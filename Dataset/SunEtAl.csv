Source Name,code,instruction,test_result.passed,cleared_code,idx
py_good_answer.csv,"def count_groups(lst):
    count = 0
    for i in range(len(lst)):
        if lst[i] != 0 and (i == 0 or lst[i-1] == 0):
            count += 1
    return count",Write Python program count number groups non-zero numbers separated zeros given list numbers.,3,"def count_groups(lst):
    count = 0
    for i in range(len(lst)):
        if lst[i] != 0 and (i == 0 or lst[i-1] == 0):
            count += 1
    return count",0
py_good_answer.csv,"class Node:  
    def __init__(self, data):  
        self.data = data  
        self.next = None  
    
class CircularLinkedList:  
    def __init__(self):  
        self.head = None  
    
    def add_to_empty(self, data):  
        if self.head is not None:  
            return  
        new_node = Node(data)  
        self.head = new_node  
        new_node.next = self.head  
    
    def add_at_end(self, data):  
        if self.head is None:  
            return self.add_to_empty(data)  
        new_node = Node(data)  
        cur = self.head  
        while cur.next != self.head:  
            cur = cur.next  
        cur.next = new_node  
        new_node.next = self.head  
    
    def search(self, x):  
        if self.head is None:  
            return None  
        cur = self.head  
        while True:  
            if cur.data == x:  
                return cur  
            cur = cur.next  
            if cur == self.head:  
                return None  
    
    def display(self):  
        if self.head is None:  
            return None  
        cur = self.head  
        while True:  
            print(cur.data, end =' ')  
            cur = cur.next  
            if cur == self.head:  
                break 
    
cllist = CircularLinkedList()  
cllist.add_to_empty(6)  
cllist.add_at_end(4)  
cllist.add_at_end(5)  
cllist.add_at_end(7)  
cllist.add_at_end(8)  
cllist.display()  
print()  
temp = cllist.search(7)  
print(temp.data)",Write Python program Search Element Circular Linked List,0,"class Node:  
    def __init__(self, data):  
        self.data = data  
        self.next = None  
class CircularLinkedList:  
    def __init__(self):  
        self.head = None  
    def add_to_empty(self, data):  
        if self.head is not None:  
            return  
        new_node = Node(data)  
        self.head = new_node  
        new_node.next = self.head  
    def add_at_end(self, data):  
        if self.head is None:  
            return self.add_to_empty(data)  
        new_node = Node(data)  
        cur = self.head  
        while cur.next != self.head:  
            cur = cur.next  
        cur.next = new_node  
        new_node.next = self.head  
    def search(self, x):  
        if self.head is None:  
            return None  
        cur = self.head  
        while True:  
            if cur.data == x:  
                return cur  
            cur = cur.next  
            if cur == self.head:  
                return None  
    def display(self):  
        if self.head is None:  
            return None  
        cur = self.head  
        while True:  
            print(cur.data, end =' ')  
            cur = cur.next  
            if cur == self.head:  
                break 
cllist = CircularLinkedList()  
cllist.add_to_empty(6)  
cllist.add_at_end(4)  
cllist.add_at_end(5)  
cllist.add_at_end(7)  
cllist.add_at_end(8)  
cllist.display()  
print()  
temp = cllist.search(7)  
print(temp.data)",1
py_good_answer.csv,"def count_elements_in_range(lst, low, high):
    count = 0
    for i in lst:
        if low <= i <= high:
            count += 1
    return count

lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
low = 3
high = 7

print(count_elements_in_range(lst, low, high))",Write Python program count number elements list within specified range.,3,"def count_elements_in_range(lst, low, high):
    count = 0
    for i in lst:
        if low <= i <= high:
            count += 1
    return count
lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
low = 3
high = 7
print(count_elements_in_range(lst, low, high))",2
py_1700_data.csv,"
def reverseAdd(nums):
    def reverse(num):
        return int(str(num)[::-1])
    
    final_arr = []
    for num in nums:
        final_arr.append(num + reverse(num))
    
    return len(set(final_arr))
","given array nums consisting positive integers. take integer array, reverse digits, add end array. apply operation original integers nums. Return number distinct integers final array.",1,"def reverseAdd(nums):
    def reverse(num):
        return int(str(num)[::-1])
    final_arr = []
    for num in nums:
        final_arr.append(num + reverse(num))
    return len(set(final_arr))
",3
py_1700_data.csv,"def minObstacles(grid):
    m = len(grid)
    n = len(grid[0])
    dp = [[float('inf') for j in range(n)] for i in range(m)]
    dp[0][0] = 0 if grid[0][0] == 0 else 1
    for i in range(1, m):
        dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else dp[i-1][0]+1
    for j in range(1, n):
        dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else dp[0][j-1]+1
    for i in range(1, m):
        for j in range(1, n):
            if grid[i][j] == 0:
                dp[i][j] = min(dp[i-1][j], dp[i][j-1])
            else:
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1
    return dp[-1][-1]","given 0-indexed 2D integer array grid size x n. cell one two values: 0 represents empty cell, 1 represents obstacle may removed. move up, down, left, right empty cell. Return minimum number obstacles remove move upper left corner (0, 0) lower right corner (m - 1, n - 1).",2,"def minObstacles(grid):
    m = len(grid)
    n = len(grid[0])
    dp = [[float('inf') for j in range(n)] for i in range(m)]
    dp[0][0] = 0 if grid[0][0] == 0 else 1
    for i in range(1, m):
        dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else dp[i-1][0]+1
    for j in range(1, n):
        dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else dp[0][j-1]+1
    for i in range(1, m):
        for j in range(1, n):
            if grid[i][j] == 0:
                dp[i][j] = min(dp[i-1][j], dp[i][j-1])
            else:
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1
    return dp[-1][-1]",4
py_1700_data.csv,"def is_anagram(t: str, s: str) -> bool:
    if len(s) != len(t):
        return False
    for char in t:
        if char not in s:
            return False
        if t.count(char) != s.count(char):
            return False
    return True","Given two strings t, return true anagram s, false otherwise. Anagram word phrase formed rearranging letters different word phrase, typically using original letters exactly once.",3,"def is_anagram(t: str, s: str) -> bool:
    if len(s) != len(t):
        return False
    for char in t:
        if char not in s:
            return False
        if t.count(char) != s.count(char):
            return False
    return True",5
py_1700_data.csv,"def kLengthApart(nums: List[int], k: int) -> bool:
    lastIdx = -1
    for i in range(len(nums)):
        if nums[i] == 1:
            if lastIdx != -1 and i - lastIdx - 1 < k:
                return False
            lastIdx = i
    return True","Given binary array nums integer k, return true 1's least k places away other, otherwise return false.",3,"def kLengthApart(nums: List[int], k: int) -> bool:
    lastIdx = -1
    for i in range(len(nums)):
        if nums[i] == 1:
            if lastIdx != -1 and i - lastIdx - 1 < k:
                return False
            lastIdx = i
    return True",6
py_1700_data.csv,"def max_consecutive_floors(bottom: int, top: int, special: List[int]) -> int:
    special_set = set(special)
    max_consecutive = 0
    current_consecutive = 0
    for i in range(bottom, top+1):
        if i not in special_set:
            current_consecutive += 1
            max_consecutive = max(max_consecutive, current_consecutive)
        else:
            current_consecutive = 0
    return max_consecutive","Alice manages company rented floors building office space. Alice decided floors special floors, used relaxation only. given two integers bottom top, denote Alice rented floors bottom top (inclusive). also given integer array special, special[i] denotes special floor Alice designated relaxation. Return maximum number consecutive floors without special floor.",3,"def max_consecutive_floors(bottom: int, top: int, special: List[int]) -> int:
    special_set = set(special)
    max_consecutive = 0
    current_consecutive = 0
    for i in range(bottom, top+1):
        if i not in special_set:
            current_consecutive += 1
            max_consecutive = max(max_consecutive, current_consecutive)
        else:
            current_consecutive = 0
    return max_consecutive",7
py_1700_data.csv,"def get_recipes_to_create(recipes, ingredients, supplies):
    recipes_to_create = []
    for i in range(len(recipes)):
        recipe_ingredients = ingredients[i]
        for ingredient in recipe_ingredients:
            if ingredient not in supplies:
                recipes_to_create.append(recipes[i])
                break
        else:
            supplies.extend(recipe_ingredients)
    return recipes_to_create","information n different recipes. given string array recipes 2D string array ingredients. ith recipe name recipes[i], create needed ingredients ingredients[i]. Ingredients recipe may need created recipes, i.e., ingredients[i] may contain string recipes. also given string array supplies containing ingredients initially have, infinite supply them. Return list recipes create. may return answer order. Note two recipes may contain ingredients.",0,"def get_recipes_to_create(recipes, ingredients, supplies):
    recipes_to_create = []
    for i in range(len(recipes)):
        recipe_ingredients = ingredients[i]
        for ingredient in recipe_ingredients:
            if ingredient not in supplies:
                recipes_to_create.append(recipes[i])
                break
        else:
            supplies.extend(recipe_ingredients)
    return recipes_to_create",8
py_1700_data.csv,"class Solution:
    def maxProduct(self, words: List[str]) -> int:
        res = 0
        for i in range(len(words)):
            for j in range(i+1, len(words)):
                if not set(words[i]) & set(words[j]): # check if no common letters
                    res = max(res, len(words[i]) * len(words[j])) # update maximum product
        return res","Given string array words, return maximum value length(word[i]) * length(word[j]) two words share common letters. two words exist, return 0.",0,"class Solution:
    def maxProduct(self, words: List[str]) -> int:
        res = 0
        for i in range(len(words)):
            for j in range(i+1, len(words)):
                if not set(words[i]) & set(words[j]): 
                    res = max(res, len(words[i]) * len(words[j])) 
        return res",9
py_1700_data.csv,"def longest_palindrome(word1, word2):
    def is_palindrome(s):
        return s == s[::-1]
    
    max_palindrome_length = 0
    for i in range(1, len(word1)+1):
        for j in range(1, len(word2)+1):
            subsequence1 = word1[:i]
            subsequence2 = word2[:j]
            combined = subsequence1 + subsequence2
            if is_palindrome(combined):
                max_palindrome_length = max(max_palindrome_length, len(combined))
                
    return max_palindrome_length","given two strings, word1 word2. want construct string following manner: Choose non-empty subsequence subsequence1 word1. Choose non-empty subsequence subsequence2 word2. Concatenate subsequences: subsequence1 + subsequence2, make string. Return length longest palindrome constructed described manner. palindromes constructed, return 0. subsequence string string made deleting (possibly none) characters without changing order remaining characters. palindrome string reads forward well backward.",3,"def longest_palindrome(word1, word2):
    def is_palindrome(s):
        return s == s[::-1]
    max_palindrome_length = 0
    for i in range(1, len(word1)+1):
        for j in range(1, len(word2)+1):
            subsequence1 = word1[:i]
            subsequence2 = word2[:j]
            combined = subsequence1 + subsequence2
            if is_palindrome(combined):
                max_palindrome_length = max(max_palindrome_length, len(combined))
    return max_palindrome_length",10
py_good_answer.csv,"from itertools import product 

def permute_with_repetitions(s, k):    
    for p in product(s, repeat=k): 
        print(''.join(p))
        
s = input(""Enter string: "")
k = int(input(""Enter number of repetitions: ""))
permute_with_repetitions(s, k)",Write Python program print permutations given repetition number characters given string.,0,"from itertools import product 
def permute_with_repetitions(s, k):    
    for p in product(s, repeat=k): 
        print(''.join(p))
s = input(""Enter string: "")
k = int(input(""Enter number of repetitions: ""))
permute_with_repetitions(s, k)",11
py_1700_data.csv,"class Solution:
    def largestTriangleArea(self, points: List[List[int]]) -> float:
        res = 0
        n = len(points)
        for i in range(n):
            for j in range(i+1, n):
                for k in range(j+1, n):
                    x1, y1 = points[i]
                    x2, y2 = points[j]
                    x3, y3 = points[k]
                    res = max(res, abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))/2)
        return res","Given array points X-Y plane points points[i] = [xi, yi], return area largest triangle formed three different points. Answers within 10-5 actual answer accepted.",3,"class Solution:
    def largestTriangleArea(self, points: List[List[int]]) -> float:
        res = 0
        n = len(points)
        for i in range(n):
            for j in range(i+1, n):
                for k in range(j+1, n):
                    x1, y1 = points[i]
                    x2, y2 = points[j]
                    x3, y3 = points[k]
                    res = max(res, abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))/2)
        return res",12
py_good_answer.csv,"
from collections import defaultdict

def count_k_distinct_substrings(s: str, k: int) -> int:
    if len(s) < k:
        return 0
    count = 0
    distinct_chars = defaultdict(int)
    start = 0
    for end in range(len(s)):
        distinct_chars[s[end]] += 1
        while len(distinct_chars) > k:
            distinct_chars[s[start]] -= 1
            if distinct_chars[s[start]] == 0:
                del distinct_chars[s[start]]
            start += 1
        if len(distinct_chars) == k:
            count += 1
    return count
",Write Python program count number substrings given string lowercase alphabets exactly k distinct (given) characters.,1,"from collections import defaultdict
def count_k_distinct_substrings(s: str, k: int) -> int:
    if len(s) < k:
        return 0
    count = 0
    distinct_chars = defaultdict(int)
    start = 0
    for end in range(len(s)):
        distinct_chars[s[end]] += 1
        while len(distinct_chars) > k:
            distinct_chars[s[start]] -= 1
            if distinct_chars[s[start]] == 0:
                del distinct_chars[s[start]]
            start += 1
        if len(distinct_chars) == k:
            count += 1
    return count
",13
py_1700_data.csv,"def longestCommonSubsequence(text1: str, text2: str) -> int:
    m = len(text1)
    n = len(text2)
    
    # create a matrix to store lengths of longest common subsequences
    lcs = [[0] * (n+1) for _ in range(m+1)]
    
    # fill the matrix using dynamic programming approach
    for i in range(1, m+1):
        for j in range(1, n+1):
            if text1[i-1] == text2[j-1]:
                lcs[i][j] = lcs[i-1][j-1] + 1
            else:
                lcs[i][j] = max(lcs[i][j-1], lcs[i-1][j])
    
    return lcs[m][n]","Given two strings text1 text2, return length longest common subsequence. common subsequence, return 0. subsequence string new string generated original string characters (can none) deleted without changing relative order remaining characters. example, ""ace"" subsequence ""abcde"". common subsequence two strings subsequence common strings.",3,"def longestCommonSubsequence(text1: str, text2: str) -> int:
    m = len(text1)
    n = len(text2)
    lcs = [[0] * (n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if text1[i-1] == text2[j-1]:
                lcs[i][j] = lcs[i-1][j-1] + 1
            else:
                lcs[i][j] = max(lcs[i][j-1], lcs[i-1][j])
    return lcs[m][n]",14
py_1700_data.csv,"
def find_arr(pref):
    n = len(pref)
    arr = [0] * n
    arr[0] = pref[0]
    for i in range(1, n):
        arr[i] = pref[i] ^ arr[i-1]
    return arr
",given integer array pref size n. Find return array arr size n satisfies: pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]. Note ^ denotes bitwise-xor operation. proven answer unique.,0,"def find_arr(pref):
    n = len(pref)
    arr = [0] * n
    arr[0] = pref[0]
    for i in range(1, n):
        arr[i] = pref[i] ^ arr[i-1]
    return arr
",15
py_1700_data.csv,"
import heapq

def maxProbability(n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:
    graph = {i:[] for i in range(n)}
    for edge, prob in zip(edges, succProb):
        graph[edge[0]].append((edge[1], prob))
        graph[edge[1]].append((edge[0], prob))

    pq = [(-1, start)]
    visited = [False] * n
    while pq:
        curr_prob, curr = heapq.heappop(pq)
        if visited[curr]:
            continue
        visited[curr] = True
        if curr == end:
            return -1 * curr_prob
        for neighbor, neighbor_prob in graph[curr]:
            if not visited[neighbor]:
                heapq.heappush(pq, (curr_prob * neighbor_prob, neighbor))
    return 0
","given undirected weighted graph n nodes (0-indexed), represented edge list edges[i] = [a, b] undirected edge connecting nodes b probability success traversing edge succProb[i]. Given two nodes start end, find path maximum probability success go start end return success probability. path start end, return 0. answer accepted differs correct answer 1e-5.",0,"import heapq
def maxProbability(n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:
    graph = {i:[] for i in range(n)}
    for edge, prob in zip(edges, succProb):
        graph[edge[0]].append((edge[1], prob))
        graph[edge[1]].append((edge[0], prob))
    pq = [(-1, start)]
    visited = [False] * n
    while pq:
        curr_prob, curr = heapq.heappop(pq)
        if visited[curr]:
            continue
        visited[curr] = True
        if curr == end:
            return -1 * curr_prob
        for neighbor, neighbor_prob in graph[curr]:
            if not visited[neighbor]:
                heapq.heappush(pq, (curr_prob * neighbor_prob, neighbor))
    return 0
",16
py_1700_data.csv,"class Solution:
    def filter_restaurants(self, restaurants: List[List[int]], vegan_friendly: int, max_price: int, max_distance: int) -> List[int]:
        filtered = []
        for r in restaurants:
            if r[2] >= vegan_friendly and r[3] <= max_price and r[4] <= max_distance:
                filtered.append(r)
        
        filtered = sorted(filtered, key=lambda x: (-x[1], -x[0]))
        return [r[0] for r in filtered]","Given array restaurants restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. filter restaurants using three filters. veganFriendly filter either true (meaning include restaurants veganFriendlyi set true) false (meaning include restaurant). addition, filters maxPrice maxDistance maximum value price distance restaurants consider respectively. Return array restaurant IDs filtering, ordered rating highest lowest. restaurants rating, order id highest lowest. simplicity veganFriendlyi veganFriendly take value 1 true, 0 false.",3,"class Solution:
    def filter_restaurants(self, restaurants: List[List[int]], vegan_friendly: int, max_price: int, max_distance: int) -> List[int]:
        filtered = []
        for r in restaurants:
            if r[2] >= vegan_friendly and r[3] <= max_price and r[4] <= max_distance:
                filtered.append(r)
        filtered = sorted(filtered, key=lambda x: (-x[1], -x[0]))
        return [r[0] for r in filtered]",17
py_good_answer.csv,"def selectionSort(arr):
    n = len(arr)

    for i in range(n):

        min_idx = i

        for j in range(i+1, n):
            if arr[min_idx] > arr[j]:
                min_idx = j

        arr[i], arr[min_idx] = arr[min_idx], arr[i]

    return arr

arr = [64, 25, 12, 22, 11]
print(""Original array: "")
print(arr)
print(""Sorted array: "")
print(selectionSort(arr))",Write Python program sort list elements using Selection sort.,3,"def selectionSort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[min_idx] > arr[j]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr
arr = [64, 25, 12, 22, 11]
print(""Original array: "")
print(arr)
print(""Sorted array: "")
print(selectionSort(arr))",18
py_1700_data.csv,"
def count_primes(n):
    if n <= 2:
        return 0
    primes = [True] * n
    primes[0] = primes[1] = False
    for i in range(2, int(n ** 0.5) + 1):
        if primes[i]:
            primes[i*i:n:i] = [False] * ((n-1-i*i)//i + 1)
    return sum(primes)
","Given integer n, return number prime numbers strictly less n.",3,"def count_primes(n):
    if n <= 2:
        return 0
    primes = [True] * n
    primes[0] = primes[1] = False
    for i in range(2, int(n ** 0.5) + 1):
        if primes[i]:
            primes[i*i:n:i] = [False] * ((n-1-i*i)//i + 1)
    return sum(primes)
",19
py_1700_data.csv,"def maximize_num(n: str, x: int) -> str:
    sign = ''
    if n[0] == '-':
        sign = '-'
        n = n[1:]
    for i in range(len(n)):
        if int(n[i]) < x:
            return sign + n[:i] + str(x) + n[i:]
    return sign + n + str(x)","given large integer n, represented string,?????? integer digit x. digits n digit x inclusive range [1, 9], n may represent negative number. want maximize n's numerical value inserting x anywhere decimal representation n??????. cannot insert x left negative sign. example, n = 73 x = 6, would best insert 7 3, making n = 763. n = -55 x = 2, would best insert first 5, making n = -255. Return string representing maximum value n?????? insertion.",2,"def maximize_num(n: str, x: int) -> str:
    sign = ''
    if n[0] == '-':
        sign = '-'
        n = n[1:]
    for i in range(len(n)):
        if int(n[i]) < x:
            return sign + n[:i] + str(x) + n[i:]
    return sign + n + str(x)",20
py_1700_data.csv,"def fibonacci(n):
    if n <= 1:
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(""Enter a number: ""))

print(""Fibonacci series:"")
for i in range(n):
    print(fibonacci(i))","Fibonacci numbers, commonly denoted F(n) form sequence, called Fibonacci sequence, number sum two preceding ones, starting 0 1. is, F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), n > 1. Given n, calculate F(n).",1,"def fibonacci(n):
    if n <= 1:
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))
n = int(input(""Enter a number: ""))
print(""Fibonacci series:"")
for i in range(n):
    print(fibonacci(i))",21
py_good_answer.csv,"from collections import Counter

def min_subsets_distinct_elements(lst):
    freq = Counter(lst)
    num_subsets = 0
    while freq:
        element, count = freq.most_common()[-1]
        del freq[element]
        num_subsets += 1
        for i in range(count - 1):
            if not freq[element + 1]:
                break
            element += 1
            count -= 1
            del freq[element]
    return num_subsets",Write Python program Minimum number subsets distinct elements using Counter,0,"from collections import Counter
def min_subsets_distinct_elements(lst):
    freq = Counter(lst)
    num_subsets = 0
    while freq:
        element, count = freq.most_common()[-1]
        del freq[element]
        num_subsets += 1
        for i in range(count - 1):
            if not freq[element + 1]:
                break
            element += 1
            count -= 1
            del freq[element]
    return num_subsets",22
py_1700_data.csv,"def min_abs_difference(nums, goal):
    n = len(nums)
    best = abs(sum(nums) - goal)
    for i in range(1, 2**n):
        sub = [nums[j] for j in range(n) if (i & (1<<j))]
        diff = abs(sum(sub) - goal)
        if diff < best:
            best = diff
    return best","given integer array nums integer goal. want choose subsequence nums sum elements closest possible goal. is, sum subsequence's elements sum, want minimize absolute difference abs(sum - goal). Return minimum possible value abs(sum - goal). Note subsequence array array formed removing elements (possibly none) original array.",0,"def min_abs_difference(nums, goal):
    n = len(nums)
    best = abs(sum(nums) - goal)
    for i in range(1, 2**n):
        sub = [nums[j] for j in range(n) if (i & (1<<j))]
        diff = abs(sum(sub) - goal)
        if diff < best:
            best = diff
    return best",23
py_1700_data.csv,"def lcaDeepestLeaves(root):
    def depth(node):
        if not node: return 0
        return 1 + max(depth(node.left), depth(node.right))
    
    def lca(node, d):
        if not node or depth(node) == d: return node
        
        left, right = lca(node.left, d), lca(node.right, d)
        if left and right: return node
        return left or right
    
    d = depth(root)
    return lca(root, d)","Given root binary tree, return lowest common ancestor deepest leaves. Recall that: node binary tree leaf children depth root tree 0. depth node d, depth children + 1. lowest common ancestor set nodes, node largest depth every node subtree root A.",0,"def lcaDeepestLeaves(root):
    def depth(node):
        if not node: return 0
        return 1 + max(depth(node.left), depth(node.right))
    def lca(node, d):
        if not node or depth(node) == d: return node
        left, right = lca(node.left, d), lca(node.right, d)
        if left and right: return node
        return left or right
    d = depth(root)
    return lca(root, d)",24
py_1700_data.csv,"def numDecodings(encoded_message: str) -> int:
    mod = 10**9 + 7
    
    # Reverse mapping dictionary
    reverse_mapping = {}
    for i in range(1, 27):
        reverse_mapping[str(i)] = chr(ord('A') + i - 1)
    
    # Dynamic programming array to store number of ways
    # to decode substring ending at index i
    dp = [0] * (len(encoded_message) + 1)
    dp[0] = 1
    
    for i in range(1, len(dp)):
        # If current digit is '*', it can represent '1' to '9'
        if encoded_message[i - 1] == '*':
            dp[i] += 9 * dp[i - 1] % mod
            if i > 1 and encoded_message[i - 2] == '1':
                dp[i] += 9 * dp[i - 2] % mod
            elif i > 1 and encoded_message[i - 2] == '2':
                dp[i] += 6 * dp[i - 2] % mod
        else:
            # Try to decode current digit as a single letter
            if encoded_message[i - 1] != '0':
                dp[i] = dp[i - 1]
            # Try to decode current digit as part of a two-digit number
            if i > 1:
                two_digit_code = encoded_message[i - 2:i]
                if '10' <= two_digit_code <= '26':
                    dp[i] += dp[i - 2] % mod
        
        dp[i] %= mod
    
    return dp[-1]","message containing letters A-Z encoded numbers using following mapping: 'A' -> ""1"" 'B' -> ""2"" ... 'Z' -> ""26"" decode encoded message, digits must grouped mapped back letters using reverse mapping (there may multiple ways). example, ""11106"" mapped into: ""AAJF"" grouping (1 1 10 6) ""KJF"" grouping (11 10 6) Note grouping (1 11 06) invalid ""06"" cannot mapped 'F' since ""6"" different ""06"". addition mapping above, encoded message may contain '*' character, represent digit '1' '9' ('0' excluded). example, encoded message ""1*"" may represent encoded messages ""11"", ""12"", ""13"", ""14"", ""15"", ""16"", ""17"", ""18"", ""19"". Decoding ""1*"" equivalent decoding encoded messages represent. Given string consisting digits '*' characters, return number ways decode it. Since answer may large, return modulo 109 + 7.",3,"def numDecodings(encoded_message: str) -> int:
    mod = 10**9 + 7
    reverse_mapping = {}
    for i in range(1, 27):
        reverse_mapping[str(i)] = chr(ord('A') + i - 1)
    dp = [0] * (len(encoded_message) + 1)
    dp[0] = 1
    for i in range(1, len(dp)):
        if encoded_message[i - 1] == '*':
            dp[i] += 9 * dp[i - 1] % mod
            if i > 1 and encoded_message[i - 2] == '1':
                dp[i] += 9 * dp[i - 2] % mod
            elif i > 1 and encoded_message[i - 2] == '2':
                dp[i] += 6 * dp[i - 2] % mod
        else:
            if encoded_message[i - 1] != '0':
                dp[i] = dp[i - 1]
            if i > 1:
                two_digit_code = encoded_message[i - 2:i]
                if '10' <= two_digit_code <= '26':
                    dp[i] += dp[i - 2] % mod
        dp[i] %= mod
    return dp[-1]",25
py_1700_data.csv,"class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def feasible(speed: int) -> bool:
            time = sum((pile - 1) // speed + 1 for pile in piles)
            return time <= h
                    
        left, right = 1, max(piles)
        while left < right:
            mid = (left + right) // 2
            if feasible(mid):
                right = mid
            else:
                left = mid + 1
        return left","Koko loves eat bananas. n piles bananas, ith pile piles[i] bananas. guards gone come back h hours. Koko decide bananas-per-hour eating speed k. hour, chooses pile bananas eats k bananas pile. pile less k bananas, eats instead eat bananas hour. Koko likes eat slowly still wants finish eating bananas guards return. Return minimum integer k eat bananas within h hours.",3,"class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def feasible(speed: int) -> bool:
            time = sum((pile - 1) // speed + 1 for pile in piles)
            return time <= h
        left, right = 1, max(piles)
        while left < right:
            mid = (left + right) // 2
            if feasible(mid):
                right = mid
            else:
                left = mid + 1
        return left",26
py_good_answer.csv,"
def sort_last(tuples):
    return sorted(tuples, key=lambda x: x[-1])
","Write Python program get list, sorted increasing order last element tuple given list non-empty tuples.",3,"def sort_last(tuples):
    return sorted(tuples, key=lambda x: x[-1])
",27
py_1700_data.csv,"
def max_difference(nums):
    max_diff = -1
    min_num = float('inf')
    for num in nums:
        max_diff = max(max_diff, num - min_num)
        min_num = min(min_num, num)
    return max_diff if max_diff != 0 else -1
","Given 0-indexed integer array nums size n, find maximum difference nums[i] nums[j] (i.e., nums[j] - nums[i]), 0 <= < j < n nums[i] < nums[j]. Return maximum difference. j exists, return -1.",3,"def max_difference(nums):
    max_diff = -1
    min_num = float('inf')
    for num in nums:
        max_diff = max(max_diff, num - min_num)
        min_num = min(min_num, num)
    return max_diff if max_diff != 0 else -1
",28
py_1700_data.csv,"
class Solution:
    def printVertically(self, s: str) -> List[str]:
        words = s.split()
        max_len = max(len(word) for word in words)
        res = [' ' * len(words) for _ in range(max_len)]
        for i, word in enumerate(words):
            for j, c in enumerate(word):
                res[j] = res[j][:i] + c + res[j][i + 1:]
        return res
","Given string s. Return words vertically order appear s. Words returned list strings, complete spaces necessary. (Trailing spaces allowed). word would put one column one column one word.",1,"class Solution:
    def printVertically(self, s: str) -> List[str]:
        words = s.split()
        max_len = max(len(word) for word in words)
        res = [' ' * len(words) for _ in range(max_len)]
        for i, word in enumerate(words):
            for j, c in enumerate(word):
                res[j] = res[j][:i] + c + res[j][i + 1:]
        return res
",29
py_1700_data.csv,"
class Solution:
    def angleClock(self, hour: int, minutes: int) -> float:
        h = (hour % 12 + minutes / 60) * 30
        m = 6 * minutes
        angle = abs(h - m)
        return min(angle, 360 - angle)
","Given two numbers, hour minutes, return smaller angle (in degrees) formed hour minute hand. Answers within 10-5 actual value accepted correct.",3,"class Solution:
    def angleClock(self, hour: int, minutes: int) -> float:
        h = (hour % 12 + minutes / 60) * 30
        m = 6 * minutes
        angle = abs(h - m)
        return min(angle, 360 - angle)
",30
py_1700_data.csv,"def rank_matrix(matrix):
    n = len(matrix)
    m = len(matrix[0])
    ranks = [[0] * m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            rank = 1
            for k in range(n):
                for l in range(m):
                    if matrix[k][l] > matrix[i][j]:
                        rank += 1
            ranks[i][j] = rank
    return ranks","Given x n matrix, return new matrix answer answer[row][col] rank matrix[row][col]. rank integer represents large element compared elements. calculated using following rules: rank integer starting 1. two elements p q row column, then: p < q rank(p) < rank(q) p == q rank(p) == rank(q) p > q rank(p) > rank(q) rank small possible. test cases generated answer unique given rules.",0,"def rank_matrix(matrix):
    n = len(matrix)
    m = len(matrix[0])
    ranks = [[0] * m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            rank = 1
            for k in range(n):
                for l in range(m):
                    if matrix[k][l] > matrix[i][j]:
                        rank += 1
            ranks[i][j] = rank
    return ranks",31
py_good_answer.csv,"def remove_duplicates(lst):
    return [lst[i] for i in range(len(lst)) if lst[i] != lst[i-1] or i == 0]",Write Python program remove consecutive duplicates given list.,0,"def remove_duplicates(lst):
    return [lst[i] for i in range(len(lst)) if lst[i] != lst[i-1] or i == 0]",32
py_1700_data.csv,"def beautifulArray(n):
    res = [1]
    while len(res) < n:
        res = [i * 2 - 1 for i in res] + [i * 2 for i in res]
    return [i for i in res if i <= n]","array nums length n beautiful if: nums permutation integers range [1, n]. every 0 <= < j < n, index k < k < j 2 * nums[k] == nums[i] + nums[j]. Given integer n, return beautiful array nums length n. least one valid answer given n.",1,"def beautifulArray(n):
    res = [1]
    while len(res) < n:
        res = [i * 2 - 1 for i in res] + [i * 2 for i in res]
    return [i for i in res if i <= n]",33
py_good_answer.csv,"import itertools

def shortest_distance(s: str, c: str) -> List[int]:
    distances = []
    for i, j in itertools.combinations(range(len(s)), 2):
        if s[i] == c or s[j] == c:
            if s[i] == s[j]:
                distances.append(abs(i-j))
            else:
                distances.append(abs(i-j)//2)
    return distances",Write Python program find shortest distance specified character given string. Return shortest distances list use itertools module solve problem.,0,"import itertools
def shortest_distance(s: str, c: str) -> List[int]:
    distances = []
    for i, j in itertools.combinations(range(len(s)), 2):
        if s[i] == c or s[j] == c:
            if s[i] == s[j]:
                distances.append(abs(i-j))
            else:
                distances.append(abs(i-j)//2)
    return distances",34
py_1700_data.csv,"def num_operations(num1, num2):
    count = 0
    while num1 > 0 and num2 > 0:
        if num1 >= num2:
            num1 -= num2
        else:
            num2 -= num1
        count += 1
    return count","given two non-negative integers num1 num2. one operation, num1 >= num2, must subtract num2 num1, otherwise subtract num1 num2. example, num1 = 5 num2 = 4, subtract num2 num1, thus obtaining num1 = 1 num2 = 4. However, num1 = 4 num2 = 5, one operation, num1 = 4 num2 = 1. Return number operations required make either num1 = 0 num2 = 0.",3,"def num_operations(num1, num2):
    count = 0
    while num1 > 0 and num2 > 0:
        if num1 >= num2:
            num1 -= num2
        else:
            num2 -= num1
        count += 1
    return count",35
py_good_answer.csv,"def bitonic_sort(arr, direction):
    def merge(arr, direction):
        if len(arr) > 1:
            half = len(arr)//2
            arr_left = arr[:half]
            arr_right = arr[half:]
            if direction == ""up"":
                arr_left = bitonic_sort(arr_left, ""up"")
                arr_right = bitonic_sort(arr_right, ""down"")
            else:
                arr_left = bitonic_sort(arr_left, ""down"")
                arr_right = bitonic_sort(arr_right, ""up"")
            arr = arr_left + arr_right
            if direction == ""up"":
                arr = arr[::-1]
        return arr
    
    if len(arr) > 1:
        half = len(arr)//2
        arr_left = arr[:half]
        arr_right = arr[half:]
        if direction == ""up"":
            arr_left = bitonic_sort(arr_left, ""up"")
            arr_right = bitonic_sort(arr_right, ""down"")
        else:
            arr_left = bitonic_sort(arr_left, ""down"")
            arr_right = bitonic_sort(arr_right, ""up"")
        arr = merge(arr_left + arr_right, direction)
    return arr",Write Python code create program Bitonic Sort.,0,"def bitonic_sort(arr, direction):
    def merge(arr, direction):
        if len(arr) > 1:
            half = len(arr)//2
            arr_left = arr[:half]
            arr_right = arr[half:]
            if direction == ""up"":
                arr_left = bitonic_sort(arr_left, ""up"")
                arr_right = bitonic_sort(arr_right, ""down"")
            else:
                arr_left = bitonic_sort(arr_left, ""down"")
                arr_right = bitonic_sort(arr_right, ""up"")
            arr = arr_left + arr_right
            if direction == ""up"":
                arr = arr[::-1]
        return arr
    if len(arr) > 1:
        half = len(arr)//2
        arr_left = arr[:half]
        arr_right = arr[half:]
        if direction == ""up"":
            arr_left = bitonic_sort(arr_left, ""up"")
            arr_right = bitonic_sort(arr_right, ""down"")
        else:
            arr_left = bitonic_sort(arr_left, ""down"")
            arr_right = bitonic_sort(arr_right, ""up"")
        arr = merge(arr_left + arr_right, direction)
    return arr",36
py_1700_data.csv,"def predictPartyVictory(senate):
    radiant = []
    dire = []
    n = len(senate)
    for i in range(n):
        if senate[i] == 'R':
            radiant.append(i)
        else:
            dire.append(i)
    while radiant and dire:
        if radiant[0] < dire[0]:
            radiant.append(radiant[0] + n)
        else:
            dire.append(dire[0] + n)
        radiant.pop(0)
        dire.pop(0)
    return ""Radiant"" if radiant else ""Dire""","world Dota2, two parties: Radiant Dire. Dota2 senate consists senators coming two parties. Senate wants decide change Dota2 game. voting change round-based procedure. round, senator exercise one two rights: Ban one senator's right: senator make another senator lose rights following rounds. Announce victory: senator found senators still rights vote party, announce victory decide change game. Given string senate representing senator's party belonging. character 'R' 'D' represent Radiant party Dire party. n senators, size given string n. round-based procedure starts first senator last senator given order. procedure last end voting. senators lost rights skipped procedure. Suppose every senator smart enough play best strategy party. Predict party finally announce victory change Dota2 game. output ""Radiant"" ""Dire"".",3,"def predictPartyVictory(senate):
    radiant = []
    dire = []
    n = len(senate)
    for i in range(n):
        if senate[i] == 'R':
            radiant.append(i)
        else:
            dire.append(i)
    while radiant and dire:
        if radiant[0] < dire[0]:
            radiant.append(radiant[0] + n)
        else:
            dire.append(dire[0] + n)
        radiant.pop(0)
        dire.pop(0)
    return ""Radiant"" if radiant else ""Dire""",37
py_good_answer.csv,"def get_string(string):
    if len(string) >= 2:
        last_two_char = string[-2:] * 4
        return last_two_char
    else:
        return ""String should be at least of length 2""",Write Python function get string made 4 copies last two characters specified string (length must least 2).,3,"def get_string(string):
    if len(string) >= 2:
        last_two_char = string[-2:] * 4
        return last_two_char
    else:
        return ""String should be at least of length 2""",38
py_1700_data.csv,"
def reverseSubarray(nums, start, end):
    while start < end:
        nums[start], nums[end] = nums[end], nums[start]
        start += 1
        end -= 1

def maxAbsDiff(nums):
    n = len(nums)
    ans = 0
    for i in range(n-1):
        ans += abs(nums[i] - nums[i+1])
    best = 0
    for i in range(1, n):
        if nums[i] < nums[i-1]:
            best = max(best, ans - 2*abs(nums[i-1] - nums[i]))
    if best != 0:
        reverseSubarray(nums, 0, n-1)
        for i in range(1, n):
            if nums[i] < nums[i-1]:
                best = max(best, ans - 2*abs(nums[i-1] - nums[i]))
        ans = best
    return ans
",given integer array nums. value array defined sum |nums[i] - nums[i + 1]| 0 <= < nums.length - 1. allowed select subarray given array reverse it. perform operation once. Find maximum possible value final array.,0,"def reverseSubarray(nums, start, end):
    while start < end:
        nums[start], nums[end] = nums[end], nums[start]
        start += 1
        end -= 1
def maxAbsDiff(nums):
    n = len(nums)
    ans = 0
    for i in range(n-1):
        ans += abs(nums[i] - nums[i+1])
    best = 0
    for i in range(1, n):
        if nums[i] < nums[i-1]:
            best = max(best, ans - 2*abs(nums[i-1] - nums[i]))
    if best != 0:
        reverseSubarray(nums, 0, n-1)
        for i in range(1, n):
            if nums[i] < nums[i-1]:
                best = max(best, ans - 2*abs(nums[i-1] - nums[i]))
        ans = best
    return ans
",39
py_1700_data.csv,"def min_food_buckets(hamsters):
    n = len(hamsters)
    empty_indices = [i for i in range(n) if hamsters[i] == '.']
    food_buckets = 0
    for i in range(n):
        if hamsters[i] == 'H':
            left = i - 1
            right = i + 1
            while left >= 0 and hamsters[left] == '.':
                hamsters[left] = 'F'
                food_buckets += 1
                left -= 1
            while right < n and hamsters[right] == '.':
                hamsters[right] = 'F'
                food_buckets += 1
                right += 1
    for i in empty_indices:
        if hamsters[i] == '.':
            return -1
    return food_buckets - len(empty_indices)","given 0-indexed string hamsters hamsters[i] either: 'H' indicating hamster index i, '.' indicating index empty. add number food buckets empty indices order feed hamsters. hamster fed least one food bucket left right. formally, hamster index fed place food bucket index - 1 and/or index + 1. Return minimum number food buckets place empty indices feed hamsters -1 impossible feed them.",0,"def min_food_buckets(hamsters):
    n = len(hamsters)
    empty_indices = [i for i in range(n) if hamsters[i] == '.']
    food_buckets = 0
    for i in range(n):
        if hamsters[i] == 'H':
            left = i - 1
            right = i + 1
            while left >= 0 and hamsters[left] == '.':
                hamsters[left] = 'F'
                food_buckets += 1
                left -= 1
            while right < n and hamsters[right] == '.':
                hamsters[right] = 'F'
                food_buckets += 1
                right += 1
    for i in empty_indices:
        if hamsters[i] == '.':
            return -1
    return food_buckets - len(empty_indices)",40
py_good_answer.csv,"
def find_shortest_keys(d):
    shortest = None
    for key, value in d.items():
        if shortest is None or len(value) < len(d[shortest]):
            shortest = key
    return shortest
",Write Python program find shortest list values keys given dictionary.,2,"def find_shortest_keys(d):
    shortest = None
    for key, value in d.items():
        if shortest is None or len(value) < len(d[shortest]):
            shortest = key
    return shortest
",41
py_1700_data.csv,"def numDistinct(s: str, t: str) -> int:
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        dp[i][0] = 1
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            dp[i][j] = dp[i - 1][j]
            if s[i - 1] == t[j - 1]:
                dp[i][j] += dp[i - 1][j - 1]
    return dp[m][n]","Given two strings t, return number distinct subsequences equals t. test cases generated answer fits 32-bit signed integer.",3,"def numDistinct(s: str, t: str) -> int:
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        dp[i][0] = 1
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            dp[i][j] = dp[i - 1][j]
            if s[i - 1] == t[j - 1]:
                dp[i][j] += dp[i - 1][j - 1]
    return dp[m][n]",42
py_70_data.csv,"def is_palindrome_string(s):
    return s == s[::-1]",Python program check String palindrome not.,3,"def is_palindrome_string(s):
    return s == s[::-1]",43
py_1700_data.csv,"
class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        left, right = 0, 0
        zeros = 0
        res = 0
        while right < len(nums):
            if nums[right] == 0:
                zeros += 1
            while zeros > k:
                if nums[left] == 0:
                    zeros -= 1
                left += 1
            res = max(res, right - left + 1)
            right += 1
        return res
","Given binary array nums integer k, return maximum number consecutive 1's array flip k 0's.",3,"class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        left, right = 0, 0
        zeros = 0
        res = 0
        while right < len(nums):
            if nums[right] == 0:
                zeros += 1
            while zeros > k:
                if nums[left] == 0:
                    zeros -= 1
                left += 1
            res = max(res, right - left + 1)
            right += 1
        return res
",44
py_good_answer.csv,"def counting_sort(arr, max_val):
    m = max_val + 1
    count = [0] * m                
    
    for a in arr:
        count[a] += 1              
    i = 0
    for a in range(m):            
        for c in range(count[a]):  
            arr[i] = a
            i += 1
    return arr",Python Program Implement Counting Sort,3,"def counting_sort(arr, max_val):
    m = max_val + 1
    count = [0] * m                
    for a in arr:
        count[a] += 1              
    i = 0
    for a in range(m):            
        for c in range(count[a]):  
            arr[i] = a
            i += 1
    return arr",45
py_1700_data.csv,"def fully_typable_words(text: str, brokenLetters: str) -> int:
    count = 0
    for word in text.split():
        broken = False
        for letter in brokenLetters:
            if letter in word:
                broken = True
        if not broken:
            count += 1
    return count","malfunctioning keyboard letter keys work. keys keyboard work properly. Given string text words separated single space (no leading trailing spaces) string brokenLetters distinct letter keys broken, return number words text fully type using keyboard.",3,"def fully_typable_words(text: str, brokenLetters: str) -> int:
    count = 0
    for word in text.split():
        broken = False
        for letter in brokenLetters:
            if letter in word:
                broken = True
        if not broken:
            count += 1
    return count",46
py_1700_data.csv,"def corpFlightBookings(bookings: List[List[int]], n: int) -> List[int]:
    res = [0] * n
    for i, j, k in bookings:
        res[i - 1] += k
        if j < n:
            res[j] -= k
    for i in range(1, n):
        res[i] += res[i - 1]
    return res","n flights labeled 1 n. given array flight bookings bookings, bookings[i] = [firsti, lasti, seatsi] represents booking flights firsti lasti (inclusive) seatsi seats reserved flight range. Return array answer length n, answer[i] total number seats reserved flight i.",3,"def corpFlightBookings(bookings: List[List[int]], n: int) -> List[int]:
    res = [0] * n
    for i, j, k in bookings:
        res[i - 1] += k
        if j < n:
            res[j] -= k
    for i in range(1, n):
        res[i] += res[i - 1]
    return res",47
py_1700_data.csv,"
def reformat_number(number):
    digits = [char for char in number if char.isdigit()]
    num_digits = len(digits)
    blocks = []
    i = 0 
    while i < num_digits:
        if num_digits - i == 4:
            blocks.append(''.join(digits[i:i+2]))
            blocks.append(''.join(digits[i+2:i+4]))
            i += 4
        elif num_digits - i in [1, 2, 3]:
            blocks.append(''.join(digits[i:]))
            i += num_digits - i
        else:
            blocks.append(''.join(digits[i:i+3]))
            i += 3
    return '-'.join(blocks)
","given phone number string number. number consists digits, spaces ' ', and/or dashes '-'. would like reformat phone number certain manner. Firstly, remove spaces dashes. Then, group digits left right blocks length 3 4 fewer digits. final digits grouped follows: 2 digits: single block length 2. 3 digits: single block length 3. 4 digits: Two blocks length 2 each. blocks joined dashes. Notice reformatting process never produce blocks length 1 produce two blocks length 2. Return phone number formatting.",3,"def reformat_number(number):
    digits = [char for char in number if char.isdigit()]
    num_digits = len(digits)
    blocks = []
    i = 0 
    while i < num_digits:
        if num_digits - i == 4:
            blocks.append(''.join(digits[i:i+2]))
            blocks.append(''.join(digits[i+2:i+4]))
            i += 4
        elif num_digits - i in [1, 2, 3]:
            blocks.append(''.join(digits[i:]))
            i += num_digits - i
        else:
            blocks.append(''.join(digits[i:i+3]))
            i += 3
    return '-'.join(blocks)
",48
py_1700_data.csv,"def remove_duplicates(s: str, k: int) -> str:
    stack = []
    for char in s:
        if not stack or stack[-1][0] != char:
            stack.append([char, 1])
        else:
            count = stack[-1][1] + 1
            if count == k:
                stack.pop()
            else:
                stack[-1][1] = count
    result = []
    for char, count in stack:
        result.append(char * count)
    return ''.join(result)","given string integer k, k duplicate removal consists choosing k adjacent equal letters removing them, causing left right side deleted substring concatenate together. repeatedly make k duplicate removals longer can. Return final string duplicate removals made. guaranteed answer unique.",3,"def remove_duplicates(s: str, k: int) -> str:
    stack = []
    for char in s:
        if not stack or stack[-1][0] != char:
            stack.append([char, 1])
        else:
            count = stack[-1][1] + 1
            if count == k:
                stack.pop()
            else:
                stack[-1][1] = count
    result = []
    for char, count in stack:
        result.append(char * count)
    return ''.join(result)",49
py_good_answer.csv,"def tree_sort(lst):
    class Node:
        def __init__(self, val=None):
            self.left = None
            self.right = None
            self.val = val
        
        def insert(self, val):
            if self.val is None:
                self.val = val
                return self
            if val < self.val:
                if self.left is None:
                    self.left = Node(val)
                    return self.left
                else:
                    return self.left.insert(val)
            else:
                if self.right is None:
                    self.right = Node(val)
                    return self.right
                else:
                    return self.right.insert(val)
        
        def inorder(self):
            if self.left is not None:
                yield from self.left.inorder()
            if self.val is not None:
                yield self.val
            if self.right is not None:
                yield from self.right.inorder()
    
    root = Node()
    for x in lst:
        root.insert(x)
    return list(root.inorder())",Write Python program sort list elements using Tree sort.,2,"def tree_sort(lst):
    class Node:
        def __init__(self, val=None):
            self.left = None
            self.right = None
            self.val = val
        def insert(self, val):
            if self.val is None:
                self.val = val
                return self
            if val < self.val:
                if self.left is None:
                    self.left = Node(val)
                    return self.left
                else:
                    return self.left.insert(val)
            else:
                if self.right is None:
                    self.right = Node(val)
                    return self.right
                else:
                    return self.right.insert(val)
        def inorder(self):
            if self.left is not None:
                yield from self.left.inorder()
            if self.val is not None:
                yield self.val
            if self.right is not None:
                yield from self.right.inorder()
    root = Node()
    for x in lst:
        root.insert(x)
    return list(root.inorder())",50
py_good_answer.csv,"import types 

def check_generator(func):
    return isinstance(func(), types.GeneratorType)",Write Python program check given function generator not. Use types.GeneratorType(),0,"import types 
def check_generator(func):
    return isinstance(func(), types.GeneratorType)",51
py_1700_data.csv,"def shiftingLetters(s: str, shifts: List[int]) -> str:
    for i in range(len(shifts)-2, -1, -1):
        shifts[i] += shifts[i+1]
    
    res = """"
    for i in range(len(s)):
        res += chr((ord(s[i]) - 97 + shifts[i]) % 26 + 97)
    
    return res","given string lowercase English letters integer array shifts length. Call shift() letter, next letter alphabet, (wrapping around 'z' becomes 'a'). example, shift('a') = 'b', shift('t') = 'u', shift('z') = 'a'. shifts[i] = x, want shift first + 1 letters s, x times. Return final string shifts applied.",3,"def shiftingLetters(s: str, shifts: List[int]) -> str:
    for i in range(len(shifts)-2, -1, -1):
        shifts[i] += shifts[i+1]
    res = """"
    for i in range(len(s)):
        res += chr((ord(s[i]) - 97 + shifts[i]) % 26 + 97)
    return res",52
py_good_answer.csv,"def check_parenthesis(expr):
    stack = []
    for char in expr:
        if char in [""("", ""{"", ""[""]:
            stack.append(char)
        else:
            if not stack:
                return False
            current_char = stack.pop()
            if current_char == ""("":
                if char != "")"":
                    return False
            if current_char == ""{"":
                if char != ""}"":
                    return False
            if current_char == ""["":
                if char != ""]"":
                    return False

    if stack:
        return False
    return True",Python Program Check Expression correctly Parenthesized,2,"def check_parenthesis(expr):
    stack = []
    for char in expr:
        if char in [""("", ""{"", ""[""]:
            stack.append(char)
        else:
            if not stack:
                return False
            current_char = stack.pop()
            if current_char == ""("":
                if char != "")"":
                    return False
            if current_char == ""{"":
                if char != ""}"":
                    return False
            if current_char == ""["":
                if char != ""]"":
                    return False
    if stack:
        return False
    return True",53
py_good_answer.csv,"def insertionSort(arr):
   for i in range(1, len(arr)):

      key = arr[i]

      j = i-1
      while j >= 0 and key < arr[j] :
         arr[j+1] = arr[j]
         j -= 1
      arr[j+1] = key
   return arr",Python Program Implement Insertion Sort,0,"def insertionSort(arr):
   for i in range(1, len(arr)):
      key = arr[i]
      j = i-1
      while j >= 0 and key < arr[j] :
         arr[j+1] = arr[j]
         j -= 1
      arr[j+1] = key
   return arr",54
py_1700_data.csv,"
def minCost(nums, cost):
    n = len(nums)
    total_cost = 0
    
    for i in range(n-1):
        curr_max = nums[i]
        j = i+1
        temp_sum = nums[i]
        curr_sum = nums[i]
        while j<n and nums[i]==nums[j]:
            curr_sum += nums[i]
            temp_sum += nums[j]
            curr_max = max(curr_max, nums[j])
            j += 1
        if curr_sum != temp_sum:
            total_cost += sum(cost[i:j]) - curr_max*(j-i) 
        
    return total_cost
",given two 0-indexed arrays nums cost consisting n positive integers. following operation number times: Increase decrease element array nums 1. cost one operation ith element cost[i]. Return minimum total cost elements array nums become equal.,1,"def minCost(nums, cost):
    n = len(nums)
    total_cost = 0
    for i in range(n-1):
        curr_max = nums[i]
        j = i+1
        temp_sum = nums[i]
        curr_sum = nums[i]
        while j<n and nums[i]==nums[j]:
            curr_sum += nums[i]
            temp_sum += nums[j]
            curr_max = max(curr_max, nums[j])
            j += 1
        if curr_sum != temp_sum:
            total_cost += sum(cost[i:j]) - curr_max*(j-i) 
    return total_cost
",55
py_1700_data.csv,"MOD = 10**9 + 7

def rectangleArea(rectangles):
    xSet = set()
    ySet = set()
    for rect in rectangles:
        xSet.add(rect[0])
        xSet.add(rect[2])
        ySet.add(rect[1])
        ySet.add(rect[3])
    xList = sorted(list(xSet))
    yList = sorted(list(ySet))
    rows = len(yList)
    cols = len(xList)
    grid = [[0] * cols for _ in range(rows)]
    for rect in rectangles:
        x1, y1, x2, y2 = rect
        x1Idx = bisect.bisect_left(xList, x1)
        y1Idx = bisect.bisect_left(yList, y1)
        x2Idx = bisect.bisect_left(xList, x2)
        y2Idx = bisect.bisect_left(yList, y2)
        for row in range(y1Idx, y2Idx):
            for col in range(x1Idx, x2Idx):
                grid[row][col] = 1
    totalArea = 0
    for row in range(rows):
        for col in range(cols):
            if grid[row][col] == 1:
                cellArea = (xList[col+1] - xList[col]) * (yList[row+1] - yList[row])
                totalArea += cellArea
    return totalArea % MOD","given 2D array axis-aligned rectangles. rectangle[i] = [xi1, yi1, xi2, yi2] denotes ith rectangle (xi1, yi1) coordinates bottom-left corner, (xi2, yi2) coordinates top-right corner. Calculate total area covered rectangles plane. area covered two rectangles counted once. Return total area. Since answer may large, return modulo 109 + 7.",0,"MOD = 10**9 + 7
def rectangleArea(rectangles):
    xSet = set()
    ySet = set()
    for rect in rectangles:
        xSet.add(rect[0])
        xSet.add(rect[2])
        ySet.add(rect[1])
        ySet.add(rect[3])
    xList = sorted(list(xSet))
    yList = sorted(list(ySet))
    rows = len(yList)
    cols = len(xList)
    grid = [[0] * cols for _ in range(rows)]
    for rect in rectangles:
        x1, y1, x2, y2 = rect
        x1Idx = bisect.bisect_left(xList, x1)
        y1Idx = bisect.bisect_left(yList, y1)
        x2Idx = bisect.bisect_left(xList, x2)
        y2Idx = bisect.bisect_left(yList, y2)
        for row in range(y1Idx, y2Idx):
            for col in range(x1Idx, x2Idx):
                grid[row][col] = 1
    totalArea = 0
    for row in range(rows):
        for col in range(cols):
            if grid[row][col] == 1:
                cellArea = (xList[col+1] - xList[col]) * (yList[row+1] - yList[row])
                totalArea += cellArea
    return totalArea % MOD",56
py_1700_data.csv,"def decode_slanted_transposition(encodedText, rows):
    cols = math.ceil(len(encodedText)/rows)
    numBlue = cols-1 if rows > 1 else 0
    numRed = 2*(cols-1) if rows > 2 else 0
    numYellow = 2*(cols-1) if rows > 1 else 0
    numEmpty = rows*cols - len(encodedText) - numBlue - numRed - numYellow
    blueCells = []
    redCells = []
    yellowCells = []
    emptyCells = []
    currCell = [0,0]
    currState = 0 # 0=blue, 1=red1, 2=yellow, 3=red2
    for c in encodedText:
        if currState == 0:
            blueCells.append(c)
            if currCell[0] == rows-1:
                currState = 1
                currCell = [rows-2, 1]
            else:
                currCell[0] += 1
                if currCell[1] == cols-1:
                    currState = 2
                    currCell = [0, cols-2]
                else:
                    currCell[1] += 1
        elif currState == 1:
            redCells.append(c)
            if currCell[1] == cols-1:
                currState = 2
                currCell = [0, cols-2]
            else:
                currCell[0] -= 1
                currCell[1] += 1
        elif currState == 2:
            yellowCells.append(c)
            if currCell[0] == 0:
                currState = 3
                currCell = [1, cols-1]
            else:
                currCell[0] -= 1
                currCell[1] -= 1
        elif currState == 3:
            redCells.append(c)
            if currCell[1] == numEmpty:
                currState = 0
                currCell = [0, 0]
            else:
                currCell[0] += 1
                currCell[1] -= 1
    decodedText = [' ']*(rows*cols)
    currCell = [0,0]
    currState = 0 # 0=blue, 1=red1, 2=yellow, 3=red2
    for c in blueCells:
        decodedText[currCell[0]*cols+currCell[1]] = c
        if currCell[0] == rows-1:
            currState = 1
            currCell = [rows-2, 1]
        else:
            currCell[0] += 1
            if currCell[1] == cols-1:
                currState = 2
                currCell = [0, cols-2]
            else:
                currCell[1] += 1
    for c in redCells:
        decodedText[currCell[0]*cols+currCell[1]] = c
        if currState == 1:
            if currCell[1] == cols-1:
                currState = 2
                currCell = [0, cols-2]
            else:
                currCell[0] -= 1
                currCell[1] += 1
        elif currState == 3:
            if currCell[1] == numEmpty:
                currState = 0
                currCell = [0, 0]
            else:
                currCell[0] += 1
                currCell[1] -= 1
        else:
            if currCell[0] == 0:
                currState = 3
                currCell = [1, cols-1]
            else:
                currCell[0] -= 1
                currCell[1] += 1
    for c in yellowCells:
        decodedText[currCell[0]*cols+currCell[1]] = c
        if currCell[0] == 0:
            currState = 3
            currCell = [1, cols-1]
        else:
            currCell[0] -= 1
            currCell[1] -= 1
    return ''.join(decodedText)","string originalText encoded using slanted transposition cipher string encodedText help matrix fixed number rows rows. originalText placed first top-left bottom-right manner. blue cells filled first, followed red cells, yellow cells, on, reach end originalText. arrow indicates order cells filled. empty cells filled ' '. number columns chosen rightmost column empty filling originalText. encodedText formed appending characters matrix row-wise fashion. characters blue cells appended first encodedText, red cells, on, finally yellow cells. arrow indicates order cells accessed. example, originalText = ""cipher"" rows = 3, encode following manner: blue arrows depict originalText placed matrix, red arrows denote order encodedText formed. example, encodedText = ""ch ie pr"". Given encoded string encodedText number rows rows, return original string originalText. Note: originalText trailing spaces ' '. test cases generated one possible originalText.",0,"def decode_slanted_transposition(encodedText, rows):
    cols = math.ceil(len(encodedText)/rows)
    numBlue = cols-1 if rows > 1 else 0
    numRed = 2*(cols-1) if rows > 2 else 0
    numYellow = 2*(cols-1) if rows > 1 else 0
    numEmpty = rows*cols - len(encodedText) - numBlue - numRed - numYellow
    blueCells = []
    redCells = []
    yellowCells = []
    emptyCells = []
    currCell = [0,0]
    currState = 0 
    for c in encodedText:
        if currState == 0:
            blueCells.append(c)
            if currCell[0] == rows-1:
                currState = 1
                currCell = [rows-2, 1]
            else:
                currCell[0] += 1
                if currCell[1] == cols-1:
                    currState = 2
                    currCell = [0, cols-2]
                else:
                    currCell[1] += 1
        elif currState == 1:
            redCells.append(c)
            if currCell[1] == cols-1:
                currState = 2
                currCell = [0, cols-2]
            else:
                currCell[0] -= 1
                currCell[1] += 1
        elif currState == 2:
            yellowCells.append(c)
            if currCell[0] == 0:
                currState = 3
                currCell = [1, cols-1]
            else:
                currCell[0] -= 1
                currCell[1] -= 1
        elif currState == 3:
            redCells.append(c)
            if currCell[1] == numEmpty:
                currState = 0
                currCell = [0, 0]
            else:
                currCell[0] += 1
                currCell[1] -= 1
    decodedText = [' ']*(rows*cols)
    currCell = [0,0]
    currState = 0 
    for c in blueCells:
        decodedText[currCell[0]*cols+currCell[1]] = c
        if currCell[0] == rows-1:
            currState = 1
            currCell = [rows-2, 1]
        else:
            currCell[0] += 1
            if currCell[1] == cols-1:
                currState = 2
                currCell = [0, cols-2]
            else:
                currCell[1] += 1
    for c in redCells:
        decodedText[currCell[0]*cols+currCell[1]] = c
        if currState == 1:
            if currCell[1] == cols-1:
                currState = 2
                currCell = [0, cols-2]
            else:
                currCell[0] -= 1
                currCell[1] += 1
        elif currState == 3:
            if currCell[1] == numEmpty:
                currState = 0
                currCell = [0, 0]
            else:
                currCell[0] += 1
                currCell[1] -= 1
        else:
            if currCell[0] == 0:
                currState = 3
                currCell = [1, cols-1]
            else:
                currCell[0] -= 1
                currCell[1] += 1
    for c in yellowCells:
        decodedText[currCell[0]*cols+currCell[1]] = c
        if currCell[0] == 0:
            currState = 3
            currCell = [1, cols-1]
        else:
            currCell[0] -= 1
            currCell[1] -= 1
    return ''.join(decodedText)",57
py_1700_data.csv,"
def apply_operations(nums, operations):
    for op in operations:
        nums[op[0]] = op[1]
    return nums
","given 0-indexed array nums consists n distinct positive integers. Apply operations array, ith operation replace number operations[i][0] operations[i][1]. guaranteed ith operation: operations[i][0] exists nums. operations[i][1] exist nums. Return array obtained applying operations.",3,"def apply_operations(nums, operations):
    for op in operations:
        nums[op[0]] = op[1]
    return nums
",58
py_1700_data.csv,"
def maxHeight(cuboids):
    n = len(cuboids)
    for i in range(n):
        cuboids[i].sort()
    cuboids.sort()
    dp = [0] * n
    for i in range(n):
        dp[i] = cuboids[i][2]
        for j in range(i):
            if cuboids[i][0] >= cuboids[j][0] and cuboids[i][1] >= cuboids[j][1] and cuboids[i][2] >= cuboids[j][2]:
                dp[i] = max(dp[i], dp[j] + cuboids[i][2])
    return max(dp)
","Given n cuboids dimensions ith cuboid cuboids[i] = [widthi, lengthi, heighti] (0-indexed). Choose subset cuboids place other. place cuboid cuboid j widthi <= widthj lengthi <= lengthj heighti <= heightj. rearrange cuboid's dimensions rotating put another cuboid. Return maximum height stacked cuboids.",3,"def maxHeight(cuboids):
    n = len(cuboids)
    for i in range(n):
        cuboids[i].sort()
    cuboids.sort()
    dp = [0] * n
    for i in range(n):
        dp[i] = cuboids[i][2]
        for j in range(i):
            if cuboids[i][0] >= cuboids[j][0] and cuboids[i][1] >= cuboids[j][1] and cuboids[i][2] >= cuboids[j][2]:
                dp[i] = max(dp[i], dp[j] + cuboids[i][2])
    return max(dp)
",59
py_1700_data.csv,"def makeGood(s):
    if len(s) < 2:
        return s
    for i in range(len(s) - 1):
        if s[i].islower() and s[i + 1].isupper() and s[i] == s[i + 1].lower() or \
           s[i].isupper() and s[i + 1].islower() and s[i] == s[i + 1].upper():
            return makeGood(s[:i] + s[i + 2:])
    return s","Given string lower upper case English letters. good string string two adjacent characters s[i] s[i + 1] where: 0 <= <= s.length - 2 s[i] lower-case letter s[i + 1] letter upper-case vice-versa. make string good, choose two adjacent characters make string bad remove them. keep string becomes good. Return string making good. answer guaranteed unique given constraints. Notice empty string also good.",3,"def makeGood(s):
    if len(s) < 2:
        return s
    for i in range(len(s) - 1):
        if s[i].islower() and s[i + 1].isupper() and s[i] == s[i + 1].lower() or \
           s[i].isupper() and s[i + 1].islower() and s[i] == s[i + 1].upper():
            return makeGood(s[:i] + s[i + 2:])
    return s",60
py_1700_data.csv,"
import math

def min_squares(n,m):
    if n == m:
        return 1
    else:
        max_side = min(n,m)
        min_side = max_side
        while True:
            num_squares = (n//min_side) * (m//min_side)
            if num_squares > 0:
                return num_squares
            else:
                min_side -= 1
            
n = 4
m = 6
print(min_squares(n,m))  # Output: 6
","Given rectangle size n x m, return minimum number integer-sided squares tile rectangle.",1,"import math
def min_squares(n,m):
    if n == m:
        return 1
    else:
        max_side = min(n,m)
        min_side = max_side
        while True:
            num_squares = (n//min_side) * (m//min_side)
            if num_squares > 0:
                return num_squares
            else:
                min_side -= 1
n = 4
m = 6
print(min_squares(n,m))  
",61
py_1700_data.csv,"def replace_elements(arr):
    ranks = {}
    for num in arr:
        rank = 1
        for other_num in arr:
            if other_num > num:
                rank += 1
        ranks[num] = rank
    for i in range(len(arr)):
        arr[i] = ranks[arr[i]]
    return arr","Given array integers arr, replace element rank. rank represents large element is. rank following rules: Rank integer starting 1. larger element, larger rank. two elements equal, rank must same. Rank small possible.",1,"def replace_elements(arr):
    ranks = {}
    for num in arr:
        rank = 1
        for other_num in arr:
            if other_num > num:
                rank += 1
        ranks[num] = rank
    for i in range(len(arr)):
        arr[i] = ranks[arr[i]]
    return arr",62
py_1700_data.csv,"def minMeetingRooms(meetings: List[List[int]]) -> int:
    meetings.sort(key=lambda x: x[0])
    rooms = []
    for meeting in meetings:
        if not rooms:
            rooms.append(meeting[1])
        else:
            if meeting[0] >= min(rooms):
                rooms[rooms.index(min(rooms))] = meeting[1]
            else:
                rooms.append(meeting[1])
    return len(rooms)","given integer n. n rooms numbered 0 n - 1. given 2D integer array meetings meetings[i] = [starti, endi] means meeting held half-closed time interval [starti, endi). values starti unique. Meetings allocated rooms following manner: meeting take place unused room lowest number. available rooms, meeting delayed room becomes free. delayed meeting duration original meeting. room becomes unused, meetings earlier original start time given room. Return number room held meetings. multiple rooms, return room lowest number. half-closed interval [a, b) interval b including including b.",0,"def minMeetingRooms(meetings: List[List[int]]) -> int:
    meetings.sort(key=lambda x: x[0])
    rooms = []
    for meeting in meetings:
        if not rooms:
            rooms.append(meeting[1])
        else:
            if meeting[0] >= min(rooms):
                rooms[rooms.index(min(rooms))] = meeting[1]
            else:
                rooms.append(meeting[1])
    return len(rooms)",63
py_1700_data.csv,"def distribute(nums, quantity):
    total = sum(quantity)
    if total != len(nums):
        return False
    
    qty_dict = {}
    for q in quantity:
        if q not in qty_dict:
            qty_dict[q] = 1
        else:
            qty_dict[q] += 1
    
    for k,v in qty_dict.items():
        if k*v > len(nums):
            return False
    
    nums.sort(reverse=True)
    for q in quantity:
        for i in range(q):
            if nums[i] < 1:
                return False
            nums[i] -= 1
    
    return True","given array n integers, nums, 50 unique values array. also given array customer order quantities, quantity, quantity[i] amount integers ith customer ordered. Determine possible distribute nums that: ith customer gets exactly quantity[i] integers, integers ith customer gets equal, Every customer satisfied. Return true possible distribute nums according conditions.",1,"def distribute(nums, quantity):
    total = sum(quantity)
    if total != len(nums):
        return False
    qty_dict = {}
    for q in quantity:
        if q not in qty_dict:
            qty_dict[q] = 1
        else:
            qty_dict[q] += 1
    for k,v in qty_dict.items():
        if k*v > len(nums):
            return False
    nums.sort(reverse=True)
    for q in quantity:
        for i in range(q):
            if nums[i] < 1:
                return False
            nums[i] -= 1
    return True",64
py_1700_data.csv,"def max_income(n, edges, amount):
    tree = [[] for _ in range(n)]
    for a, b in edges:
        tree[a].append(b)
        tree[b].append(a)
        
    def dfs(node, parent):
        if node == 0:
            return 0
        
        max_profit = amount[node]
        for child in tree[node]:
            if child != parent:
                profit = dfs(child, node)
                if profit >= 0:
                    max_profit += profit
        
        return max_profit
    
    return dfs(1, 0)","undirected tree n nodes labeled 0 n - 1, rooted node 0. given 2D integer array edges length n - 1 edges[i] = [ai, bi] indicates edge nodes ai bi tree. every node i, gate. also given array even integers amount, amount[i] represents: price needed open gate node i, amount[i] negative, or, cash reward obtained opening gate node i, otherwise. game goes follows: Initially, Alice node 0 Bob node bob. every second, Alice Bob move adjacent node. Alice moves towards leaf node, Bob moves towards node 0. every node along path, Alice Bob either spend money open gate node, accept reward. Note that: gate already open, price required, cash reward. Alice Bob reach node simultaneously, share price/reward opening gate there. words, price open gate c, Alice Bob pay c / 2 each. Similarly, reward gate c, receive c / 2 each. Alice reaches leaf node, stops moving. Similarly, Bob reaches node 0, stops moving. Note events independent other. Return maximum net income Alice travels towards optimal leaf node.",0,"def max_income(n, edges, amount):
    tree = [[] for _ in range(n)]
    for a, b in edges:
        tree[a].append(b)
        tree[b].append(a)
    def dfs(node, parent):
        if node == 0:
            return 0
        max_profit = amount[node]
        for child in tree[node]:
            if child != parent:
                profit = dfs(child, node)
                if profit >= 0:
                    max_profit += profit
        return max_profit
    return dfs(1, 0)",65
py_1700_data.csv,"def minMoves(nums):
    return sum(nums) - min(nums) * len(nums)","Given integer array nums size n, return minimum number moves required make array elements equal. one move, increment n - 1 elements array 1.",3,"def minMoves(nums):
    return sum(nums) - min(nums) * len(nums)",66
py_good_answer.csv,"# Node class 
class Node: 

    def __init__(self, data): 
        self.data = data 
        self.next = None

class LinkedList: 

    def __init__(self): 
        self.head = None

    # add new node at the end of the linked list
    def append(self, new_data): 
        new_node = Node(new_data) 

        if self.head is None: 
            self.head = new_node 
            return

        last = self.head 
        while (last.next): 
            last = last.next

        last.next = new_node 

    # modify the linked list such that even numbers 
    # appear before odd numbers
    def modify_list(self): 
        even_head = None
        even_tail = None
        odd_head = None
        odd_tail = None

        current_node = self.head 
        while current_node: 
            if current_node.data % 2 == 0: 
                if even_head is None: 
                    even_head = current_node 
                    even_tail = current_node 
                else: 
                    even_tail.next = current_node 
                    even_tail = even_tail.next 
            else: 
                if odd_head is None: 
                    odd_head = current_node 
                    odd_tail = current_node 
                else: 
                    odd_tail.next = current_node 
                    odd_tail = odd_tail.next 

            current_node = current_node.next 

        if even_head is None: 
            self.head = odd_head 
        else: 
            even_tail.next = odd_head 
            self.head = even_head 

    # print the linked list
    def print_list(self): 
        current_node = self.head 
        while current_node: 
            print(current_node.data, end=' -> ')

            current_node = current_node.next 
        print('None') 

# driver code
if __name__ == '__main__': 
    llist = LinkedList() 

    llist.append(1) 
    llist.append(2) 
    llist.append(3) 
    llist.append(4) 
    llist.append(5) 

    print('Original Linked List')
    llist.print_list()

    llist.modify_list() 

    print('Modified Linked List')
    llist.print_list()",Python Program Modify Linked List Even Numbers appear Odd Numbers Modified Linked List,0,"class Node: 
    def __init__(self, data): 
        self.data = data 
        self.next = None
class LinkedList: 
    def __init__(self): 
        self.head = None
    def append(self, new_data): 
        new_node = Node(new_data) 
        if self.head is None: 
            self.head = new_node 
            return
        last = self.head 
        while (last.next): 
            last = last.next
        last.next = new_node 
    def modify_list(self): 
        even_head = None
        even_tail = None
        odd_head = None
        odd_tail = None
        current_node = self.head 
        while current_node: 
            if current_node.data % 2 == 0: 
                if even_head is None: 
                    even_head = current_node 
                    even_tail = current_node 
                else: 
                    even_tail.next = current_node 
                    even_tail = even_tail.next 
            else: 
                if odd_head is None: 
                    odd_head = current_node 
                    odd_tail = current_node 
                else: 
                    odd_tail.next = current_node 
                    odd_tail = odd_tail.next 
            current_node = current_node.next 
        if even_head is None: 
            self.head = odd_head 
        else: 
            even_tail.next = odd_head 
            self.head = even_head 
    def print_list(self): 
        current_node = self.head 
        while current_node: 
            print(current_node.data, end=' -> ')
            current_node = current_node.next 
        print('None') 
if __name__ == '__main__': 
    llist = LinkedList() 
    llist.append(1) 
    llist.append(2) 
    llist.append(3) 
    llist.append(4) 
    llist.append(5) 
    print('Original Linked List')
    llist.print_list()
    llist.modify_list() 
    print('Modified Linked List')
    llist.print_list()",67
py_1700_data.csv,"def max_tasks_completed(tasks, workers, pills, strength):
    sorted_tasks = sorted(tasks)
    sorted_workers = sorted(workers)
    sorted_pills = sorted(pills, reverse=True)

    num_tasks_completed = 0
    for task in sorted_tasks:
        for i, worker in enumerate(sorted_workers):
            if worker >= task:
                sorted_workers.pop(i)
                num_tasks_completed += 1
                break
        else: # if no worker found
            for i, p in enumerate(sorted_pills):
                if strength + p >= task:
                    sorted_pills.pop(i)
                    num_tasks_completed += 1
                    break
            else: # if no worker or pill found
                break

    return num_tasks_completed","n tasks workers. task strength requirement stored 0-indexed integer array tasks, ith task requiring tasks[i] strength complete. strength worker stored 0-indexed integer array workers, jth worker workers[j] strength. worker assigned single task must strength greater equal task's strength requirement (i.e., workers[j] >= tasks[i]). Additionally, pills magical pills increase worker's strength strength. decide workers receive magical pills, however, may give worker one magical pill. Given 0-indexed integer arrays tasks workers integers pills strength, return maximum number tasks completed.",0,"def max_tasks_completed(tasks, workers, pills, strength):
    sorted_tasks = sorted(tasks)
    sorted_workers = sorted(workers)
    sorted_pills = sorted(pills, reverse=True)
    num_tasks_completed = 0
    for task in sorted_tasks:
        for i, worker in enumerate(sorted_workers):
            if worker >= task:
                sorted_workers.pop(i)
                num_tasks_completed += 1
                break
        else: 
            for i, p in enumerate(sorted_pills):
                if strength + p >= task:
                    sorted_pills.pop(i)
                    num_tasks_completed += 1
                    break
            else: 
                break
    return num_tasks_completed",68
py_1700_data.csv,"def replace_uppercase_with_lowercase(s):
    new_string = """"
    for char in s:
        if char.isupper():
            new_string += char.lower()
        else:
            new_string += char
    return new_string","Given string s, return string replacing every uppercase letter lowercase letter.",3,"def replace_uppercase_with_lowercase(s):
    new_string = """"
    for char in s:
        if char.isupper():
            new_string += char.lower()
        else:
            new_string += char
    return new_string",69
py_1700_data.csv,"def game_probability(n, k, maxPts):
    if n >= k:
        return 0
    total_outcomes = pow(maxPts, k)
    favorable_outcomes = 0
    for i in range(total_outcomes):
        score = 0
        for j in range(k):
            draw = random.randint(1, maxPts)
            score += draw
            if score >= k:
                break
        if score < n:
            favorable_outcomes += 1
    return favorable_outcomes / total_outcomes
","Alice plays following game, loosely based card game ""21"". Alice starts 0 points draws numbers less k points. draw, gains integer number points randomly range [1, maxPts], maxPts integer. draw independent outcomes equal probabilities. Alice stops drawing numbers gets k points. Return probability Alice n fewer points. Answers within 10-5 actual answer considered accepted.",0,"def game_probability(n, k, maxPts):
    if n >= k:
        return 0
    total_outcomes = pow(maxPts, k)
    favorable_outcomes = 0
    for i in range(total_outcomes):
        score = 0
        for j in range(k):
            draw = random.randint(1, maxPts)
            score += draw
            if score >= k:
                break
        if score < n:
            favorable_outcomes += 1
    return favorable_outcomes / total_outcomes
",70
py_1700_data.csv,"def len_longest_fibonacci_subsequence(arr):
    set_arr = set(arr)
    max_seq = 0
    for i in range(len(arr)):
        for j in range(i+1, len(arr)):
            a, b = arr[i], arr[j]
            count = 2
            while a+b in set_arr:
                a, b = b, a+b
                count += 1
            max_seq = max(max_seq, count)
    return max_seq if max_seq > 2 else 0","sequence x1, x2, ..., xn Fibonacci-like if: n >= 3 xi + xi+1 == xi+2 + 2 <= n Given strictly increasing array arr positive integers forming sequence, return length longest Fibonacci-like subsequence arr. one exist, return 0. subsequence derived another sequence arr deleting number elements (including none) arr, without changing order remaining elements. example, [3, 5, 8] subsequence [3, 4, 5, 6, 7, 8].",0,"def len_longest_fibonacci_subsequence(arr):
    set_arr = set(arr)
    max_seq = 0
    for i in range(len(arr)):
        for j in range(i+1, len(arr)):
            a, b = arr[i], arr[j]
            count = 2
            while a+b in set_arr:
                a, b = b, a+b
                count += 1
            max_seq = max(max_seq, count)
    return max_seq if max_seq > 2 else 0",71
py_1700_data.csv,"def isMagicSquare(grid, i, j):
    # Check row sums
    row_sum = sum(grid[i][j:j+3])
    for k in range(1, 3):
        if sum(grid[i+k][j:j+3]) != row_sum:
            return False
    
    # Check column sums
    col_sum = sum(grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2])
    if sum(grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2]) != col_sum:
        return False
    if sum(grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j]) != col_sum:
        return False
    
    return True

def countMagicSquares(grid):
    m, n = len(grid), len(grid[0])
    count = 0
    
    for i in range(1, m-1):
        for j in range(1, n-1):
            if grid[i][j] in range(1, 10) and grid[i][j-1] not in range(1, 10) and grid[i][j+1] not in range(1, 10) and \
               grid[i-1][j] not in range(1, 10) and grid[i+1][j] not in range(1, 10) and \
               grid[i-1][j-1] not in range(1, 10) and grid[i-1][j+1] not in range(1, 10) and \
               grid[i+1][j-1] not in range(1, 10) and grid[i+1][j+1] not in range(1, 10):
                if isMagicSquare(grid, i-1, j-1):
                    count += 1
    
    return count","3 x 3 magic square 3 x 3 grid filled distinct numbers 1 9 row, column, diagonals sum. Given row x col grid integers, many 3 x 3 ""magic square"" subgrids there? (Each subgrid contiguous).",1,"def isMagicSquare(grid, i, j):
    row_sum = sum(grid[i][j:j+3])
    for k in range(1, 3):
        if sum(grid[i+k][j:j+3]) != row_sum:
            return False
    col_sum = sum(grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2])
    if sum(grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2]) != col_sum:
        return False
    if sum(grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j]) != col_sum:
        return False
    return True
def countMagicSquares(grid):
    m, n = len(grid), len(grid[0])
    count = 0
    for i in range(1, m-1):
        for j in range(1, n-1):
            if grid[i][j] in range(1, 10) and grid[i][j-1] not in range(1, 10) and grid[i][j+1] not in range(1, 10) and \
               grid[i-1][j] not in range(1, 10) and grid[i+1][j] not in range(1, 10) and \
               grid[i-1][j-1] not in range(1, 10) and grid[i-1][j+1] not in range(1, 10) and \
               grid[i+1][j-1] not in range(1, 10) and grid[i+1][j+1] not in range(1, 10):
                if isMagicSquare(grid, i-1, j-1):
                    count += 1
    return count",72
py_1700_data.csv,"def largest_palindrome(num):
    digits = list(num)
    digits.sort(reverse=True)
    for i in range(int(num), int("""".join(digits))+1):
        if str(i) == str(i)[::-1]:
            return str(i)
    return ""0""","given string num consisting digits only. Return largest palindromic integer (in form string) formed using digits taken num. contain leading zeroes. Notes: need use digits num, must use least one digit. digits reordered.",2,"def largest_palindrome(num):
    digits = list(num)
    digits.sort(reverse=True)
    for i in range(int(num), int("""".join(digits))+1):
        if str(i) == str(i)[::-1]:
            return str(i)
    return ""0""",73
py_1700_data.csv,"
import heapq

def kthSmallest(mat, k):
    heap = [(sum(row), [0]) for row in mat]
    seen = set(tuple(zero * len(mat)) for zero in [0])
    for i in range(k - 1):
        sm, indices = heapq.heappop(heap)
        for j in range(len(mat)):
            if indices[j] + 1 < len(mat[0]):
                new_indices = indices[:j] + [indices[j] + 1] + indices[j + 1:]
                if tuple(new_indices) not in seen:
                    seen.add(tuple(new_indices))
                    heapq.heappush(heap, (sm - mat[j][indices[j]] + mat[j][indices[j] + 1], new_indices))
    return heap[0][0]
",given x n matrix mat rows sorted non-decreasing order integer k. allowed choose exactly one element row form array. Return kth smallest array sum among possible arrays.,0,"import heapq
def kthSmallest(mat, k):
    heap = [(sum(row), [0]) for row in mat]
    seen = set(tuple(zero * len(mat)) for zero in [0])
    for i in range(k - 1):
        sm, indices = heapq.heappop(heap)
        for j in range(len(mat)):
            if indices[j] + 1 < len(mat[0]):
                new_indices = indices[:j] + [indices[j] + 1] + indices[j + 1:]
                if tuple(new_indices) not in seen:
                    seen.add(tuple(new_indices))
                    heapq.heappush(heap, (sm - mat[j][indices[j]] + mat[j][indices[j] + 1], new_indices))
    return heap[0][0]
",74
py_1700_data.csv,"def count_laser_beams(bank):
    laser_count = 0
    for r1 in range(len(bank)-1):
        for r2 in range(r1+1, len(bank)):
            if '1' in bank[r1] and '1' in bank[r2]:
                if all(bank[i][j] == '0' for i in range(r1+1, r2) for j in range(len(bank[i]))):
                    laser_count += 1
    return laser_count","Anti-theft security devices activated inside bank. given 0-indexed binary string array bank representing floor plan bank, x n 2D matrix. bank[i] represents ith row, consisting '0's '1's. '0' means cell empty, while'1' means cell security device. one laser beam two security devices conditions met: two devices located two different rows: r1 r2, r1 < r2. row r1 < < r2, security devices ith row. Laser beams independent, i.e., one beam interfere join another. Return total number laser beams bank.",2,"def count_laser_beams(bank):
    laser_count = 0
    for r1 in range(len(bank)-1):
        for r2 in range(r1+1, len(bank)):
            if '1' in bank[r1] and '1' in bank[r2]:
                if all(bank[i][j] == '0' for i in range(r1+1, r2) for j in range(len(bank[i]))):
                    laser_count += 1
    return laser_count",75
py_1700_data.csv,"def sumSubarray(nums):
    MOD = 10**9 + 7
    n = len(nums)
    ans = 0
    for i in range(n):
        for j in range(i, n):
            ans += sum(nums[i:j+1])
    return ans % MOD","given array nums consisting n positive integers. computed sum non-empty continuous subarrays array sorted non-decreasing order, creating new array n * (n + 1) / 2 numbers. Return sum numbers index left index right (indexed 1), inclusive, new array. Since answer huge number return modulo 109 + 7.",2,"def sumSubarray(nums):
    MOD = 10**9 + 7
    n = len(nums)
    ans = 0
    for i in range(n):
        for j in range(i, n):
            ans += sum(nums[i:j+1])
    return ans % MOD",76
py_1700_data.csv,"def max_total_beauty(flowers, newFlowers, target, full, partial):
    n = len(flowers)
    incomplete_gardens = [max(0, target - flowers[i]) for i in range(n)]
    complete_gardens = [max(0, flowers[i] - target) for i in range(n)]
    num_incomplete_gardens = sum(1 for i in range(n) if flowers[i] < target)
    num_new_flowers = min(num_incomplete_gardens * partial, newFlowers)
    total_beauty = sum(complete_gardens) * full + num_new_flowers * partial
    return total_beauty","Alice caretaker n gardens wants plant flowers maximize total beauty gardens. given 0-indexed integer array flowers size n, flowers[i] number flowers already planted ith garden. Flowers already planted cannot removed. given another integer newFlowers, maximum number flowers Alice additionally plant. also given integers target, full, partial. garden considered complete least target flowers. total beauty gardens determined sum following: number complete gardens multiplied full. minimum number flowers incomplete gardens multiplied partial. incomplete gardens, value 0. Return maximum total beauty Alice obtain planting newFlowers flowers.",1,"def max_total_beauty(flowers, newFlowers, target, full, partial):
    n = len(flowers)
    incomplete_gardens = [max(0, target - flowers[i]) for i in range(n)]
    complete_gardens = [max(0, flowers[i] - target) for i in range(n)]
    num_incomplete_gardens = sum(1 for i in range(n) if flowers[i] < target)
    num_new_flowers = min(num_incomplete_gardens * partial, newFlowers)
    total_beauty = sum(complete_gardens) * full + num_new_flowers * partial
    return total_beauty",77
py_1700_data.csv,"def secret_people(n: int, delay: int, forget: int) -> int:
    MOD = 10**9 + 7
    dp = [0] * (n + 1)
    dp[0] = 1
    forget_days = [0] * (n + 1)
    forget_days[delay] = 1
    for i in range(1, n + 1):
        dp[i] = dp[i - 1] + forget_days[i - 1]
        if i >= delay:
            dp[i] -= forget_days[i - delay]
        dp[i] %= MOD
        forget_days[i] = (forget_days[i - 1] + dp[i - forget]) % MOD
    return dp[n]","day 1, one person discovers secret. given integer delay, means person share secret new person every day, starting delay days discovering secret. also given integer forget, means person forget secret forget days discovering it. person cannot share secret day forgot it, day afterwards. Given integer n, return number people know secret end day n. Since answer may large, return modulo 109 + 7.",0,"def secret_people(n: int, delay: int, forget: int) -> int:
    MOD = 10**9 + 7
    dp = [0] * (n + 1)
    dp[0] = 1
    forget_days = [0] * (n + 1)
    forget_days[delay] = 1
    for i in range(1, n + 1):
        dp[i] = dp[i - 1] + forget_days[i - 1]
        if i >= delay:
            dp[i] -= forget_days[i - delay]
        dp[i] %= MOD
        forget_days[i] = (forget_days[i - 1] + dp[i - forget]) % MOD
    return dp[n]",78
py_1700_data.csv,"def smallestString(k: int, s: str) -> str:
    if k >= len(s):
        return s
    return min(s[i:k]+s[k:] for i in range(len(s)-k+1))",given string integer k. choose one first k letters append end string.. Return lexicographically smallest string could applying mentioned step number moves.,1,"def smallestString(k: int, s: str) -> str:
    if k >= len(s):
        return s
    return min(s[i:k]+s[k:] for i in range(len(s)-k+1))",79
py_1700_data.csv,"def defangIPaddr(address: str) -> str:
    return address.replace('.', '[.]')","Given valid (IPv4) IP address, return defanged version IP address. defanged IP address replaces every period ""."" ""[.]"".",3,"def defangIPaddr(address: str) -> str:
    return address.replace('.', '[.]')",80
py_1700_data.csv,"
def max_sum(nums):
    num_dict = {}
    max_val = -1
    for i, num in enumerate(nums):
        digits_sum = sum(list(map(int, str(num))))
        if digits_sum in num_dict:
            if num + num_dict[digits_sum] > max_val:
                max_val = num + num_dict[digits_sum]
        num_dict[digits_sum] = max(num_dict.get(digits_sum, 0), num)
    return max_val
","given 0-indexed array nums consisting positive integers. choose two indices j, != j, sum digits number nums[i] equal nums[j]. Return maximum value nums[i] + nums[j] obtain possible indices j satisfy conditions.",0,"def max_sum(nums):
    num_dict = {}
    max_val = -1
    for i, num in enumerate(nums):
        digits_sum = sum(list(map(int, str(num))))
        if digits_sum in num_dict:
            if num + num_dict[digits_sum] > max_val:
                max_val = num + num_dict[digits_sum]
        num_dict[digits_sum] = max(num_dict.get(digits_sum, 0), num)
    return max_val
",81
py_good_answer.csv,"def uncommon_characters(str1, str2):
    set1 = set(str1)
    set2 = set(str2)
    uncommon_set = set1 ^ set2
    uncommon_list = list(uncommon_set)
    uncommon_list.sort()
    uncommon_str = ''.join(uncommon_list)
    return uncommon_str

str1 = ""abcd""
str2 = ""defg""
print(uncommon_characters(str1, str2))",Concatenated string uncommon characters Python,0,"def uncommon_characters(str1, str2):
    set1 = set(str1)
    set2 = set(str2)
    uncommon_set = set1 ^ set2
    uncommon_list = list(uncommon_set)
    uncommon_list.sort()
    uncommon_str = ''.join(uncommon_list)
    return uncommon_str
str1 = ""abcd""
str2 = ""defg""
print(uncommon_characters(str1, str2))",82
py_1700_data.csv,"
def minOperations(nums: List[int], x: int) -> int:
    target_sum = sum(nums) - x
    if target_sum == 0:
        return len(nums)
    if target_sum < 0:
        return -1
    left = 0
    curr_sum = 0
    max_len = float('-inf')
    for right in range(len(nums)):
        curr_sum += nums[right]
        while curr_sum > target_sum and left <= right:
            curr_sum -= nums[left]
            left += 1
        if curr_sum == target_sum:
            max_len = max(max_len, right - left + 1)
    return len(nums) - max_len if max_len != float('-inf') else -1
","given integer array nums integer x. one operation, either remove leftmost rightmost element array nums subtract value x. Note modifies array future operations. Return minimum number operations reduce x exactly 0 possible, otherwise, return -1.",3,"def minOperations(nums: List[int], x: int) -> int:
    target_sum = sum(nums) - x
    if target_sum == 0:
        return len(nums)
    if target_sum < 0:
        return -1
    left = 0
    curr_sum = 0
    max_len = float('-inf')
    for right in range(len(nums)):
        curr_sum += nums[right]
        while curr_sum > target_sum and left <= right:
            curr_sum -= nums[left]
            left += 1
        if curr_sum == target_sum:
            max_len = max(max_len, right - left + 1)
    return len(nums) - max_len if max_len != float('-inf') else -1
",83
py_good_answer.csv,"
def sieve_of_eratosthenes(n):
    primes = [True for i in range(n+1)]
    p = 2
    
    while p**2<=n:
        if primes[p]:
            for i in range(p**2, n+1, p):
                primes[i] = False
        p += 1
        
    prime_nums = []
    for i in range(2, n+1):
        if primes[i]:
            prime_nums.append(i)
    return prime_nums
",Write Python program using Sieve Eratosthenes method computing primes upto specified number.,3,"def sieve_of_eratosthenes(n):
    primes = [True for i in range(n+1)]
    p = 2
    while p**2<=n:
        if primes[p]:
            for i in range(p**2, n+1, p):
                primes[i] = False
        p += 1
    prime_nums = []
    for i in range(2, n+1):
        if primes[i]:
            prime_nums.append(i)
    return prime_nums
",84
py_good_answer.csv,"def compare_lists(list1, list2):
    if sorted(list1) == sorted(list2):
        return True
    else:
        return False",Write Python program compare two unordered lists (not sets).,3,"def compare_lists(list1, list2):
    if sorted(list1) == sorted(list2):
        return True
    else:
        return False",85
py_1700_data.csv,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
        
def sortedArrayToBST(nums):
    
    def buildTree(left,right):
        
        if left>right:
            return None
        
        mid=(left+right)//2
        node=TreeNode(nums[mid])
        node.left=buildTree(left,mid-1)
        node.right=buildTree(mid+1,right)
        
        return node
    
    return buildTree(0,len(nums)-1)","Given integer array nums elements sorted ascending order, convert height-balanced binary search tree.",2,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
def sortedArrayToBST(nums):
    def buildTree(left,right):
        if left>right:
            return None
        mid=(left+right)//2
        node=TreeNode(nums[mid])
        node.left=buildTree(left,mid-1)
        node.right=buildTree(mid+1,right)
        return node
    return buildTree(0,len(nums)-1)",86
py_1700_data.csv,"class Solution:
    def isRobotBounded(self, instructions: str) -> bool:
        x, y = 0, 0
        dx, dy = 0, 1
        for i in instructions:
            if i == ""G"":
                x, y = x + dx, y + dy
            elif i == ""L"":
                dx, dy = -dy, dx
            elif i == ""R"":
                dx, dy = dy, -dx
        return (x == 0 and y == 0) or (dx != 0 or dy != 1)","infinite plane, robot initially stands (0, 0) faces north. Note that: north direction positive direction y-axis. south direction negative direction y-axis. east direction positive direction x-axis. west direction negative direction x-axis. robot receive one three instructions: ""G"": go straight 1 unit. ""L"": turn 90 degrees left (i.e., anti-clockwise direction). ""R"": turn 90 degrees right (i.e., clockwise direction). robot performs instructions given order, repeats forever. Return true exists circle plane robot never leaves circle.",3,"class Solution:
    def isRobotBounded(self, instructions: str) -> bool:
        x, y = 0, 0
        dx, dy = 0, 1
        for i in instructions:
            if i == ""G"":
                x, y = x + dx, y + dy
            elif i == ""L"":
                dx, dy = -dy, dx
            elif i == ""R"":
                dx, dy = dy, -dx
        return (x == 0 and y == 0) or (dx != 0 or dy != 1)",87
py_good_answer.csv,"
import re

def check_string(string):
    if re.search('[a-zA-Z]', string) and re.search('[0-9]', string):
        return True
    else:
        return False
",Write Python program check string least one letter one number,0,"import re
def check_string(string):
    if re.search('[a-zA-Z]', string) and re.search('[0-9]', string):
        return True
    else:
        return False
",88
py_1700_data.csv,"def subsetXORSum(nums):
    res = 0
    n = len(nums)
    for i in range(1 << n):
        temp = []
        for j in range(n):
            if i & (1 << j):
                temp.append(nums[j])
        total_xor = 0
        for num in temp:
            total_xor ^= num
        res += total_xor
    return res","XOR total array defined bitwise XOR elements, 0 array empty. example, XOR total array [2,5,6] 2 XOR 5 XOR 6 = 1. Given array nums, return sum XOR totals every subset nums. Note: Subsets elements counted multiple times. array subset array b obtained b deleting (possibly zero) elements b.",3,"def subsetXORSum(nums):
    res = 0
    n = len(nums)
    for i in range(1 << n):
        temp = []
        for j in range(n):
            if i & (1 << j):
                temp.append(nums[j])
        total_xor = 0
        for num in temp:
            total_xor ^= num
        res += total_xor
    return res",89
py_1700_data.csv,"def min_unfairness(cookies, k):
    cookies.sort()
    min_unfairness = float('inf')
    for i in range(len(cookies)-k+1):
        max_cookies = cookies[i+k-1]
        min_cookies = cookies[i]
        unfairness = max_cookies - min_cookies
        if unfairness < min_unfairness:
            min_unfairness = unfairness
    return min_unfairness","given integer array cookies, cookies[i] denotes number cookies ith bag. also given integer k denotes number children distribute bags cookies to. cookies bag must go child cannot split up. unfairness distribution defined maximum total cookies obtained single child distribution. Return minimum unfairness distributions.",0,"def min_unfairness(cookies, k):
    cookies.sort()
    min_unfairness = float('inf')
    for i in range(len(cookies)-k+1):
        max_cookies = cookies[i+k-1]
        min_cookies = cookies[i]
        unfairness = max_cookies - min_cookies
        if unfairness < min_unfairness:
            min_unfairness = unfairness
    return min_unfairness",90
py_1700_data.csv,"class Solution:
    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:
        n=len(passingFees)
        distance=[[float('inf')]*n for _ in range(n)]
        for i in range(n):
            distance[i][i]=0
        for x,y,t in edges:
            distance[x][y]=t
            distance[y][x]=t
        
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    distance[i][j]=min(distance[i][j],distance[i][k]+distance[k][j])
        
        dp=[[float('inf')]*maxTime for _ in range(n)]
        dp[0]=[passingFees[0] for _ in range(maxTime)]
        for t in range(maxTime):
            for i in range(n):
                for j in range(n):
                    if distance[i][j]<=t:
                        dp[j][t]=min(dp[j][t],dp[i][t-distance[i][j]]+passingFees[j])
        return dp[-1][maxTime-1] if dp[-1][maxTime-1]!=float('inf') else -1","country n cities numbered 0 n - 1 cities connected bi-directional roads. roads represented 2D integer array edges edges[i] = [xi, yi, timei] denotes road cities xi yi takes timei minutes travel. may multiple roads differing travel times connecting two cities, road connects city itself. time pass city, must pay passing fee. represented 0-indexed integer array passingFees length n passingFees[j] amount dollars must pay pass city j. beginning, city 0 want reach city n - 1 maxTime minutes less. cost journey summation passing fees city passed moment journey (including source destination cities). Given maxTime, edges, passingFees, return minimum cost complete journey, -1 cannot complete within maxTime minutes.",0,"class Solution:
    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:
        n=len(passingFees)
        distance=[[float('inf')]*n for _ in range(n)]
        for i in range(n):
            distance[i][i]=0
        for x,y,t in edges:
            distance[x][y]=t
            distance[y][x]=t
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    distance[i][j]=min(distance[i][j],distance[i][k]+distance[k][j])
        dp=[[float('inf')]*maxTime for _ in range(n)]
        dp[0]=[passingFees[0] for _ in range(maxTime)]
        for t in range(maxTime):
            for i in range(n):
                for j in range(n):
                    if distance[i][j]<=t:
                        dp[j][t]=min(dp[j][t],dp[i][t-distance[i][j]]+passingFees[j])
        return dp[-1][maxTime-1] if dp[-1][maxTime-1]!=float('inf') else -1",91
py_1700_data.csv,"def xorGame(nums):
    xor = 0
    for num in nums:
        xor ^= num
    return xor == 0 or len(nums) % 2 == 0","given array integers nums represents numbers written chalkboard. Alice Bob take turns erasing exactly one number chalkboard, Alice starting first. erasing number causes bitwise XOR elements chalkboard become 0, player loses. bitwise XOR one element element itself, bitwise XOR elements 0. Also, player starts turn bitwise XOR elements chalkboard equal 0, player wins. Return true Alice wins game, assuming players play optimally.",3,"def xorGame(nums):
    xor = 0
    for num in nums:
        xor ^= num
    return xor == 0 or len(nums) % 2 == 0",92
py_1700_data.csv,"def customSortString(order: str, s: str) -> str:
    count = Counter(s)
    ans = ''
    for c in order:
        ans += c * count[c]
        count[c] = 0
    for c in count:
        ans += c * count[c]
    return ans","given two strings order s. characters order unique sorted custom order previously. Permute characters match order order sorted. specifically, character x occurs character order, x occur permuted string. Return permutation satisfies property.",3,"def customSortString(order: str, s: str) -> str:
    count = Counter(s)
    ans = ''
    for c in order:
        ans += c * count[c]
        count[c] = 0
    for c in count:
        ans += c * count[c]
    return ans",93
py_1700_data.csv,"def reverse(num):
    rev = 0
    while num > 0:
        rev = rev*10 + num % 10
        num //= 10
    return rev

def is_num_reversed(num):
    reversed1 = reverse(num)
    reversed2 = reverse(reversed1)
    return reversed2 == num","Reversing integer means reverse digits. example, reversing 2021 gives 1202. Reversing 12300 gives 321 leading zeros retained. Given integer num, reverse num get reversed1, reverse reversed1 get reversed2. Return true reversed2 equals num. Otherwise return false.",3,"def reverse(num):
    rev = 0
    while num > 0:
        rev = rev*10 + num % 10
        num //= 10
    return rev
def is_num_reversed(num):
    reversed1 = reverse(num)
    reversed2 = reverse(reversed1)
    return reversed2 == num",94
py_1700_data.csv,"def max_uppercase_letter(s):
    uppercase_letters = [char for char in s if char.isupper()]
    if len(uppercase_letters) == 0:
        return ''
    else:
        return max(uppercase_letters)","Given string English letters s, return greatest English letter occurs lowercase uppercase letter s. returned letter uppercase. letter exists, return empty string. English letter b greater another letter b appears English alphabet.",1,"def max_uppercase_letter(s):
    uppercase_letters = [char for char in s if char.isupper()]
    if len(uppercase_letters) == 0:
        return ''
    else:
        return max(uppercase_letters)",95
py_good_answer.csv,"def sum_nodes(root):
    if root is None:
        return 0
    return root.data + sum_nodes(root.left) + sum_nodes(root.right)",Python Program Find Sum Nodes Tree,0,"def sum_nodes(root):
    if root is None:
        return 0
    return root.data + sum_nodes(root.left) + sum_nodes(root.right)",96
py_good_answer.csv,"def maximum_subarray(arr):
    if len(arr) == 1:
        return arr[0]

    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]

    left_sum = maximum_subarray(left)
    right_sum = maximum_subarray(right)

    cross_sum = 0

    left_cross_sum = -float('inf')
    sum = 0

    for i in range(mid-1, -1, -1):
        sum += arr[i]
        if sum > left_cross_sum:
            left_cross_sum = sum

    right_cross_sum = -float('inf')
    sum = 0

    for i in range(mid, len(arr)):
        sum += arr[i]
        if sum > right_cross_sum:
            right_cross_sum = sum

    cross_sum = left_cross_sum + right_cross_sum

    return max(cross_sum, left_sum, right_sum)",Python Program solve Maximum Subarray Problem using Divide Conquer,0,"def maximum_subarray(arr):
    if len(arr) == 1:
        return arr[0]
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    left_sum = maximum_subarray(left)
    right_sum = maximum_subarray(right)
    cross_sum = 0
    left_cross_sum = -float('inf')
    sum = 0
    for i in range(mid-1, -1, -1):
        sum += arr[i]
        if sum > left_cross_sum:
            left_cross_sum = sum
    right_cross_sum = -float('inf')
    sum = 0
    for i in range(mid, len(arr)):
        sum += arr[i]
        if sum > right_cross_sum:
            right_cross_sum = sum
    cross_sum = left_cross_sum + right_cross_sum
    return max(cross_sum, left_sum, right_sum)",97
py_good_answer.csv,"def fib(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 2:
        return 1
    memo[n] = fib(n-1, memo) + fib(n-2, memo)
    return memo[n]

n = int(input(""Enter a number: ""))
print(f""The {n}th Fibonacci number is {fib(n)}"")",Python Program Print nth Fibonacci Number using Dynamic Programming Memoization,3,"def fib(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 2:
        return 1
    memo[n] = fib(n-1, memo) + fib(n-2, memo)
    return memo[n]
n = int(input(""Enter a number: ""))
print(f""The {n}th Fibonacci number is {fib(n)}"")",98
py_1700_data.csv,"def large_groups(string):
    groups = []
    start = 0
    for i in range(len(string)):
        if i == len(string)-1 or string[i] != string[i+1]:
            if i - start + 1 >= 3:
                groups.append((start, i))
            start = i+1
    return sorted(groups, key=lambda x: x[0])","string lowercase letters, letters form consecutive groups character. example, string like = ""abbxxxxzyy"" groups ""a"", ""bb"", ""xxxx"", ""z"", ""yy"". group identified interval [start, end], start end denote start end indices (inclusive) group. example, ""xxxx"" interval [3,6]. group considered large 3 characters. Return intervals every large group sorted increasing order start index.",0,"def large_groups(string):
    groups = []
    start = 0
    for i in range(len(string)):
        if i == len(string)-1 or string[i] != string[i+1]:
            if i - start + 1 >= 3:
                groups.append((start, i))
            start = i+1
    return sorted(groups, key=lambda x: x[0])",99
py_1700_data.csv,"class Solution: 
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        def dfs(i):
            for j in range(n):
                if isConnected[i][j] == 1 and visited[j] == 0:
                    visited[j] = 1
                    dfs(j)
        
        n = len(isConnected)
        visited = [0]*n
        count = 0
        for i in range(n):
            if visited[i] == 0:
                dfs(i)
                count += 1
        return count","n cities. connected, not. city connected directly city b, city b connected directly city c, city connected indirectly city c. province group directly indirectly connected cities cities outside group. given n x n matrix isConnected isConnected[i][j] = 1 ith city jth city directly connected, isConnected[i][j] = 0 otherwise. Return total number provinces.",3,"class Solution: 
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        def dfs(i):
            for j in range(n):
                if isConnected[i][j] == 1 and visited[j] == 0:
                    visited[j] = 1
                    dfs(j)
        n = len(isConnected)
        visited = [0]*n
        count = 0
        for i in range(n):
            if visited[i] == 0:
                dfs(i)
                count += 1
        return count",100
py_1700_data.csv,"class Solution:
    def superPow(self, a: int, b: List[int]) -> int:
        result, base = 1, a % 1337
        for num in reversed(b):
            digit = num % 1337
            for _ in range(10):
                result = (result * base) % 1337
                if digit == 1: 
                    return result
                elif digit == 0: 
                    return 0
            base = (base * base) % 1337
        return result",task calculate ab mod 1337 positive integer b extremely large positive integer given form array.,0,"class Solution:
    def superPow(self, a: int, b: List[int]) -> int:
        result, base = 1, a % 1337
        for num in reversed(b):
            digit = num % 1337
            for _ in range(10):
                result = (result * base) % 1337
                if digit == 1: 
                    return result
                elif digit == 0: 
                    return 0
            base = (base * base) % 1337
        return result",101
py_1700_data.csv,"def longestSubsequence(arr, difference):
    dp = {}
    for num in arr:
        dp[num] = dp.get(num - difference, 0) + 1
    return max(dp.values())","Given integer array arr integer difference, return length longest subsequence arr arithmetic sequence difference adjacent elements subsequence equals difference. subsequence sequence derived arr deleting elements without changing order remaining elements.",3,"def longestSubsequence(arr, difference):
    dp = {}
    for num in arr:
        dp[num] = dp.get(num - difference, 0) + 1
    return max(dp.values())",102
py_good_answer.csv,"import json

class MyClass:
    def __init__(self, name, age):
        self.name = name
        self.age = age

my_object = MyClass(""John"", 25)

json_object = json.dumps(my_object.__dict__)

print(json_object)",Convert class object JSON Python,3,"import json
class MyClass:
    def __init__(self, name, age):
        self.name = name
        self.age = age
my_object = MyClass(""John"", 25)
json_object = json.dumps(my_object.__dict__)
print(json_object)",103
py_1700_data.csv,"def max_depth(vps):
    depth = 0
    max_depth = 0
    for char in vps:
        if char == ""("":
            depth += 1
            max_depth = max(max_depth, depth)
        elif char == "")"":
            depth -= 1
    return max_depth

def split_vps(seq):
    n = len(seq)
    best_depth = -1
    for i in range(n):
        for j in range(i+1, n+1):
            a = seq[:i] + seq[j:]
            b = seq[i:j]
            depth = max(max_depth(a), max_depth(b))
            if depth > best_depth:
                best_depth = depth
                best_a = a
                best_b = b
    answer = [0] * n
    for i in range(n):
        if seq[i] in best_a:
            answer[i] = 0
        else:
            answer[i] = 1
    return answer","string valid parentheses string (denoted VPS) consists ""("" "")"" characters only, and: empty string, written AB (A concatenated B), B VPS's, written (A), VPS. similarly define nesting depth depth(S) VPS follows: depth("""") = 0 depth(A + B) = max(depth(A), depth(B)), B VPS's depth(""("" + + "")"") = 1 + depth(A), VPS. example, """", ""()()"", ""()(()())"" VPS's (with nesting depths 0, 1, 2), "")("" ""(()"" VPS's. Given VPS seq, split two disjoint subsequences B, B VPS's (and A.length + B.length = seq.length). choose B max(depth(A), depth(B)) minimum possible value. Return answer array (of length seq.length) encodes choice B: answer[i] = 0 seq[i] part A, else answer[i] = 1. Note even though multiple answers may exist, may return them.",0,"def max_depth(vps):
    depth = 0
    max_depth = 0
    for char in vps:
        if char == ""("":
            depth += 1
            max_depth = max(max_depth, depth)
        elif char == "")"":
            depth -= 1
    return max_depth
def split_vps(seq):
    n = len(seq)
    best_depth = -1
    for i in range(n):
        for j in range(i+1, n+1):
            a = seq[:i] + seq[j:]
            b = seq[i:j]
            depth = max(max_depth(a), max_depth(b))
            if depth > best_depth:
                best_depth = depth
                best_a = a
                best_b = b
    answer = [0] * n
    for i in range(n):
        if seq[i] in best_a:
            answer[i] = 0
        else:
            answer[i] = 1
    return answer",104
py_1700_data.csv,"def entity_parser(text):
    specials = {
        ""&quot;"": ""\"""",
        ""&apos;"": ""\'"",
        ""&amp;"": ""&"",
        ""&gt;"": "">"",
        ""&lt;"": ""<"",
        ""&frasl;"": ""/""
    }
    for special in specials:
        text = text.replace(special, specials[special])
    return text","HTML entity parser parser takes HTML code input replace entities special characters characters itself. special characters entities HTML are: Quotation Mark: entity &quot; symbol character "". Single Quote Mark: entity &apos; symbol character '. Ampersand: entity &amp; symbol character &. Greater Sign: entity &gt; symbol character >. Less Sign: entity &lt; symbol character <. Slash: entity &frasl; symbol character /. Given input text string HTML parser, implement entity parser. Return text replacing entities special characters.",1,"def entity_parser(text):
    specials = {
        ""&quot;"": ""\"""",
        ""&apos;"": ""\'"",
        ""&amp;"": ""&"",
        ""&gt;"": "">"",
        ""&lt;"": ""<"",
        ""&frasl;"": ""/""
    }
    for special in specials:
        text = text.replace(special, specials[special])
    return text",105
py_good_answer.csv,"
def check_list(list1, list2):
    return set(list2).issubset(set(list1))
",Write Python program check elements list included another given list.,3,"def check_list(list1, list2):
    return set(list2).issubset(set(list1))
",106
py_1700_data.csv,"def removeComments(source: List[str]) -> List[str]:
    ans = []
    in_block_comment = False
    for line in source:
        i = 0
        if not in_block_comment:
            new_line = []
        while i < len(line):
            if line[i:i+2] == '/*' and not in_block_comment:
                in_block_comment = True
                i += 1
            elif line[i:i+2] == '*/' and in_block_comment:
                in_block_comment = False
                i += 1
            elif line[i:i+2] == '//':
                break    # line comment, ignore rest of the line
            elif not in_block_comment:
                new_line.append(line[i])
            i += 1
        if new_line and not in_block_comment:
            ans.append("""".join(new_line))
    return ans","Given C++ program, remove comments it. program source array strings source source[i] ith line source code. represents result splitting original source code string newline character '\n'. C++, two types comments, line comments, block comments. string ""//"" denotes line comment, represents rest characters right line ignored. string ""/*"" denotes block comment, represents characters next (non-overlapping) occurrence ""*/"" ignored. (Here, occurrences happen reading order: line line left right.) clear, string ""/*/"" yet end block comment, ending would overlapping beginning. first effective comment takes precedence others. example, string ""//"" occurs block comment, ignored. Similarly, string ""/*"" occurs line block comment, also ignored. certain line code empty removing comments, must output line: string answer list non-empty. control characters, single quote, double quote characters. example, source = ""string = ""/* comment. */"";"" test case. Also, nothing else defines macros interfere comments. guaranteed every open block comment eventually closed, ""/*"" outside line block comment always starts new comment. Finally, implicit newline characters deleted block comments. Please see examples details. removing comments source code, return source code format.",3,"def removeComments(source: List[str]) -> List[str]:
    ans = []
    in_block_comment = False
    for line in source:
        i = 0
        if not in_block_comment:
            new_line = []
        while i < len(line):
            if line[i:i+2] == '/*' and not in_block_comment:
                in_block_comment = True
                i += 1
            elif line[i:i+2] == '*/' and in_block_comment:
                in_block_comment = False
                i += 1
            elif line[i:i+2] == '//':
                break    
            elif not in_block_comment:
                new_line.append(line[i])
            i += 1
        if new_line and not in_block_comment:
            ans.append("""".join(new_line))
    return ans",107
py_1700_data.csv,"def add(num1, num2):
    return num1 + num2","Given two integers num1 num2, return sum two integers.",3,"def add(num1, num2):
    return num1 + num2",108
py_1700_data.csv,"def preorderTraversal(root):
    if not root:
        return []
    res = [root.val]
    res += preorderTraversal(root.left)
    res += preorderTraversal(root.right)
    return res","Given root binary tree, return preorder traversal nodes' values.",0,"def preorderTraversal(root):
    if not root:
        return []
    res = [root.val]
    res += preorderTraversal(root.left)
    res += preorderTraversal(root.right)
    return res",109
py_1700_data.csv,"
def closedIsland(grid):
    def dfs(i, j):
        if 0 <= i < m and 0 <= j < n and grid[i][j] == 0:
            grid[i][j] = 1
            dfs(i+1, j)
            dfs(i-1, j)
            dfs(i, j+1)
            dfs(i, j-1)
            return True
        return False

    m, n = len(grid), len(grid[0])
    count = 0
    for i in range(m):
        for j in range(n):
            if i == 0 or j == 0 or i == m-1 or j == n-1:
                dfs(i, j)
    for i in range(1, m-1):
        for j in range(1, n-1):
            if grid[i][j] == 0:
                if dfs(i, j):
                    count += 1
    return count
","Given 2D grid consists 0s (land) 1s (water). island maximal 4-directionally connected group 0s closed island island totally (all left, top, right, bottom) surrounded 1s. Return number closed islands.",1,"def closedIsland(grid):
    def dfs(i, j):
        if 0 <= i < m and 0 <= j < n and grid[i][j] == 0:
            grid[i][j] = 1
            dfs(i+1, j)
            dfs(i-1, j)
            dfs(i, j+1)
            dfs(i, j-1)
            return True
        return False
    m, n = len(grid), len(grid[0])
    count = 0
    for i in range(m):
        for j in range(n):
            if i == 0 or j == 0 or i == m-1 or j == n-1:
                dfs(i, j)
    for i in range(1, m-1):
        for j in range(1, n-1):
            if grid[i][j] == 0:
                if dfs(i, j):
                    count += 1
    return count
",110
py_70_data.csv,"def recursive_series(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return recursive_series(n-1) + recursive_series(n-2)",series using recursive method.,3,"def recursive_series(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return recursive_series(n-1) + recursive_series(n-2)",111
py_1700_data.csv,"
class Solution:
    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:
        graph = defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        def dfs(node, prev):
            cost = 0
            for nei in graph[node]:
                if nei == prev:
                    continue
                c = dfs(nei, node)
                if c or hasApple[nei]:
                    cost += c + 2
            return cost

        return max(0, dfs(0, -1) - 2)
","Given undirected tree consisting n vertices numbered 0 n-1, apples vertices. spend 1 second walk one edge tree. Return minimum time seconds spend collect apples tree, starting vertex 0 coming back vertex. edges undirected tree given array edges, edges[i] = [ai, bi] means exists edge connecting vertices ai bi. Additionally, boolean array hasApple, hasApple[i] = true means vertex apple; otherwise, apple.",0,"class Solution:
    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:
        graph = defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        def dfs(node, prev):
            cost = 0
            for nei in graph[node]:
                if nei == prev:
                    continue
                c = dfs(nei, node)
                if c or hasApple[nei]:
                    cost += c + 2
            return cost
        return max(0, dfs(0, -1) - 2)
",112
py_1700_data.csv,"def numTilePossibilities(tiles):
    def dfs(curr):
        if curr:
            seen.add(curr)
        for i in range(len(tiles)):
            if used[i]:
                continue
            used[i] = True
            dfs(curr + tiles[i])
            used[i] = False
    
    used = [False] * len(tiles)
    seen = set()
    dfs('')
    return len(seen) - 1","n tiles, tile one letter tiles[i] printed it. Return number possible non-empty sequences letters make using letters printed tiles.",0,"def numTilePossibilities(tiles):
    def dfs(curr):
        if curr:
            seen.add(curr)
        for i in range(len(tiles)):
            if used[i]:
                continue
            used[i] = True
            dfs(curr + tiles[i])
            used[i] = False
    used = [False] * len(tiles)
    seen = set()
    dfs('')
    return len(seen) - 1",113
py_1700_data.csv,"
def longestConsecutive(nums):
    num_set = set(nums)
    longest_streak = 0
    
    for num in num_set:
        if num-1 not in num_set:
            current_num = num
            current_streak = 1
            
            while current_num+1 in num_set:
                current_num += 1
                current_streak += 1
            
            longest_streak = max(longest_streak, current_streak)
    
    return longest_streak
","Given unsorted array integers nums, return length longest consecutive elements sequence. must write algorithm runs O(n) time.",3,"def longestConsecutive(nums):
    num_set = set(nums)
    longest_streak = 0
    for num in num_set:
        if num-1 not in num_set:
            current_num = num
            current_streak = 1
            while current_num+1 in num_set:
                current_num += 1
                current_streak += 1
            longest_streak = max(longest_streak, current_streak)
    return longest_streak
",114
py_1700_data.csv,"class Node:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.head = Node(0, 0)
        self.tail = Node(0, 0)
        self.head.next = self.tail
        self.tail.prev = self.head
    
    def _remove_node(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev
    
    def _add_node_to_front(self, node):
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    def get(self, key: int) -> int:
        if key in self.cache:
            node = self.cache[key]
            self._remove_node(node)
            self._add_node_to_front(node)
            return node.value
        return -1
    
    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            node = self.cache[key]
            node.value = value
            self._remove_node(node)
            self._add_node_to_front(node)
        else:
            if len(self.cache) == self.capacity:
                del self.cache[self.tail.prev.key]
                self._remove_node(self.tail.prev)
            node = Node(key, value)
            self.cache[key] = node
            self._add_node_to_front(node)","Design data structure follows constraints Least Recently Used (LRU) cache. Implement LRUCache class: LRUCache(int capacity) Initialize LRU cache positive size capacity. int get(int key) Return value key key exists, otherwise return -1. void put(int key, int value) Update value key key exists. Otherwise, add key-value pair cache. number keys exceeds capacity operation, evict least recently used key. functions get put must run O(1) average time complexity.",3,"class Node:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None
class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.head = Node(0, 0)
        self.tail = Node(0, 0)
        self.head.next = self.tail
        self.tail.prev = self.head
    def _remove_node(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev
    def _add_node_to_front(self, node):
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    def get(self, key: int) -> int:
        if key in self.cache:
            node = self.cache[key]
            self._remove_node(node)
            self._add_node_to_front(node)
            return node.value
        return -1
    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            node = self.cache[key]
            node.value = value
            self._remove_node(node)
            self._add_node_to_front(node)
        else:
            if len(self.cache) == self.capacity:
                del self.cache[self.tail.prev.key]
                self._remove_node(self.tail.prev)
            node = Node(key, value)
            self.cache[key] = node
            self._add_node_to_front(node)",115
py_1700_data.csv,"
import random

def original_from_changed(changed):
    if not changed:
        return []

    original = []
    for val in changed:
        original.extend([val // 2] * 2)

    random.shuffle(original)
    return original
","integer array original transformed doubled array changed appending twice value every element original, randomly shuffling resulting array. Given array changed, return original changed doubled array. changed doubled array, return empty array. elements original may returned order.",1,"import random
def original_from_changed(changed):
    if not changed:
        return []
    original = []
    for val in changed:
        original.extend([val // 2] * 2)
    random.shuffle(original)
    return original
",116
py_good_answer.csv,"
def find_common_elements(lists):
    common_elements = set(lists[0])
    for lst in lists:
        common_elements.intersection_update(lst)
    return list(common_elements)
",Write Python program find common elements given list lists.,3,"def find_common_elements(lists):
    common_elements = set(lists[0])
    for lst in lists:
        common_elements.intersection_update(lst)
    return list(common_elements)
",117
py_1700_data.csv,"def time_to_minutes(time):
    hrs, mins = map(int, time.split("":""))
    return hrs*60 + mins

def minutes_to_time(minutes):
    hrs, mins = divmod(minutes, 60)
    return f""{hrs:02d}:{mins:02d}""

def minimum_operations_needed(current, correct, operations):
    current_minutes = time_to_minutes(current)
    correct_minutes = time_to_minutes(correct)
    difference = abs(correct_minutes - current_minutes)
    count = 0
    for op in operations[::-1]:
        count += difference // op
        difference %= op
    return count

current = ""12:30""
correct = ""15:45""
operations = [1, 15, 60]
print(minimum_operations_needed(current, correct, operations)) # Output: 2","given two strings current correct representing two 24-hour times. 24-hour times formatted ""HH:MM"", HH 00 23, MM 00 59. earliest 24-hour time 00:00, latest 23:59. one operation increase time current 1, 5, 15, 60 minutes. perform operation number times. Return minimum number operations needed convert current correct.",2,"def time_to_minutes(time):
    hrs, mins = map(int, time.split("":""))
    return hrs*60 + mins
def minutes_to_time(minutes):
    hrs, mins = divmod(minutes, 60)
    return f""{hrs:02d}:{mins:02d}""
def minimum_operations_needed(current, correct, operations):
    current_minutes = time_to_minutes(current)
    correct_minutes = time_to_minutes(correct)
    difference = abs(correct_minutes - current_minutes)
    count = 0
    for op in operations[::-1]:
        count += difference // op
        difference %= op
    return count
current = ""12:30""
correct = ""15:45""
operations = [1, 15, 60]
print(minimum_operations_needed(current, correct, operations)) ",118
py_1700_data.csv,"def shortestPathBinaryMatrix(grid):
    n = len(grid)
    if grid[0][0] == 1 or grid[n-1][n-1] == 1:
        return -1
    queue = [(0,0,1)]
    visited = set((0,0))
    while queue:
        x, y, dist = queue.pop(0)
        if x == n-1 and y == n-1:
            return dist
        for dx, dy in [(1,1), (1,0), (0,1), (-1,-1), (-1,0), (0,-1), (1,-1), (-1,1)]:
            nx, ny = x+dx, y+dy
            if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx,ny) not in visited:
                visited.add((nx,ny))
                queue.append((nx,ny,dist+1))
    return -1","Given n x n binary matrix grid, return length shortest clear path matrix. clear path, return -1. clear path binary matrix path top-left cell (i.e., (0, 0)) bottom-right cell (i.e., (n - 1, n - 1)) that: visited cells path 0. adjacent cells path 8-directionally connected (i.e., different share edge corner). length clear path number visited cells path.",3,"def shortestPathBinaryMatrix(grid):
    n = len(grid)
    if grid[0][0] == 1 or grid[n-1][n-1] == 1:
        return -1
    queue = [(0,0,1)]
    visited = set((0,0))
    while queue:
        x, y, dist = queue.pop(0)
        if x == n-1 and y == n-1:
            return dist
        for dx, dy in [(1,1), (1,0), (0,1), (-1,-1), (-1,0), (0,-1), (1,-1), (-1,1)]:
            nx, ny = x+dx, y+dy
            if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx,ny) not in visited:
                visited.add((nx,ny))
                queue.append((nx,ny,dist+1))
    return -1",119
py_1700_data.csv,"
def minimize_string(s, n):
    def get_prefix_suffix_indices(s):
        prefix_indices = []
        suffix_indices = []
        for i in range(1, len(s)):
            if s[:i] == s[-i:]:
                prefix_indices.append(i)
                suffix_indices.append(len(s) - i)
        return prefix_indices, suffix_indices
        
    def delete_substr(s, start, end):
        return s[:start] + s[end:]

    min_len = len(s)
    for _ in range(n):
        prefix_indices, suffix_indices = get_prefix_suffix_indices(s)
        if not prefix_indices:
            break
        intersect_index = max(suffix_indices)
        for i in prefix_indices:
            if i <= intersect_index:
                intersect_index = i - 1
                break
        s = delete_substr(s, 0, intersect_index+1) + delete_substr(s, -intersect_index-1, None)
        min_len = min(min_len, len(s))
    return min_len
","Given string consisting characters 'a', 'b', 'c'. asked apply following algorithm string number times: Pick non-empty prefix string characters prefix equal. Pick non-empty suffix string characters suffix equal. prefix suffix intersect index. characters prefix suffix must same. Delete prefix suffix. Return minimum length performing operation number times (possibly zero times).",3,"def minimize_string(s, n):
    def get_prefix_suffix_indices(s):
        prefix_indices = []
        suffix_indices = []
        for i in range(1, len(s)):
            if s[:i] == s[-i:]:
                prefix_indices.append(i)
                suffix_indices.append(len(s) - i)
        return prefix_indices, suffix_indices
    def delete_substr(s, start, end):
        return s[:start] + s[end:]
    min_len = len(s)
    for _ in range(n):
        prefix_indices, suffix_indices = get_prefix_suffix_indices(s)
        if not prefix_indices:
            break
        intersect_index = max(suffix_indices)
        for i in prefix_indices:
            if i <= intersect_index:
                intersect_index = i - 1
                break
        s = delete_substr(s, 0, intersect_index+1) + delete_substr(s, -intersect_index-1, None)
        min_len = min(min_len, len(s))
    return min_len
",120
py_1700_data.csv,"def nextGreaterElements(nums):
    stack = []
    res = [-1] * len(nums)
    for i in range(len(nums)*2):
        while stack and nums[stack[-1]] < nums[i%len(nums)]:
            res[stack.pop()] = nums[i%len(nums)]
        stack.append(i%len(nums))
    return res","Given circular integer array nums (i.e., next element nums[nums.length - 1] nums[0]), return next greater number every element nums. next greater number number x first greater number traversing-order next array, means could search circularly find next greater number. exist, return -1 number.",0,"def nextGreaterElements(nums):
    stack = []
    res = [-1] * len(nums)
    for i in range(len(nums)*2):
        while stack and nums[stack[-1]] < nums[i%len(nums)]:
            res[stack.pop()] = nums[i%len(nums)]
        stack.append(i%len(nums))
    return res",121
py_1700_data.csv,"
def advantage_shuffle(nums1, nums2):
    nums1.sort()
    res = [-1] * len(nums1)
    candidates = list(range(len(nums1)))
    for n in sorted(nums2)[::-1]:
        i = candidates.pop(candidates.index(max([x for x in candidates if nums1[x] > n], default=-1)))
        res[i] = n
    return [nums1[i] if res[i] == -1 else res[i] for i in range(len(nums1))]
",given two integer arrays nums1 nums2 length. advantage nums1 respect nums2 number indices nums1[i] > nums2[i]. Return permutation nums1 maximizes advantage respect nums2.,0,"def advantage_shuffle(nums1, nums2):
    nums1.sort()
    res = [-1] * len(nums1)
    candidates = list(range(len(nums1)))
    for n in sorted(nums2)[::-1]:
        i = candidates.pop(candidates.index(max([x for x in candidates if nums1[x] > n], default=-1)))
        res[i] = n
    return [nums1[i] if res[i] == -1 else res[i] for i in range(len(nums1))]
",122
py_1700_data.csv,"def find_winner(n, k):
    current_friend = 0
    friends = list(range(1, n+1))
    while len(friends) > 1:
        current_friend = (current_friend + k - 1) % len(friends)
        friends.pop(current_friend)
    return friends[0]","n friends playing game. friends sitting circle numbered 1 n clockwise order. formally, moving clockwise ith friend brings (i+1)th friend 1 <= < n, moving clockwise nth friend brings 1st friend. rules game follows: Start 1st friend. Count next k friends clockwise direction including friend started at. counting wraps around circle may count friends once. last friend counted leaves circle loses game. still one friend circle, go back step 2 starting friend immediately clockwise friend lost repeat. Else, last friend circle wins game. Given number friends, n, integer k, return winner game.",0,"def find_winner(n, k):
    current_friend = 0
    friends = list(range(1, n+1))
    while len(friends) > 1:
        current_friend = (current_friend + k - 1) % len(friends)
        friends.pop(current_friend)
    return friends[0]",123
py_1700_data.csv,"def reshape(mat, r, c):
    rows = len(mat)
    cols = len(mat[0])
    
    if rows * cols == r * c:
        flattened = [elem for row in mat for elem in row]
        reshaped = [flattened[i*c:(i+1)*c] for i in range(r)]
        return reshaped
    else:
        return mat","MATLAB, handy function called reshape reshape x n matrix new one different size r x c keeping original data. given x n matrix mat two integers r c representing number rows number columns wanted reshaped matrix. reshaped matrix filled elements original matrix row-traversing order were. reshape operation given parameters possible legal, output new reshaped matrix; Otherwise, output original matrix.",3,"def reshape(mat, r, c):
    rows = len(mat)
    cols = len(mat[0])
    if rows * cols == r * c:
        flattened = [elem for row in mat for elem in row]
        reshaped = [flattened[i*c:(i+1)*c] for i in range(r)]
        return reshaped
    else:
        return mat",124
py_1700_data.csv,"def is_possible_to_print_matrix(targetGrid):
    def dfs(top, bottom, left, right, color):
        if top > bottom or left > right:
            return True
        if memo[(top, bottom, left, right, color)] != -1:
            return memo[(top, bottom, left, right, color)]
        for i in range(top, bottom + 1):
            for j in range(left, right + 1):
                if targetGrid[i][j] == color:
                    if dfs(top, i - 1, left, right, color) and dfs(i + 1, bottom, left, right, color) and dfs(top, bottom, left, j - 1, color) and dfs(top, bottom, j + 1, right, color):
                        memo[(top, bottom, left, right, color)] = True
                        return True
        for k in range(top, bottom + 1):
            for l in range(left, right + 1):
                if targetGrid[k][l] != color and targetGrid[k][l] != -1:
                    if dfs(top, bottom, left, l - 1, targetGrid[k][l]) and dfs(top, bottom, l + 1, right, targetGrid[k][l]) and dfs(top, k - 1, l, l, targetGrid[k][l]) and dfs(k + 1, bottom, l, l, targetGrid[k][l]):
                        memo[(top, bottom, left, right, color)] = True
                        return True
        memo[(top, bottom, left, right, color)] = False
        return False

    memo = {}
    for i in range(len(targetGrid)):
        for j in range(len(targetGrid[i])):
            memo[(i, i, j, j, targetGrid[i][j])] = True
            for color in range(1, 60):
                memo[(i, i, j, j, color)] = False
    for size in range(2, len(targetGrid) + len(targetGrid[0]) + 1):
        for i in range(len(targetGrid) - size + 1):
            for j in range(len(targetGrid[i]) - size + 1):
                top, bottom, left, right = i, i + size - 1, j, j + size - 1
                memo[(top, bottom, left, right, -1)] = False
                for color in range(1, 60):
                    if dfs(top, bottom, left, right, color):
                        memo[(top, bottom, left, right, color)] = True
                        break
                    memo[(top, bottom, left, right, color)] = False
                if memo[(top, bottom, left, right, targetGrid[i][j])] == False:
                    return False
    return True","strange printer following two special requirements: turn, printer print solid rectangular pattern single color grid. cover existing colors rectangle. printer used color operation, color cannot used again. given x n matrix targetGrid, targetGrid[row][col] color position (row, col) grid. Return true possible print matrix targetGrid, otherwise, return false.",0,"def is_possible_to_print_matrix(targetGrid):
    def dfs(top, bottom, left, right, color):
        if top > bottom or left > right:
            return True
        if memo[(top, bottom, left, right, color)] != -1:
            return memo[(top, bottom, left, right, color)]
        for i in range(top, bottom + 1):
            for j in range(left, right + 1):
                if targetGrid[i][j] == color:
                    if dfs(top, i - 1, left, right, color) and dfs(i + 1, bottom, left, right, color) and dfs(top, bottom, left, j - 1, color) and dfs(top, bottom, j + 1, right, color):
                        memo[(top, bottom, left, right, color)] = True
                        return True
        for k in range(top, bottom + 1):
            for l in range(left, right + 1):
                if targetGrid[k][l] != color and targetGrid[k][l] != -1:
                    if dfs(top, bottom, left, l - 1, targetGrid[k][l]) and dfs(top, bottom, l + 1, right, targetGrid[k][l]) and dfs(top, k - 1, l, l, targetGrid[k][l]) and dfs(k + 1, bottom, l, l, targetGrid[k][l]):
                        memo[(top, bottom, left, right, color)] = True
                        return True
        memo[(top, bottom, left, right, color)] = False
        return False
    memo = {}
    for i in range(len(targetGrid)):
        for j in range(len(targetGrid[i])):
            memo[(i, i, j, j, targetGrid[i][j])] = True
            for color in range(1, 60):
                memo[(i, i, j, j, color)] = False
    for size in range(2, len(targetGrid) + len(targetGrid[0]) + 1):
        for i in range(len(targetGrid) - size + 1):
            for j in range(len(targetGrid[i]) - size + 1):
                top, bottom, left, right = i, i + size - 1, j, j + size - 1
                memo[(top, bottom, left, right, -1)] = False
                for color in range(1, 60):
                    if dfs(top, bottom, left, right, color):
                        memo[(top, bottom, left, right, color)] = True
                        break
                    memo[(top, bottom, left, right, color)] = False
                if memo[(top, bottom, left, right, targetGrid[i][j])] == False:
                    return False
    return True",125
py_good_answer.csv,"INF = float('inf')

def floyd_warshall(graph):
    n = len(graph)
    dist = [[INF] * n for _ in range(n)]

    # Initialize the distance matrix with the weights of the edges
    for i in range(n):
        for j in range(n):
            if i == j:
                dist[i][j] = 0
            elif graph[i][j] != 0:
                dist[i][j] = graph[i][j]

    # Find the shortest path between all pairs of vertices
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    return dist",Python Program Implement Floyd-Warshall Algorithm,0,"INF = float('inf')
def floyd_warshall(graph):
    n = len(graph)
    dist = [[INF] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i == j:
                dist[i][j] = 0
            elif graph[i][j] != 0:
                dist[i][j] = graph[i][j]
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    return dist",126
py_good_answer.csv,"def gcd(a, b):
    while(b):
        a, b = b, a%b
    return a

print(gcd(24, 16)) # Output: 8",Write Python program compute greatest common divisor (GCD) two positive integers.,3,"def gcd(a, b):
    while(b):
        a, b = b, a%b
    return a
print(gcd(24, 16)) ",127
py_good_answer.csv,"def group_lists(lst):
    result = []
    temp = []
    for item in lst:
        if type(item) == list:
            if temp:
                result.append(temp)
                temp = []
            result.append(item)
        else:
            temp.append(item)
    if temp:
        result.append(temp)
    return result",Write Python program Group Sublists another List,0,"def group_lists(lst):
    result = []
    temp = []
    for item in lst:
        if type(item) == list:
            if temp:
                result.append(temp)
                temp = []
            result.append(item)
        else:
            temp.append(item)
    if temp:
        result.append(temp)
    return result",128
py_good_answer.csv,"
def convert_list(lst, key):
    result = []
    for dictt in lst:
        result.append(dictt[key])
    return result
",Write Python program convert given list dictionaries list values corresponding specified key.,3,"def convert_list(lst, key):
    result = []
    for dictt in lst:
        result.append(dictt[key])
    return result
",129
py_1700_data.csv,"def countSubstring(t):
    count = 0
    for i in range(len(t)):
        for j in range(i+1, len(t)+1):
            sub = t[i:j]
            for k in range(len(sub)):
                for alpha in string.ascii_lowercase:
                    if alpha != sub[k]:
                        new_sub = sub[:k] + alpha + sub[k+1:]
                        if new_sub != sub and new_sub in t:
                            count += 1
    return count","Given two strings t, find number ways choose non-empty substring replace single character different character resulting substring substring t. words, find number substrings differ substring exactly one character. example, underlined substrings ""computer"" ""computation"" differ 'e'/'a', valid way. Return number substrings satisfy condition above. substring contiguous sequence characters within string.",0,"def countSubstring(t):
    count = 0
    for i in range(len(t)):
        for j in range(i+1, len(t)+1):
            sub = t[i:j]
            for k in range(len(sub)):
                for alpha in string.ascii_lowercase:
                    if alpha != sub[k]:
                        new_sub = sub[:k] + alpha + sub[k+1:]
                        if new_sub != sub and new_sub in t:
                            count += 1
    return count",130
py_1700_data.csv,"def expressiveWords(S: str, words: List[str]) -> int:
    def decompose(S):
        decom = []
        i = 0
        while i < len(S):
            j = i
            while j < len(S) and S[j] == S[i]:
                j += 1
            decom.append((S[i], j-i))
            i = j
        return decom
    
    def compare(a, b):
        if len(a) != len(b):
            return False
        for i in range(len(a)):
            if a[i][0] != b[i][0]:
                return False
            if a[i][1] < 3 and a[i][1] != b[i][1] or a[i][1] < b[i][1]:
                return False
        return True
    
    S_decom = decompose(S)
    count = 0
    for w in words:
        w_decom = decompose(w)
        if compare(S_decom, w_decom):
            count += 1
    return count","Sometimes people repeat letters represent extra feeling. example: ""hello"" -> ""heeellooo"" ""hi"" -> ""hiiii"" strings like ""heeellooo"", groups adjacent letters same: ""h"", ""eee"", ""ll"", ""ooo"". given string array query strings words. query word stretchy made equal number applications following extension operation: choose group consisting characters c, add number characters c group size group three more. example, starting ""hello"", could extension group ""o"" get ""hellooo"", cannot get ""helloo"" since group ""oo"" size less three. Also, could another extension like ""ll"" -> ""lllll"" get ""helllllooo"". = ""helllllooo"", query word ""hello"" would stretchy two extension operations: query = ""hello"" -> ""hellooo"" -> ""helllllooo"" = s. Return number query strings stretchy.",3,"def expressiveWords(S: str, words: List[str]) -> int:
    def decompose(S):
        decom = []
        i = 0
        while i < len(S):
            j = i
            while j < len(S) and S[j] == S[i]:
                j += 1
            decom.append((S[i], j-i))
            i = j
        return decom
    def compare(a, b):
        if len(a) != len(b):
            return False
        for i in range(len(a)):
            if a[i][0] != b[i][0]:
                return False
            if a[i][1] < 3 and a[i][1] != b[i][1] or a[i][1] < b[i][1]:
                return False
        return True
    S_decom = decompose(S)
    count = 0
    for w in words:
        w_decom = decompose(w)
        if compare(S_decom, w_decom):
            count += 1
    return count",131
py_1700_data.csv,"def num_matches(n):
    matches = 0
    while n > 1:
        matches += n // 2
        if n % 2 == 0:
            n = n // 2
        else:
            n = (n - 1) // 2 + 1
    return matches","given integer n, number teams tournament strange rules: current number teams even, team gets paired another team. total n / 2 matches played, n / 2 teams advance next round. current number teams odd, one team randomly advances tournament, rest gets paired. total (n - 1) / 2 matches played, (n - 1) / 2 + 1 teams advance next round. Return number matches played tournament winner decided.",3,"def num_matches(n):
    matches = 0
    while n > 1:
        matches += n // 2
        if n % 2 == 0:
            n = n // 2
        else:
            n = (n - 1) // 2 + 1
    return matches",132
py_1700_data.csv,"def build_matrix(k, rowConditions, colConditions):
    matrix = [[0 for _ in range(k)] for _ in range(k)]
    for i in range(len(rowConditions)):
        above, below = rowConditions[i]
        for num in range(1, k + 1):
            row = matrix.index([num]*k) if [num]*k in matrix else -1
            if row > above and row < k - below - 1:
                for j in range(k):
                    if matrix[row][j] == 0:
                        matrix[row][j] = num
                        break
    for i in range(len(colConditions)):
        left, right = colConditions[i]
        for num in range(1, k + 1):
            col = [matrix[j][left:right+1] for j in range(k)].index([num]*(right-left+1)) if [num]*(right-left+1) in [matrix[j][left:right+1] for j in range(k)] else -1
            if col != -1:
                if col > left and col < k - right - 1:
                    for j in range(k):
                        if matrix[j][col] == 0:
                            matrix[j][col] = num
                            break
    return matrix","given positive integer k. also given: 2D integer array rowConditions size n rowConditions[i] = [abovei, belowi], 2D integer array colConditions size colConditions[i] = [lefti, righti]. two arrays contain integers 1 k. build k x k matrix contains numbers 1 k exactly once. remaining cells value 0. matrix also satisfy following conditions: number abovei appear row strictly row number belowi appears 0 n - 1. number lefti appear column strictly left column number righti appears 0 - 1. Return matrix satisfies conditions. answer exists, return empty matrix.",0,"def build_matrix(k, rowConditions, colConditions):
    matrix = [[0 for _ in range(k)] for _ in range(k)]
    for i in range(len(rowConditions)):
        above, below = rowConditions[i]
        for num in range(1, k + 1):
            row = matrix.index([num]*k) if [num]*k in matrix else -1
            if row > above and row < k - below - 1:
                for j in range(k):
                    if matrix[row][j] == 0:
                        matrix[row][j] = num
                        break
    for i in range(len(colConditions)):
        left, right = colConditions[i]
        for num in range(1, k + 1):
            col = [matrix[j][left:right+1] for j in range(k)].index([num]*(right-left+1)) if [num]*(right-left+1) in [matrix[j][left:right+1] for j in range(k)] else -1
            if col != -1:
                if col > left and col < k - right - 1:
                    for j in range(k):
                        if matrix[j][col] == 0:
                            matrix[j][col] = num
                            break
    return matrix",133
py_1700_data.csv,"def smooth_descent_periods(prices):
    count = 0
    for i in range(1, len(prices)):
        if prices[i] < prices[i-1]:
            count += 1
    return count","given integer array prices representing daily price history stock, prices[i] stock price ith day. smooth descent period stock consists one contiguous days price day lower price preceding day exactly 1. first day period exempted rule. Return number smooth descent periods.",0,"def smooth_descent_periods(prices):
    count = 0
    for i in range(1, len(prices)):
        if prices[i] < prices[i-1]:
            count += 1
    return count",134
py_1700_data.csv,"MOD = 10 ** 9 + 7

def max_product(root):
    def dfs(node):
        if not node:
            return 0
        left_sum = dfs(node.left)
        right_sum = dfs(node.right)
        subtree_sum = left_sum + right_sum + node.val
        sums[subtree_sum] += 1
        return subtree_sum
    
    def get_max_product(node, total_sum):
        if not node:
            return 0
        left_sum = get_max_product(node.left, total_sum)
        right_sum = get_max_product(node.right, total_sum)
        subtree_sum = left_sum + right_sum + node.val
        other_sum = total_sum - subtree_sum
        product = (other_sum * subtree_sum) % MOD
        if product > max_product[0]:
            max_product[0] = product
        return subtree_sum
    
    sums = defaultdict(int)
    dfs(root)
    total_sum = sums[max(sums)]
    max_product = [0]
    get_max_product(root, total_sum)
    return max_product[0]","Given root binary tree, split binary tree two subtrees removing one edge product sums subtrees maximized. Return maximum product sums two subtrees. Since answer may large, return modulo 109 + 7. Note need maximize answer taking mod taking it.",0,"MOD = 10 ** 9 + 7
def max_product(root):
    def dfs(node):
        if not node:
            return 0
        left_sum = dfs(node.left)
        right_sum = dfs(node.right)
        subtree_sum = left_sum + right_sum + node.val
        sums[subtree_sum] += 1
        return subtree_sum
    def get_max_product(node, total_sum):
        if not node:
            return 0
        left_sum = get_max_product(node.left, total_sum)
        right_sum = get_max_product(node.right, total_sum)
        subtree_sum = left_sum + right_sum + node.val
        other_sum = total_sum - subtree_sum
        product = (other_sum * subtree_sum) % MOD
        if product > max_product[0]:
            max_product[0] = product
        return subtree_sum
    sums = defaultdict(int)
    dfs(root)
    total_sum = sums[max(sums)]
    max_product = [0]
    get_max_product(root, total_sum)
    return max_product[0]",135
py_1700_data.csv,"def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)

def countSubarrays(nums, k):
    n = len(nums)
    count = 0
    
    for i in range(n):
        subarray_gcd = nums[i]
        for j in range(i, n):
            subarray_gcd = gcd(subarray_gcd, nums[j])
            if subarray_gcd == k:
                count += 1
    
    return count","Given integer array nums integer k, return number subarrays nums greatest common divisor subarray's elements k. subarray contiguous non-empty sequence elements within array. greatest common divisor array largest integer evenly divides array elements.",3,"def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)
def countSubarrays(nums, k):
    n = len(nums)
    count = 0
    for i in range(n):
        subarray_gcd = nums[i]
        for j in range(i, n):
            subarray_gcd = gcd(subarray_gcd, nums[j])
            if subarray_gcd == k:
                count += 1
    return count",136
py_good_answer.csv,"
def move_element(lst, ele, idx):
    lst.remove(ele)
    lst.insert(idx, ele)
    return lst
",Write Python program move specified element given list.,0,"def move_element(lst, ele, idx):
    lst.remove(ele)
    lst.insert(idx, ele)
    return lst
",137
py_1700_data.csv,"def numOfSubarrays(arr: List[int], k: int, threshold: int) -> int:
    target = k * threshold
    current_sum = sum(arr[:k])
    count = 1 if current_sum >= target else 0
    
    for i in range(k, len(arr)):
        current_sum = current_sum - arr[i-k] + arr[i]
        if current_sum >= target:
            count += 1
    
    return count","Given array integers arr two integers k threshold, return number sub-arrays size k average greater equal threshold.",3,"def numOfSubarrays(arr: List[int], k: int, threshold: int) -> int:
    target = k * threshold
    current_sum = sum(arr[:k])
    count = 1 if current_sum >= target else 0
    for i in range(k, len(arr)):
        current_sum = current_sum - arr[i-k] + arr[i]
        if current_sum >= target:
            count += 1
    return count",138
py_1700_data.csv,"class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = []
        for i in range(numRows):
            row = [1] * (i + 1)
            for j in range(1, i):
                row[j] = res[i-1][j-1] + res[i-1][j]
            res.append(row)
        return res","Given integer numRows, return first numRows Pascal's triangle. Pascal's triangle, number sum two numbers directly shown:",3,"class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = []
        for i in range(numRows):
            row = [1] * (i + 1)
            for j in range(1, i):
                row[j] = res[i-1][j-1] + res[i-1][j]
            res.append(row)
        return res",139
py_good_answer.csv,"
def interleave(*lists):
    max_len = max(len(lst) for lst in lists)
    result = []
    for i in range(max_len):
        for lst in lists:
            if i < len(lst):
                result.append(lst[i])
    return result
",Write Python program interleave multiple given lists different lengths.,3,"def interleave(*lists):
    max_len = max(len(lst) for lst in lists)
    result = []
    for i in range(max_len):
        for lst in lists:
            if i < len(lst):
                result.append(lst[i])
    return result
",140
py_1700_data.csv,"class Solution:
    def destCity(self, paths: List[List[str]]) -> str:
        hash_map = {}
        for path in paths:
            hash_map[path[0]] = path[1]
        for city in hash_map.values():
            if city not in hash_map:
                return city","given array paths, paths[i] = [cityAi, cityBi] means exists direct path going cityAi cityBi. Return destination city, is, city without path outgoing another city. guaranteed graph paths forms line without loop, therefore, exactly one destination city.",3,"class Solution:
    def destCity(self, paths: List[List[str]]) -> str:
        hash_map = {}
        for path in paths:
            hash_map[path[0]] = path[1]
        for city in hash_map.values():
            if city not in hash_map:
                return city",141
py_1700_data.csv,"def maxAlternatingSum(nums):
    dp = [0] * len(nums)
    dp[0] = nums[0]
    for i in range(1, len(nums)):
        dp[i] = max(dp[i-1] + nums[i], nums[i])
    return max(dp)

nums = [4,2,5,3]
print(maxAlternatingSum(nums)) # 4

nums2 = [4,2,3,7,2,1,4]
print(maxAlternatingSum(nums2)) # 16","alternating sum 0-indexed array defined sum elements even indices minus sum elements odd indices. example, alternating sum [4,2,5,3] (4 + 5) - (2 + 3) = 4. Given array nums, return maximum alternating sum subsequence nums (after reindexing elements subsequence). subsequence array new array generated original array deleting elements (possibly none) without changing remaining elements' relative order. example, [2,7,4] subsequence [4,2,3,7,2,1,4] (the underlined elements), [2,4,2] not.",0,"def maxAlternatingSum(nums):
    dp = [0] * len(nums)
    dp[0] = nums[0]
    for i in range(1, len(nums)):
        dp[i] = max(dp[i-1] + nums[i], nums[i])
    return max(dp)
nums = [4,2,5,3]
print(maxAlternatingSum(nums)) 
nums2 = [4,2,3,7,2,1,4]
print(maxAlternatingSum(nums2)) ",142
py_good_answer.csv,"class Node: 
    def __init__(self, data): 
        self.data = data  
        self.next = None  
        self.prev = None  

    def __str__(self):
        return str(self.data)
  
class DoublyLinkedList: 
    def __init__(self):
        self.head = None
  
    def append(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            return
        last_node = self.head
        while last_node.next:
            last_node = last_node.next
        last_node.next = new_node
        new_node.prev = last_node

    def largest_element(self):
        if self.head is None:
            return None
        largest = self.head
        current = self.head
        while current:
            if current.data > largest.data:
                largest = current
            current = current.next
        return largest
      
dll = DoublyLinkedList()
dll.append(1)
dll.append(2)
dll.append(3)
dll.append(2)
dll.append(1)
print(dll.largest_element())  # Output: 3",Python Program Find Largest Element Doubly Linked List,0,"class Node: 
    def __init__(self, data): 
        self.data = data  
        self.next = None  
        self.prev = None  
    def __str__(self):
        return str(self.data)
class DoublyLinkedList: 
    def __init__(self):
        self.head = None
    def append(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            return
        last_node = self.head
        while last_node.next:
            last_node = last_node.next
        last_node.next = new_node
        new_node.prev = last_node
    def largest_element(self):
        if self.head is None:
            return None
        largest = self.head
        current = self.head
        while current:
            if current.data > largest.data:
                largest = current
            current = current.next
        return largest
dll = DoublyLinkedList()
dll.append(1)
dll.append(2)
dll.append(3)
dll.append(2)
dll.append(1)
print(dll.largest_element())  ",143
py_1700_data.csv,"class Solution:
    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:
        MOD = 10**9 + 7
        dp = [[0] * n for _ in range(m)]
        dp[startRow][startColumn] = 1
        res = 0
        dirs = [(0,1), (0,-1), (1,0), (-1,0)]
        for move in range(maxMove):
            new_dp = [[0] * n for _ in range(m)]
            for i in range(m):
                for j in range(n):
                    for d in dirs:
                        new_i = i + d[0]
                        new_j = j + d[1]
                        if new_i < 0 or new_i >= m or new_j < 0 or new_j >= n:
                            res = (res + dp[i][j]) % MOD
                        else:
                            new_dp[new_i][new_j] = (new_dp[new_i][new_j] + dp[i][j]) % MOD
            dp = new_dp
        return res % MOD","x n grid ball. ball initially position [startRow, startColumn]. allowed move ball one four adjacent cells grid (possibly grid crossing grid boundary). apply maxMove moves ball. Given five integers m, n, maxMove, startRow, startColumn, return number paths move ball grid boundary. Since answer large, return modulo 109 + 7.",0,"class Solution:
    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:
        MOD = 10**9 + 7
        dp = [[0] * n for _ in range(m)]
        dp[startRow][startColumn] = 1
        res = 0
        dirs = [(0,1), (0,-1), (1,0), (-1,0)]
        for move in range(maxMove):
            new_dp = [[0] * n for _ in range(m)]
            for i in range(m):
                for j in range(n):
                    for d in dirs:
                        new_i = i + d[0]
                        new_j = j + d[1]
                        if new_i < 0 or new_i >= m or new_j < 0 or new_j >= n:
                            res = (res + dp[i][j]) % MOD
                        else:
                            new_dp[new_i][new_j] = (new_dp[new_i][new_j] + dp[i][j]) % MOD
            dp = new_dp
        return res % MOD",144
py_1700_data.csv,"def minOperations(target):
    res = 0
    cur = 0
    for n in target:
        if n > cur:
            res += n - cur
            cur = n
        else:
            cur = n
        
    return res",given integer array target. integer array initial size target elements initially zeros. one operation choose subarray initial increment value one. Return minimum number operations form target array initial. test cases generated answer fits 32-bit integer.,3,"def minOperations(target):
    res = 0
    cur = 0
    for n in target:
        if n > cur:
            res += n - cur
            cur = n
        else:
            cur = n
    return res",145
py_1700_data.csv,"class Solution:
    def isBoomerang(self, points: List[List[int]]) -> bool:
        return (points[2][1]-points[0][1])*(points[1][0]-points[0][0]) != (points[1][1]-points[0][1])*(points[2][0]-points[0][0])","Given array points points[i] = [xi, yi] represents point X-Y plane, return true points boomerang. boomerang set three points distinct straight line.",3,"class Solution:
    def isBoomerang(self, points: List[List[int]]) -> bool:
        return (points[2][1]-points[0][1])*(points[1][0]-points[0][0]) != (points[1][1]-points[0][1])*(points[2][0]-points[0][0])",146
py_good_answer.csv,"def find_substring(string):
    letters = []
    for char in string:
        if char not in letters:
            letters.append(char)
    n = len(letters)
    unique_char_count = 0
    char_count = [0] * 128
    start = 0
    min_len = len(string)
    start_index = -1
    for j in range(len(string)):
        char_count[ord(string[j])] += 1
        if char_count[ord(string[j])] == 1:
            unique_char_count += 1
        if unique_char_count == n:
            while char_count[ord(string[start])] > 1:
                if char_count[ord(string[start])] > 1:
                    char_count[ord(string[start])] -= 1
                start += 1
            len_window = j - start + 1
            if min_len > len_window:
                min_len = len_window
                start_index = start
    return string[start_index:start_index+min_len]",Write Python program find smallest window contains characters given string.,2,"def find_substring(string):
    letters = []
    for char in string:
        if char not in letters:
            letters.append(char)
    n = len(letters)
    unique_char_count = 0
    char_count = [0] * 128
    start = 0
    min_len = len(string)
    start_index = -1
    for j in range(len(string)):
        char_count[ord(string[j])] += 1
        if char_count[ord(string[j])] == 1:
            unique_char_count += 1
        if unique_char_count == n:
            while char_count[ord(string[start])] > 1:
                if char_count[ord(string[start])] > 1:
                    char_count[ord(string[start])] -= 1
                start += 1
            len_window = j - start + 1
            if min_len > len_window:
                min_len = len_window
                start_index = start
    return string[start_index:start_index+min_len]",147
py_1700_data.csv,"def lengthOfLongestSubstring(s):
    if len(s) == 0:
        return 0
    left = 0
    right = 0
    ans = 1
    visited = set()
    while right < len(s):
        if s[right] not in visited:
            visited.add(s[right])
            right += 1
            ans = max(ans, len(visited))
        else:
            visited.remove(s[left])
            left += 1
    return ans","Given string s, find length longest substring without repeating characters.",3,"def lengthOfLongestSubstring(s):
    if len(s) == 0:
        return 0
    left = 0
    right = 0
    ans = 1
    visited = set()
    while right < len(s):
        if s[right] not in visited:
            visited.add(s[right])
            right += 1
            ans = max(ans, len(visited))
        else:
            visited.remove(s[left])
            left += 1
    return ans",148
py_good_answer.csv,"def lengthOfLinkedList(head):
    count = 0
    while head:
        count += 1
        head = head.next
    return count",Python Program Find Length Linked List without using Recursion,3,"def lengthOfLinkedList(head):
    count = 0
    while head:
        count += 1
        head = head.next
    return count",149
py_1700_data.csv,"class Solution:
    def isValidSerialization(self, preorder: str) -> bool:
        stack = []
        for val in preorder.split(','):
            stack.append(val)
            while len(stack) > 2 and stack[-2:] == ['#', '#'] and stack[-3] != '#':
                stack.pop()
                stack.pop()
                stack[-1] = '#'
        return len(stack) == 1 and stack.pop() == '#'","One way serialize binary tree use preorder traversal. encounter non-null node, record node's value. null node, record using sentinel value '#'. example, binary tree serialized string ""9,3,4,#,#,1,#,#,2,#,6,#,#"", '#' represents null node. Given string comma-separated values preorder, return true correct preorder traversal serialization binary tree. guaranteed comma-separated value string must either integer character '#' representing null pointer. may assume input format always valid. example, could never contain two consecutive commas, ""1,,3"". Note: allowed reconstruct tree.",3,"class Solution:
    def isValidSerialization(self, preorder: str) -> bool:
        stack = []
        for val in preorder.split(','):
            stack.append(val)
            while len(stack) > 2 and stack[-2:] == ['
                stack.pop()
                stack.pop()
                stack[-1] = '
        return len(stack) == 1 and stack.pop() == '",150
py_good_answer.csv,"
class Rectangle:
    def __init__(self, length, width):
        self.length = length
        self.width = width

    def compute_area(self):
        return self.length * self.width
",rite Python class named Rectangle constructed length width method compute area rectangle.,0,"class Rectangle:
    def __init__(self, length, width):
        self.length = length
        self.width = width
    def compute_area(self):
        return self.length * self.width
",151
py_1700_data.csv,"def maxSumBST(root: TreeNode) -> int:
    max_sum = 0

    def dfs(node: TreeNode) -> Tuple[bool, int, int, int]:
        nonlocal max_sum
        if not node:
            return True, float(""inf""), float(""-inf""), 0
        l_flag, l_min, l_max, l_sum = dfs(node.left)
        r_flag, r_min, r_max, r_sum = dfs(node.right)

        if l_flag and r_flag and l_max < node.val < r_min:
            curr_sum = l_sum + r_sum + node.val
            max_sum = max(max_sum, curr_sum)
            return True, min(l_min, node.val), max(r_max, node.val), curr_sum

        return False, None, None, None

    dfs(root)
    return max_sum","Given binary tree root, return maximum sum keys sub-tree also Binary Search Tree (BST). Assume BST defined follows: left subtree node contains nodes keys less node's key. right subtree node contains nodes keys greater node's key. left right subtrees must also binary search trees.",0,"def maxSumBST(root: TreeNode) -> int:
    max_sum = 0
    def dfs(node: TreeNode) -> Tuple[bool, int, int, int]:
        nonlocal max_sum
        if not node:
            return True, float(""inf""), float(""-inf""), 0
        l_flag, l_min, l_max, l_sum = dfs(node.left)
        r_flag, r_min, r_max, r_sum = dfs(node.right)
        if l_flag and r_flag and l_max < node.val < r_min:
            curr_sum = l_sum + r_sum + node.val
            max_sum = max(max_sum, curr_sum)
            return True, min(l_min, node.val), max(r_max, node.val), curr_sum
        return False, None, None, None
    dfs(root)
    return max_sum",152
py_1700_data.csv,"
def generate_string(b):
    a_count = 3*b - 2
    b_count = b
    string = 'a'*a_count + 'b'*b_count
    if 'aaa' not in string:
        string = string[:a_count-2] + 'aaa' + string[a_count:]
    if 'bbb' not in string:
        string = string[:b_count-2] + 'bbb' + string[b_count:]
    return string
","Given two integers b, return string that: length + b contains exactly 'a' letters, exactly b 'b' letters, substring 'aaa' occur s, substring 'bbb' occur s.",0,"def generate_string(b):
    a_count = 3*b - 2
    b_count = b
    string = 'a'*a_count + 'b'*b_count
    if 'aaa' not in string:
        string = string[:a_count-2] + 'aaa' + string[a_count:]
    if 'bbb' not in string:
        string = string[:b_count-2] + 'bbb' + string[b_count:]
    return string
",153
py_good_answer.csv,"from random import randint

def generate_binary_string(length):
    binary_string = """"
    for i in range(length):
        binary_string += str(randint(0, 1))
    return binary_string

print(generate_binary_string(10)) # Example output: 1010010011",Write Python Program Generate Random binary string,0,"from random import randint
def generate_binary_string(length):
    binary_string = """"
    for i in range(length):
        binary_string += str(randint(0, 1))
    return binary_string
print(generate_binary_string(10)) ",154
py_1700_data.csv,"def is_crossing(distance):
    x = 0
    y = 0
    direction = 0
    for i in range(len(distance)):
        # move in direction
        if direction == 0:
            y += distance[i]
        elif direction == 1:
            x -= distance[i]
        elif direction == 2:
            y -= distance[i]
        elif direction == 3:
            x += distance[i]
        # update direction
        direction = (direction + 1) % 4
        # check if crossed path
        if direction == 0 and (x != 0 or y != 0):
            return True
    return False","given array integers distance. start point (0, 0) X-Y plane, move distance[0] meters north, distance[1] meters west, distance[2] meters south, distance[3] meters east, on. words, move, direction changes counter-clockwise. Return true path crosses false not.",2,"def is_crossing(distance):
    x = 0
    y = 0
    direction = 0
    for i in range(len(distance)):
        if direction == 0:
            y += distance[i]
        elif direction == 1:
            x -= distance[i]
        elif direction == 2:
            y -= distance[i]
        elif direction == 3:
            x += distance[i]
        direction = (direction + 1) % 4
        if direction == 0 and (x != 0 or y != 0):
            return True
    return False",155
py_1700_data.csv,"MOD = 10**9 + 7

class Solution:
    def countPaths(self, grid: List[List[int]]) -> int:
        n = len(grid)
        m = len(grid[0])
        dp = [[0] * m for _ in range(n)]
        dp[0][0] = 1
        for i in range(n):
            for j in range(m):
                for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]:
                    x, y = i + dx, j + dy
                    if 0 <= x < n and 0 <= y < m and grid[x][y] < grid[i][j]:
                        dp[i][j] = (dp[i][j] + dp[x][y]) % MOD
        return dp[n-1][m-1]","given x n integer matrix grid, move cell adjacent cell 4 directions. Return number strictly increasing paths grid start cell end cell. Since answer may large, return modulo 109 + 7. Two paths considered different exactly sequence visited cells.",1,"MOD = 10**9 + 7
class Solution:
    def countPaths(self, grid: List[List[int]]) -> int:
        n = len(grid)
        m = len(grid[0])
        dp = [[0] * m for _ in range(n)]
        dp[0][0] = 1
        for i in range(n):
            for j in range(m):
                for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]:
                    x, y = i + dx, j + dy
                    if 0 <= x < n and 0 <= y < m and grid[x][y] < grid[i][j]:
                        dp[i][j] = (dp[i][j] + dp[x][y]) % MOD
        return dp[n-1][m-1]",156
py_1700_data.csv,"def postorderTraversal(root):
    res = []
    def traversal(node):
        if node:
            traversal(node.left)
            traversal(node.right)
            res.append(node.val)
    traversal(root)
    return res","Given root binary tree, return postorder traversal nodes' values.",0,"def postorderTraversal(root):
    res = []
    def traversal(node):
        if node:
            traversal(node.left)
            traversal(node.right)
            res.append(node.val)
    traversal(root)
    return res",157
py_1700_data.csv,"def maxCandies(candies: List[int], k: int) -> int:
    def check(x):
        total = 0
        for candy in candies:
            total += candy // x
            if total >= k:
                return True
        return False
    
    l, r = 1, sum(candies)
    while l < r:
        mid = (l+r+1) // 2
        if check(mid):
            l = mid
        else:
            r = mid - 1
            
    return l * k","given 0-indexed integer array candies. element array denotes pile candies size candies[i]. divide pile number sub piles, cannot merge two piles together. also given integer k. allocate piles candies k children child gets number candies. child take one pile candies piles candies may go unused. Return maximum number candies child get.",0,"def maxCandies(candies: List[int], k: int) -> int:
    def check(x):
        total = 0
        for candy in candies:
            total += candy // x
            if total >= k:
                return True
        return False
    l, r = 1, sum(candies)
    while l < r:
        mid = (l+r+1) // 2
        if check(mid):
            l = mid
        else:
            r = mid - 1
    return l * k",158
py_1700_data.csv,"
def numberOfSubarrays(nums, k):
    odd_count = 0
    count = 0
    freq = {0: 1}
    for num in nums:
        if num % 2 == 1:
            odd_count += 1
        if odd_count >= k:
            count += freq[odd_count - k]
        freq[odd_count] = freq.get(odd_count, 0) + 1
    return count
",Given array integers nums integer k. continuous subarray called nice k odd numbers it. Return number nice sub-arrays.,3,"def numberOfSubarrays(nums, k):
    odd_count = 0
    count = 0
    freq = {0: 1}
    for num in nums:
        if num % 2 == 1:
            odd_count += 1
        if odd_count >= k:
            count += freq[odd_count - k]
        freq[odd_count] = freq.get(odd_count, 0) + 1
    return count
",159
py_1700_data.csv,"def reconstruct_sentence(shuffled):
    original = [''] * len(shuffled)
    for word in shuffled.split():
        index = int(word[-1]) - 1
        original[index] = word[:-1]
    return ' '.join(original)","sentence list words separated single space leading trailing spaces. word consists lowercase uppercase English letters. sentence shuffled appending 1-indexed word position word rearranging words sentence. example, sentence ""This sentence"" shuffled ""sentence4 a3 is2 This1"" ""is2 sentence4 This1 a3"". Given shuffled sentence containing 9 words, reconstruct return original sentence.",0,"def reconstruct_sentence(shuffled):
    original = [''] * len(shuffled)
    for word in shuffled.split():
        index = int(word[-1]) - 1
        original[index] = word[:-1]
    return ' '.join(original)",160
py_1700_data.csv,"class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        left, right = max(weights), sum(weights)
        
        while left < right:
            mid = (left + right) // 2
            curr_weight = 0
            needed_days = 1
            
            for weight in weights:
                if curr_weight + weight > mid:
                    needed_days += 1
                    curr_weight = 0
                curr_weight += weight
            
            if needed_days <= days:
                right = mid
            else:
                left = mid + 1
                
        return left","conveyor belt packages must shipped one port another within days days. ith package conveyor belt weight weights[i]. day, load ship packages conveyor belt (in order given weights). may load weight maximum weight capacity ship. Return least weight capacity ship result packages conveyor belt shipped within days days.",3,"class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        left, right = max(weights), sum(weights)
        while left < right:
            mid = (left + right) // 2
            curr_weight = 0
            needed_days = 1
            for weight in weights:
                if curr_weight + weight > mid:
                    needed_days += 1
                    curr_weight = 0
                curr_weight += weight
            if needed_days <= days:
                right = mid
            else:
                left = mid + 1
        return left",161
py_1700_data.csv,"
from itertools import zip_longest

def longest_happy_string(a, b, c):
    chars = {'a':a, 'b':b, 'c':c}
    s = ''
    while True:
        temp = ''
        for k, v in sorted(chars.items(), key=lambda x: x[1], reverse=True):
            if v > 0 and (not s or s[-1] != k or (len(s) > 1 and s[-2] != k)):
                temp += k
                chars[k] -= 1
        if not temp:
            break
        s += temp
    return s
","string called happy satisfies following conditions: contains letters 'a', 'b', 'c'. contain ""aaa"", ""bbb"", ""ccc"" substring. contains occurrences letter 'a'. contains b occurrences letter 'b'. contains c occurrences letter 'c'. Given three integers a, b, c, return longest possible happy string. multiple longest happy strings, return them. string, return empty string """". substring contiguous sequence characters within string.",0,"from itertools import zip_longest
def longest_happy_string(a, b, c):
    chars = {'a':a, 'b':b, 'c':c}
    s = ''
    while True:
        temp = ''
        for k, v in sorted(chars.items(), key=lambda x: x[1], reverse=True):
            if v > 0 and (not s or s[-1] != k or (len(s) > 1 and s[-2] != k)):
                temp += k
                chars[k] -= 1
        if not temp:
            break
        s += temp
    return s
",162
py_good_answer.csv,"
def matrix_chain_order(p):
    n = len(p) - 1

    m = [[-1 for _ in range(n)] for _ in range(n)]
    s = [[-1 for _ in range(n)] for _ in range(n)]

    for i in range(n):
        m[i][i] = 0

    for l in range(2, n + 1):
        for i in range(n - l + 1):
            j = i + l - 1
            m[i][j] = float('inf')
            for k in range(i, j):
                q = m[i][k] + m[k+1][j] + p[i] * p[k+1] * p[j+1]
                if q < m[i][j]:
                    m[i][j] = q
                    s[i][j] = k

    return m, s

def print_optimal_parens(s, i, j):
    if i == j:
        print(f'A{i}', end='')
    else:
        print('(', end='')
        print_optimal_parens(s, i, s[i][j])
        print_optimal_parens(s, s[i][j] + 1, j)
        print(')', end='')

p = [30, 35, 15, 5, 10, 20, 25]
m, s = matrix_chain_order(p)
print_optimal_parens(s, 0, len(p)-2)
",Python Program Solve Matrix-Chain Multiplication using Dynamic Programming Bottom-Up Approach,0,"def matrix_chain_order(p):
    n = len(p) - 1
    m = [[-1 for _ in range(n)] for _ in range(n)]
    s = [[-1 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        m[i][i] = 0
    for l in range(2, n + 1):
        for i in range(n - l + 1):
            j = i + l - 1
            m[i][j] = float('inf')
            for k in range(i, j):
                q = m[i][k] + m[k+1][j] + p[i] * p[k+1] * p[j+1]
                if q < m[i][j]:
                    m[i][j] = q
                    s[i][j] = k
    return m, s
def print_optimal_parens(s, i, j):
    if i == j:
        print(f'A{i}', end='')
    else:
        print('(', end='')
        print_optimal_parens(s, i, s[i][j])
        print_optimal_parens(s, s[i][j] + 1, j)
        print(')', end='')
p = [30, 35, 15, 5, 10, 20, 25]
m, s = matrix_chain_order(p)
print_optimal_parens(s, 0, len(p)-2)
",163
py_good_answer.csv,"tuples_lst = [(15, 2, 3), (300, 100, 200), (1000, 99, 55), (25, 10, 5), (853, 732, 245)]

def total_digits(tup):
    return sum(len(str(i)) for i in tup)

sorted_tuples = sorted(tuples_lst, key=total_digits)

print(sorted_tuples)",Write Python program Sort Tuples Total digits,3,"tuples_lst = [(15, 2, 3), (300, 100, 200), (1000, 99, 55), (25, 10, 5), (853, 732, 245)]
def total_digits(tup):
    return sum(len(str(i)) for i in tup)
sorted_tuples = sorted(tuples_lst, key=total_digits)
print(sorted_tuples)",164
py_1700_data.csv,"def carFleet(target: int, position: List[int], speed: List[int]) -> int:
    cars = sorted(zip(position, speed))
    time = [(target - p) / s for p, s in cars]
    fleet = 0
    while len(time) > 1:
        lead = time.pop()
        if lead < time[-1]:
            fleet += 1
        else:
            time[-1] = lead
    return fleet + bool(time)","n cars going destination along one-lane road. destination target miles away. given two integer array position speed, length n, position[i] position ith car speed[i] speed ith car (in miles per hour). car never pass another car ahead it, catch drive bumper bumper speed. faster car slow match slower car's speed. distance two cars ignored (i.e., assumed position). car fleet non-empty set cars driving position speed. Note single car also car fleet. car catches car fleet right destination point, still considered one car fleet. Return number car fleets arrive destination.",3,"def carFleet(target: int, position: List[int], speed: List[int]) -> int:
    cars = sorted(zip(position, speed))
    time = [(target - p) / s for p, s in cars]
    fleet = 0
    while len(time) > 1:
        lead = time.pop()
        if lead < time[-1]:
            fleet += 1
        else:
            time[-1] = lead
    return fleet + bool(time)",165
py_good_answer.csv,"def reverse_string_recursion(s):
    if len(s) == 0:
        return s
    else:
        return reverse_string_recursion(s[1:]) + s[0]",Python Program Reverse String Using Recursion,3,"def reverse_string_recursion(s):
    if len(s) == 0:
        return s
    else:
        return reverse_string_recursion(s[1:]) + s[0]",166
py_1700_data.csv,"class Solution:
    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        graph = [[] for _ in range(numCourses)]
        for p in prerequisites:
            graph[p[0]].append(p[1])
        
        def dfs(u, v):
            if u == v:
                return True
            visited[u] = True
            for nei in graph[u]:
                if not visited[nei] and dfs(nei, v):
                    return True
            return False
        
        res = []
        for q in queries:
            visited = [False] * numCourses
            res.append(dfs(q[0], q[1]))
        return res","total numCourses courses take, labeled 0 numCourses - 1. given array prerequisites prerequisites[i] = [ai, bi] indicates must take course ai first want take course bi. example, pair [0, 1] indicates take course 0 take course 1. Prerequisites also indirect. course prerequisite course b, course b prerequisite course c, course prerequisite course c. also given array queries queries[j] = [uj, vj]. jth query, answer whether course uj prerequisite course vj not. Return boolean array answer, answer[j] answer jth query.",3,"class Solution:
    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        graph = [[] for _ in range(numCourses)]
        for p in prerequisites:
            graph[p[0]].append(p[1])
        def dfs(u, v):
            if u == v:
                return True
            visited[u] = True
            for nei in graph[u]:
                if not visited[nei] and dfs(nei, v):
                    return True
            return False
        res = []
        for q in queries:
            visited = [False] * numCourses
            res.append(dfs(q[0], q[1]))
        return res",167
py_1700_data.csv,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        max_profit = 0
        min_price = float('inf')
        for price in prices:
            if price < min_price:
                min_price = price
            elif price - min_price > max_profit:
                max_profit = price - min_price
        return max_profit","given array prices prices[i] price given stock ith day. want maximize profit choosing single day buy one stock choosing different day future sell stock. Return maximum profit achieve transaction. cannot achieve profit, return 0.",3,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        max_profit = 0
        min_price = float('inf')
        for price in prices:
            if price < min_price:
                min_price = price
            elif price - min_price > max_profit:
                max_profit = price - min_price
        return max_profit",168
py_1700_data.csv,"class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
        if maxChoosableInteger >= desiredTotal:
            return True
        if (1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal:
            return False
        memo = {}

        def dfs(used, total):
            if used in memo:
                return memo[used]
            if total >= desiredTotal:
                return False
            for i in range(maxChoosableInteger):
                cur = 1 << i
                if cur & used == 0:
                    if not dfs(used | cur, total + i + 1):
                        memo[used] = True
                        return True
            memo[used] = False
            return False

        return dfs(0, 0)","""100 game"" two players take turns adding, running total, integer 1 10. player first causes running total reach exceed 100 wins. change game players cannot re-use integers? example, two players might take turns drawing common pool numbers 1 15 without replacement reach total >= 100. Given two integers maxChoosableInteger desiredTotal, return true first player move force win, otherwise, return false. Assume players play optimally.",3,"class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
        if maxChoosableInteger >= desiredTotal:
            return True
        if (1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal:
            return False
        memo = {}
        def dfs(used, total):
            if used in memo:
                return memo[used]
            if total >= desiredTotal:
                return False
            for i in range(maxChoosableInteger):
                cur = 1 << i
                if cur & used == 0:
                    if not dfs(used | cur, total + i + 1):
                        memo[used] = True
                        return True
            memo[used] = False
            return False
        return dfs(0, 0)",169
py_1700_data.csv,"def minimum_abs_difference(arr):
    arr.sort()
    diff = arr[-1]
    for i in range(len(arr) - 1):
        if arr[i+1] - arr[i] < diff:
            diff = arr[i+1] - arr[i]
    pairs = []
    for i in range(len(arr) - 1):
        if arr[i+1] - arr[i] == diff:
            pairs.append([arr[i], arr[i+1]])
    return pairs","Given array distinct integers arr, find pairs elements minimum absolute difference two elements. Return list pairs ascending order(with respect pairs), pair [a, b] follows a, b arr < b b - equals minimum absolute difference two elements arr",3,"def minimum_abs_difference(arr):
    arr.sort()
    diff = arr[-1]
    for i in range(len(arr) - 1):
        if arr[i+1] - arr[i] < diff:
            diff = arr[i+1] - arr[i]
    pairs = []
    for i in range(len(arr) - 1):
        if arr[i+1] - arr[i] == diff:
            pairs.append([arr[i], arr[i+1]])
    return pairs",170
py_good_answer.csv,"def longest(iterables):
    return max(iterables, key=len)",Write Python program takes number iterable objects objects length property returns longest one.,0,"def longest(iterables):
    return max(iterables, key=len)",171
py_1700_data.csv,"def is_strictly_palindromic(n):
    for b in range(2, n):
        num_in_base_b = ''
        num = n
        while num > 0:
            num_in_base_b += str(num % b)
            num //= b
        if num_in_base_b != num_in_base_b[::-1]:
            return False
    return True","integer n strictly palindromic if, every base b 2 n - 2 (inclusive), string representation integer n base b palindromic. Given integer n, return true n strictly palindromic false otherwise. string palindromic reads forward backward.",3,"def is_strictly_palindromic(n):
    for b in range(2, n):
        num_in_base_b = ''
        num = n
        while num > 0:
            num_in_base_b += str(num % b)
            num //= b
        if num_in_base_b != num_in_base_b[::-1]:
            return False
    return True",172
py_1700_data.csv,"def maxCoins(nums):
    nums = [1] + nums + [1]
    n = len(nums)
    dp = [[0] * n for _ in range(n)]
    for k in range(2, n):
        for left in range(0, n - k):
            right = left + k
            for i in range(left + 1, right):
                dp[left][right] = max(dp[left][right], 
                                      nums[left]*nums[i]*nums[right] + dp[left][i] + dp[i][right])
    return dp[0][n-1]","given n balloons, indexed 0 n - 1. balloon painted number represented array nums. asked burst balloons. burst ith balloon, get nums[i - 1] * nums[i] * nums[i + 1] coins. - 1 + 1 goes bounds array, treat balloon 1 painted it. Return maximum coins collect bursting balloons wisely.",3,"def maxCoins(nums):
    nums = [1] + nums + [1]
    n = len(nums)
    dp = [[0] * n for _ in range(n)]
    for k in range(2, n):
        for left in range(0, n - k):
            right = left + k
            for i in range(left + 1, right):
                dp[left][right] = max(dp[left][right], 
                                      nums[left]*nums[i]*nums[right] + dp[left][i] + dp[i][right])
    return dp[0][n-1]",173
py_1700_data.csv,"def firstNonRepeatingChar(s):
    charCount = {}
    for char in s:
        if char in charCount:
            charCount[char] += 1
        else:
            charCount[char] = 1
    for i in range(len(s)):
        if charCount[s[i]] == 1:
            return i
    return -1","Given string s, find first non-repeating character return index. exist, return -1.",3,"def firstNonRepeatingChar(s):
    charCount = {}
    for char in s:
        if char in charCount:
            charCount[char] += 1
        else:
            charCount[char] = 1
    for i in range(len(s)):
        if charCount[s[i]] == 1:
            return i
    return -1",174
py_1700_data.csv,"def countTriplets(nums: List[int], diff: int) -> int:
    count = 0
    dict1, dict2 = defaultdict(int), defaultdict(int)
    for i in nums:
        count += dict2[i]
        dict2[i+diff] += dict1[i]
        dict1[i+diff] += 1
    return count","given 0-indexed, strictly increasing integer array nums positive integer diff. triplet (i, j, k) arithmetic triplet following conditions met: < j < k, nums[j] - nums[i] == diff, nums[k] - nums[j] == diff. Return number unique arithmetic triplets.",3,"def countTriplets(nums: List[int], diff: int) -> int:
    count = 0
    dict1, dict2 = defaultdict(int), defaultdict(int)
    for i in nums:
        count += dict2[i]
        dict2[i+diff] += dict1[i]
        dict1[i+diff] += 1
    return count",175
py_good_answer.csv,"
import types

def not_func(func):
    if isinstance(func, types.FunctionType) or isinstance(func, types.LambdaType):
        return not func()
    else:
        return ""Input is not a function""
","Write Python program check function user-defined function not. Use types.FunctionType, types.LambdaType()",0,"import types
def not_func(func):
    if isinstance(func, types.FunctionType) or isinstance(func, types.LambdaType):
        return not func()
    else:
        return ""Input is not a function""
",176
py_1700_data.csv,"def alice_wins(n):
    # Alice starts first
    alice_turn = True
    
    while True:
        # Alice's turn
        if alice_turn:
            for x in range(1, n):
                if n % x == 0:
                    n -= x
                    alice_turn = False
                    break
        # Bob's turn
        else:
            can_make_move = False
            for x in range(1, n):
                if n % x == 0:
                    n -= x
                    alice_turn = True
                    can_make_move = True
                    break
            # If Bob cannot make a move, Alice wins
            if not can_make_move:
                return True
            
        # If n <= 0, Bob wins
        if n <= 0:
            return False","Alice Bob take turns playing game, Alice starting first. Initially, number n chalkboard. player's turn, player makes move consisting of: Choosing x 0 < x < n n % x == 0. Replacing number n chalkboard n - x. Also, player cannot make move, lose game. Return true Alice wins game, assuming players play optimally.",0,"def alice_wins(n):
    alice_turn = True
    while True:
        if alice_turn:
            for x in range(1, n):
                if n % x == 0:
                    n -= x
                    alice_turn = False
                    break
        else:
            can_make_move = False
            for x in range(1, n):
                if n % x == 0:
                    n -= x
                    alice_turn = True
                    can_make_move = True
                    break
            if not can_make_move:
                return True
        if n <= 0:
            return False",177
py_1700_data.csv,"def longest_palindrome(words):
    palindromes = set()
    for word in words:
        if word[::-1] in palindromes:
            palindromes.remove(word[::-1])
        else:
            palindromes.add(word)
    result = """"
    for palindrome in sorted(palindromes):
        result += palindrome
    if result == result[::-1]:
        return len(result)
    else:
        return 0","given array strings words. element words consists two lowercase English letters. Create longest possible palindrome selecting elements words concatenating order. element selected once. Return length longest palindrome create. impossible create palindrome, return 0. palindrome string reads forward backward.",0,"def longest_palindrome(words):
    palindromes = set()
    for word in words:
        if word[::-1] in palindromes:
            palindromes.remove(word[::-1])
        else:
            palindromes.add(word)
    result = """"
    for palindrome in sorted(palindromes):
        result += palindrome
    if result == result[::-1]:
        return len(result)
    else:
        return 0",178
py_1700_data.csv,"def check_numbers(sentence):
    tokens = sentence.strip().split()
    prev_num = -1
    for token in tokens:
        if token.isdigit():
            num = int(token)
            if num <= prev_num:
                return False
            prev_num = num
    return True","sentence list tokens separated single space leading trailing spaces. Every token either positive number consisting digits 0-9 leading zeros, word consisting lowercase English letters. example, ""a puppy 2 eyes 4 legs"" sentence seven tokens: ""2"" ""4"" numbers tokens ""puppy"" words. Given string representing sentence, need check numbers strictly increasing left right (i.e., last number, number strictly smaller number right s). Return true so, false otherwise.",3,"def check_numbers(sentence):
    tokens = sentence.strip().split()
    prev_num = -1
    for token in tokens:
        if token.isdigit():
            num = int(token)
            if num <= prev_num:
                return False
            prev_num = num
    return True",179
py_good_answer.csv,"def maxSubArray(numbers):
    max_sum = current_sum = numbers[0]
    for num in numbers[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum

# example usage
numbers = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(maxSubArray(numbers))",Python Program solve Maximum Subarray Problem using KadaneÃÂÃÂÃÂÃÂs Algorithm,3,"def maxSubArray(numbers):
    max_sum = current_sum = numbers[0]
    for num in numbers[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum
numbers = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(maxSubArray(numbers))",180
py_1700_data.csv,"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        intervals.sort(key=lambda x: x[1])
        end = intervals[0][1]
        count = 1
        for i in range(1, len(intervals)):
            if intervals[i][0] >= end:
                end = intervals[i][1]
                count += 1
        return len(intervals) - count","Given array intervals intervals intervals[i] = [starti, endi], return minimum number intervals need remove make rest intervals non-overlapping.",3,"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        intervals.sort(key=lambda x: x[1])
        end = intervals[0][1]
        count = 1
        for i in range(1, len(intervals)):
            if intervals[i][0] >= end:
                end = intervals[i][1]
                count += 1
        return len(intervals) - count",181
py_70_data.csv,"def is_palindrome(number):
    return str(number) == str(number)[::-1]
    
def recursive_palindrome(number):
    if len(str(number)) == 1:
        return True
    elif len(str(number)) == 2:
        return str(number)[0] == str(number)[1]
    else:
        return str(number)[0] == str(number)[-1] and recursive_palindrome(str(number)[1:-1])
    
number = int(input(""Enter a number to check if it's a palindrome: ""))
if recursive_palindrome(number):
    print(f""{number} is a palindrome."")
else:
    print(f""{number} is not a palindrome."")",Write program Python check whether number palindrome using recursive method.,3,"def is_palindrome(number):
    return str(number) == str(number)[::-1]
def recursive_palindrome(number):
    if len(str(number)) == 1:
        return True
    elif len(str(number)) == 2:
        return str(number)[0] == str(number)[1]
    else:
        return str(number)[0] == str(number)[-1] and recursive_palindrome(str(number)[1:-1])
number = int(input(""Enter a number to check if it's a palindrome: ""))
if recursive_palindrome(number):
    print(f""{number} is a palindrome."")
else:
    print(f""{number} is not a palindrome."")",182
py_good_answer.csv,"import math

def arc_length(radius, angle):
    return (angle/360) * 2 * math.pi * radius

# test
print(arc_length(5, 90)) #expected output: 7.853981633974483",Write Python program calculate arc length angle.,0,"import math
def arc_length(radius, angle):
    return (angle/360) * 2 * math.pi * radius
print(arc_length(5, 90)) ",183
py_1700_data.csv,"def num_subarrays(nums: List[int], k: int) -> int:
    def score(arr):
        return sum(arr) * len(arr)
    
    count = 0
    for i in range(len(nums)):
        for j in range(i+1, len(nums)+1):
            if score(nums[i:j]) < k:
                count += 1
                
    return count","score array defined product sum length. example, score [1, 2, 3, 4, 5] (1 + 2 + 3 + 4 + 5) * 5 = 75. Given positive integer array nums integer k, return number non-empty subarrays nums whose score strictly less k. subarray contiguous sequence elements within array.",3,"def num_subarrays(nums: List[int], k: int) -> int:
    def score(arr):
        return sum(arr) * len(arr)
    count = 0
    for i in range(len(nums)):
        for j in range(i+1, len(nums)+1):
            if score(nums[i:j]) < k:
                count += 1
    return count",184
py_good_answer.csv,"def kth_column_product_tuple_list(lst, k):
    res = []
    for i in range(len(lst[0])):
        col = [row[i] for row in lst]
        if i == k:
            product = 1
            for num in col:
                product *= num
            res.append(product)
    return tuple(res)",Write Python program Kth Column Product Tuple List,3,"def kth_column_product_tuple_list(lst, k):
    res = []
    for i in range(len(lst[0])):
        col = [row[i] for row in lst]
        if i == k:
            product = 1
            for num in col:
                product *= num
            res.append(product)
    return tuple(res)",185
py_1700_data.csv,"def remove_node(root):
    result = []
    
    def traverse(node):
        if node is None:
            return False
        
        left = traverse(node.left)
        right = traverse(node.right)
        
        if left or right:
            node.left = None
            node.right = None
            result.append(node)
            return True
        
        if node.val == 1:
            if node.left is not None:
                result.append(node.left)
            if node.right is not None:
                result.append(node.right)
            return True
        
        return False
    
    traverse(root)
    if root.val != 1:
        result.append(root)
    return result","Given root binary tree, return tree every subtree (of given tree) containing 1 removed. subtree node node node plus every node descendant node.",0,"def remove_node(root):
    result = []
    def traverse(node):
        if node is None:
            return False
        left = traverse(node.left)
        right = traverse(node.right)
        if left or right:
            node.left = None
            node.right = None
            result.append(node)
            return True
        if node.val == 1:
            if node.left is not None:
                result.append(node.left)
            if node.right is not None:
                result.append(node.right)
            return True
        return False
    traverse(root)
    if root.val != 1:
        result.append(root)
    return result",186
py_good_answer.csv,"class Stack:
    def __init__(self):
        self.queue1 = []
        self.queue2 = []
        
    def push(self, value):
        self.queue1.append(value)

    def pop(self):
        if not self.queue1:
            return None
        while len(self.queue1) > 1:
            self.queue2.append(self.queue1.pop(0))
        value = self.queue1.pop(0)
        self.queue1 = self.queue2
        self.queue2 = []
        return value",Python Program Implement Stack Using Two Queues,0,"class Stack:
    def __init__(self):
        self.queue1 = []
        self.queue2 = []
    def push(self, value):
        self.queue1.append(value)
    def pop(self):
        if not self.queue1:
            return None
        while len(self.queue1) > 1:
            self.queue2.append(self.queue1.pop(0))
        value = self.queue1.pop(0)
        self.queue1 = self.queue2
        self.queue2 = []
        return value",187
py_good_answer.csv,"
from collections import Counter

def get_frequency(lists):
    flat_list = [item for sublist in lists for item in sublist]
    count = Counter(flat_list)
    return dict(count)
",Write Python program get frequency elements given list lists.,3,"from collections import Counter
def get_frequency(lists):
    flat_list = [item for sublist in lists for item in sublist]
    count = Counter(flat_list)
    return dict(count)
",188
py_1700_data.csv,"
from itertools import combinations

def generate_lists(n, k):
    possible_lists = []
    for combo in combinations(range(1, n+1), n):
        diffs = [abs(combo[i+1] - combo[i]) for i in range(n-1)]
        if len(set(diffs)) == k:
            possible_lists.append(combo)
    return possible_lists
","Given two integers n k, construct list answer contains n different positive integers ranging 1 n obeys following requirement: Suppose list answer = [a1, a2, a3, ... , an], list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] exactly k distinct integers. Return list answer. multiple valid answers, return them.",0,"from itertools import combinations
def generate_lists(n, k):
    possible_lists = []
    for combo in combinations(range(1, n+1), n):
        diffs = [abs(combo[i+1] - combo[i]) for i in range(n-1)]
        if len(set(diffs)) == k:
            possible_lists.append(combo)
    return possible_lists
",189
py_1700_data.csv,"def largestSquareSubgrid(grid):
    n, m = len(grid), len(grid[0])
    dp = [[0 for _ in range(m)] for _ in range(n)]
    max_size = 0
    
    for i in range(n):
        for j in range(m):
            if i == 0 or j == 0 or i == n-1 or j == m-1 or grid[i][j] == 0:
                dp[i][j] = grid[i][j]
            else:
                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
            max_size = max(max_size, dp[i][j])
    
    return max_size","Given 2D grid 0s 1s, return number elements largest square subgrid 1s border, 0 subgrid exist grid.",1,"def largestSquareSubgrid(grid):
    n, m = len(grid), len(grid[0])
    dp = [[0 for _ in range(m)] for _ in range(n)]
    max_size = 0
    for i in range(n):
        for j in range(m):
            if i == 0 or j == 0 or i == n-1 or j == m-1 or grid[i][j] == 0:
                dp[i][j] = grid[i][j]
            else:
                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
            max_size = max(max_size, dp[i][j])
    return max_size",190
py_good_answer.csv,"def exists_once(list1, list2, func):
    """"""Returns a list of elements that exist in both list1 and list2 only once
    after applying the provided function to each element""""""
    
    count1 = {}
    count2 = {}
    result = []
    
    for elem in list1:
        if elem not in count1:
            count1[elem] = 1
        else:
            count1[elem] += 1
    
    for elem in list2:
        if elem not in count2:
            count2[elem] = 1
        else:
            count2[elem] += 1
    
    for elem in set(list1+list2):
        if elem in count1 and count1[elem] == 1 and elem in count2 and count2[elem] == 1:
            result.append(func(elem))
            
    return result","Write Python program get every element exists two given lists once, applying provided function element both.",0,"def exists_once(list1, list2, func):
    count1 = {}
    count2 = {}
    result = []
    for elem in list1:
        if elem not in count1:
            count1[elem] = 1
        else:
            count1[elem] += 1
    for elem in list2:
        if elem not in count2:
            count2[elem] = 1
        else:
            count2[elem] += 1
    for elem in set(list1+list2):
        if elem in count1 and count1[elem] == 1 and elem in count2 and count2[elem] == 1:
            result.append(func(elem))
    return result",191
py_1700_data.csv,"def strange_printer(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    
    for i in range(n-1, -1, -1):
        dp[i][i] = 1
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i][j-1]
            else:
                dp[i][j] = dp[i][j-1] + 1
                for k in range(i, j):
                    if s[k] == s[j]:
                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j-1])
    
    return dp[0][n-1]","strange printer following two special properties: printer print sequence character time. turn, printer print new characters starting ending place cover original existing characters. Given string s, return minimum number turns printer needed print it.",0,"def strange_printer(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n-1, -1, -1):
        dp[i][i] = 1
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i][j-1]
            else:
                dp[i][j] = dp[i][j-1] + 1
                for k in range(i, j):
                    if s[k] == s[j]:
                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j-1])
    return dp[0][n-1]",192
py_good_answer.csv,"class Python:
	count = 0
	def __init__(self):
		Python.count += 1

p1 = Python()
p2 = Python()
p3 = Python()

print(""Number of instances:"", Python.count)",count number instances class Python,3,"class Python:
	count = 0
	def __init__(self):
		Python.count += 1
p1 = Python()
p2 = Python()
p3 = Python()
print(""Number of instances:"", Python.count)",193
py_1700_data.csv,"def hamming_weight(n: int) -> int:
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count

print(hamming_weight(0b10101)) # Output: 3
print(hamming_weight(0b11111111111111111111111111111011)) # Output: 31
print(hamming_weight(0b11111111111111111111111111111101)) # Output: 31 (note: input represents -3)","Write function takes binary representation unsigned integer returns number '1' bits (also known Hamming weight). Note: Note languages, Java, unsigned integer type. case, input given signed integer type. affect implementation, integer's internal binary representation same, whether signed unsigned. Java, compiler represents signed integers using 2's complement notation. Therefore, Example 3, input represents signed integer. -3.",0,"def hamming_weight(n: int) -> int:
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count
print(hamming_weight(0b10101)) 
print(hamming_weight(0b11111111111111111111111111111011)) 
print(hamming_weight(0b11111111111111111111111111111101)) ",194
py_1700_data.csv,"def find_final_value(nums, original):
    while original in nums:
        original = 2 * original
    return original","given array integers nums. also given integer original first number needs searched nums. following steps: original found nums, multiply two (i.e., set original = 2 * original). Otherwise, stop process. Repeat process new number long keep finding number. Return final value original.",3,"def find_final_value(nums, original):
    while original in nums:
        original = 2 * original
    return original",195
py_1700_data.csv,"def count_numbers(digits, n):
    ans = 0
    for i in range(1, n+1):
        s = str(i)
        for digit in digits:
            s_count = s.count(digit)
            digit_count = digits.count(digit)
            if s_count > digit_count:
                break
            if digit == digits[-1]:
                ans += 1
    return ans","Given array digits sorted non-decreasing order. write numbers using digits[i] many times want. example, digits = ['1','3','5'], may write numbers '13', '551', '1351315'. Return number positive integers generated less equal given integer n.",1,"def count_numbers(digits, n):
    ans = 0
    for i in range(1, n+1):
        s = str(i)
        for digit in digits:
            s_count = s.count(digit)
            digit_count = digits.count(digit)
            if s_count > digit_count:
                break
            if digit == digits[-1]:
                ans += 1
    return ans",196
py_1700_data.csv,"
def max_points_gain(s: str, x: int, y: int, number: int) -> int:

    def remove_ab(s: str) -> Tuple[str, int]:
        points = 0
        while ""ab"" in s:
            s = s.replace(""ab"", """", 1)
            points += x
        return s, points

    def remove_ba(s: str) -> Tuple[str, int]:
        points = 0
        while ""ba"" in s:
            s = s.replace(""ba"", """", 1)
            points += y
        return s, points

    max_points = 0
    for i in range(number+1):
        s_temp = s
        points = 0
        for j in range(i):
            s_temp, p = remove_ab(s_temp)
            points += p
        for k in range(number-i):
            s_temp, p = remove_ba(s_temp)
            points += p
        max_points = max(max_points, points)
    return max_points
","given string two integers x y. perform two types operations number times. Remove substring ""ab"" gain x points. example, removing ""ab"" ""cabxbae"" becomes ""cxbae"". Remove substring ""ba"" gain points. example, removing ""ba"" ""cabxbae"" becomes ""cabxe"". Return maximum points gain applying operations s.",3,"def max_points_gain(s: str, x: int, y: int, number: int) -> int:
    def remove_ab(s: str) -> Tuple[str, int]:
        points = 0
        while ""ab"" in s:
            s = s.replace(""ab"", """", 1)
            points += x
        return s, points
    def remove_ba(s: str) -> Tuple[str, int]:
        points = 0
        while ""ba"" in s:
            s = s.replace(""ba"", """", 1)
            points += y
        return s, points
    max_points = 0
    for i in range(number+1):
        s_temp = s
        points = 0
        for j in range(i):
            s_temp, p = remove_ab(s_temp)
            points += p
        for k in range(number-i):
            s_temp, p = remove_ba(s_temp)
            points += p
        max_points = max(max_points, points)
    return max_points
",197
py_1700_data.csv,"MOD = 10**9 + 7

def min_wasted_space(packages, boxes):
    packages.sort()
    ans = float('inf')
    for b in boxes:
        b.sort()
        if b[-1] < packages[-1]:
            continue
        i = 0
        cur = 0
        for box in b:
            if i == len(packages):
                break
            if box >= packages[i]:
                cur += box - packages[i]
                i += 1
        if i == len(packages):
            ans = min(ans, cur)
    
    return ans % MOD if ans != float('inf') else -1","n packages trying place boxes, one package box. suppliers produce boxes different sizes (with infinite supply). package placed box size package less equal size box. package sizes given integer array packages, packages[i] size ith package. suppliers given 2D integer array boxes, boxes[j] array box sizes jth supplier produces. want choose single supplier use boxes total wasted space minimized. package box, define space wasted size box - size package. total wasted space sum space wasted boxes. example, fit packages sizes [2,3,5] supplier offers boxes sizes [4,8], fit packages size-2 size-3 two boxes size-4 package size-5 box size-8. would result waste (4-2) + (4-3) + (8-5) = 6. Return minimum total wasted space choosing box supplier optimally, -1 impossible fit packages inside boxes. Since answer may large, return modulo 109 + 7.",0,"MOD = 10**9 + 7
def min_wasted_space(packages, boxes):
    packages.sort()
    ans = float('inf')
    for b in boxes:
        b.sort()
        if b[-1] < packages[-1]:
            continue
        i = 0
        cur = 0
        for box in b:
            if i == len(packages):
                break
            if box >= packages[i]:
                cur += box - packages[i]
                i += 1
        if i == len(packages):
            ans = min(ans, cur)
    return ans % MOD if ans != float('inf') else -1",198
py_1700_data.csv,"
def deleteAndEarn(nums: List[int]) -> int:
    if not nums:
        return 0
    max_val = max(nums)
    freq = [0] * (max_val + 1)
    for num in nums:
        freq[num] += num
    prev, curr = 0, 0
    for i in range(max_val + 1):
        temp = max(curr, prev + freq[i])
        prev = curr
        curr = temp
    return curr
","given integer array nums. want maximize number points get performing following operation number times: Pick nums[i] delete earn nums[i] points. Afterwards, must delete every element equal nums[i] - 1 every element equal nums[i] + 1. Return maximum number points earn applying operation number times.",3,"def deleteAndEarn(nums: List[int]) -> int:
    if not nums:
        return 0
    max_val = max(nums)
    freq = [0] * (max_val + 1)
    for num in nums:
        freq[num] += num
    prev, curr = 0, 0
    for i in range(max_val + 1):
        temp = max(curr, prev + freq[i])
        prev = curr
        curr = temp
    return curr
",199
py_1700_data.csv,"class Solution:
    def nthMagicalNumber(self, n: int, a: int, b: int) -> int:
        def gcd(x, y):
            if y == 0:
                return x
            return gcd(y, x % y)

        def lcm(x, y):
            return x * y // gcd(x, y)

        mod = 10 ** 9 + 7
        l = lcm(a, b)
        left, right = 1, 10 ** 15
        while left < right:
            mid = (left + right) // 2
            count = mid // a + mid // b - mid // l
            if count < n:
                left = mid + 1
            else:
                right = mid

        return left % mod","positive integer magical divisible either b. Given three integers n, a, b, return nth magical number. Since answer may large, return modulo 109 + 7.",3,"class Solution:
    def nthMagicalNumber(self, n: int, a: int, b: int) -> int:
        def gcd(x, y):
            if y == 0:
                return x
            return gcd(y, x % y)
        def lcm(x, y):
            return x * y // gcd(x, y)
        mod = 10 ** 9 + 7
        l = lcm(a, b)
        left, right = 1, 10 ** 15
        while left < right:
            mid = (left + right) // 2
            count = mid // a + mid // b - mid // l
            if count < n:
                left = mid + 1
            else:
                right = mid
        return left % mod",200
py_1700_data.csv,"def numSubarrays(nums):
    count = 0
    result = 0
    for num in nums:
        if num == 0:
            count += 1
            result += count
        else:
            count = 0
    return result","Given integer array nums, return number subarrays filled 0. subarray contiguous non-empty sequence elements within array.",3,"def numSubarrays(nums):
    count = 0
    result = 0
    for num in nums:
        if num == 0:
            count += 1
            result += count
        else:
            count = 0
    return result",201
py_1700_data.csv,"def quarantine(isInfected):
    walls = 0
    m, n = len(isInfected), len(isInfected[0])
    
    def dfs(i, j):
        if i < 0 or j < 0 or i == m or j == n or isInfected[i][j] == 0:
            return
        
        isInfected[i][j] = 0
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)
    
    for i in range(m):
        for j in range(n):
            if isInfected[i][j] == 1:
                walls += 1
                dfs(i, j)
    
    return walls","virus spreading rapidly, task quarantine infected area installing walls. world modeled x n binary grid isInfected, isInfected[i][j] == 0 represents uninfected cells, isInfected[i][j] == 1 represents cells contaminated virus. wall (and one wall) installed two 4-directionally adjacent cells, shared boundary. Every night, virus spreads neighboring cells four directions unless blocked wall. Resources limited. day, install walls around one region (i.e., affected area (continuous block infected cells) threatens uninfected cells following night). never tie. Return number walls used quarantine infected regions. world become fully infected, return number walls used.",0,"def quarantine(isInfected):
    walls = 0
    m, n = len(isInfected), len(isInfected[0])
    def dfs(i, j):
        if i < 0 or j < 0 or i == m or j == n or isInfected[i][j] == 0:
            return
        isInfected[i][j] = 0
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)
    for i in range(m):
        for j in range(n):
            if isInfected[i][j] == 1:
                walls += 1
                dfs(i, j)
    return walls",202
py_1700_data.csv,"def find_second_greater(nums):
    n = len(nums)
    answer = [-1] * n
    stack = []
    for i in range(n):
        while stack and nums[i] > nums[stack[-1]]:
            idx = stack.pop()
            if stack and nums[i] > nums[stack[-1]]:
                answer[stack[-1]] = nums[i]
        stack.append(i)
    return answer","given 0-indexed array non-negative integers nums. integer nums, must find respective second greater integer. second greater integer nums[i] nums[j] that: j > nums[j] > nums[i] exists exactly one index k nums[k] > nums[i] < k < j. nums[j], second greater integer considered -1. example, array [1, 2, 4, 3], second greater integer 1 4, 2 3, 3 4 -1. Return integer array answer, answer[i] second greater integer nums[i].",0,"def find_second_greater(nums):
    n = len(nums)
    answer = [-1] * n
    stack = []
    for i in range(n):
        while stack and nums[i] > nums[stack[-1]]:
            idx = stack.pop()
            if stack and nums[i] > nums[stack[-1]]:
                answer[stack[-1]] = nums[i]
        stack.append(i)
    return answer",203
py_good_answer.csv,"def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]

    left = merge_sort(left)
    right = merge_sort(right)

    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result += left[i:]
    result += right[j:]

    return result",Merge Sort Program Python | Java | C | C++,0,"def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    left = merge_sort(left)
    right = merge_sort(right)
    return merge(left, right)
def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result += left[i:]
    result += right[j:]
    return result",204
py_1700_data.csv,"def find_pairs(nums, k):
    pairs = []
    for i in range(len(nums)):
        for j in range(i, len(nums)):
            if nums[i] * nums[j] % k == 0:
                pairs.append((i,j))
    return pairs","Given 0-indexed integer array nums length n integer k, return number pairs (i, j) that: 0 <= < j <= n - 1 nums[i] * nums[j] divisible k.",0,"def find_pairs(nums, k):
    pairs = []
    for i in range(len(nums)):
        for j in range(i, len(nums)):
            if nums[i] * nums[j] % k == 0:
                pairs.append((i,j))
    return pairs",205
py_1700_data.csv,"def minimumScore(nums: List[int], k: int) -> int:
    nums.sort()
    n = len(nums)
    res = nums[-1] - nums[0]
    
    for i in range(1, n):
        max_val = max(nums[i-1] + k, nums[-1] - k)
        min_val = min(nums[0] + k, nums[i] - k)
        res = min(res, max_val - min_val)
        
    return res","given integer array nums integer k. one operation, choose index 0 <= < nums.length change nums[i] nums[i] + x x integer range [-k, k]. apply operation index i. score nums difference maximum minimum elements nums. Return minimum score nums applying mentioned operation index it.",2,"def minimumScore(nums: List[int], k: int) -> int:
    nums.sort()
    n = len(nums)
    res = nums[-1] - nums[0]
    for i in range(1, n):
        max_val = max(nums[i-1] + k, nums[-1] - k)
        min_val = min(nums[0] + k, nums[i] - k)
        res = min(res, max_val - min_val)
    return res",206
py_good_answer.csv,"def calculate_frequency(tup):
    frequency = {}
    
    for i in tup:
        if type(i) == tuple:
            for j in i:
                if j in frequency:
                    frequency[j] += 1
                else:
                    frequency[j] = 1
        else:
            if i in frequency:
                frequency[i] += 1
            else:
                frequency[i] = 1
                
    return frequency

mixed_tuple = (1, 2, (3, 4), 4, (5, 6), 7, 8, (9, 10, 9))
frequency = calculate_frequency(mixed_tuple)
print(frequency)",Write Python program Elements Frequency Mixed Nested Tuple,2,"def calculate_frequency(tup):
    frequency = {}
    for i in tup:
        if type(i) == tuple:
            for j in i:
                if j in frequency:
                    frequency[j] += 1
                else:
                    frequency[j] = 1
        else:
            if i in frequency:
                frequency[i] += 1
            else:
                frequency[i] = 1
    return frequency
mixed_tuple = (1, 2, (3, 4), 4, (5, 6), 7, 8, (9, 10, 9))
frequency = calculate_frequency(mixed_tuple)
print(frequency)",207
py_1700_data.csv,"def maxFruits(fruits, startPos, k):
    left = startPos - k
    right = startPos + k
    maxFruits = 0
    i = 0
    j = 0
    currFruits = 0
    
    while j < len(fruits):
        if fruits[j][0] <= right:
            currFruits += fruits[j][1]
            j += 1
        else:
            maxFruits = max(maxFruits, currFruits)
            if fruits[i][0] <= left:
                currFruits -= fruits[i][1]
                i += 1
            else:
                currFruits = 0
                left = fruits[i][0]
    
    return max(maxFruits, currFruits)","Fruits available positions infinite x-axis. given 2D integer array fruits fruits[i] = [positioni, amounti] depicts amounti fruits position positioni. fruits already sorted positioni ascending order, positioni unique. also given integer startPos integer k. Initially, position startPos. position, either walk left right. takes one step move one unit x-axis, walk k steps total. every position reach, harvest fruits position, fruits disappear position. Return maximum total number fruits harvest.",0,"def maxFruits(fruits, startPos, k):
    left = startPos - k
    right = startPos + k
    maxFruits = 0
    i = 0
    j = 0
    currFruits = 0
    while j < len(fruits):
        if fruits[j][0] <= right:
            currFruits += fruits[j][1]
            j += 1
        else:
            maxFruits = max(maxFruits, currFruits)
            if fruits[i][0] <= left:
                currFruits -= fruits[i][1]
                i += 1
            else:
                currFruits = 0
                left = fruits[i][0]
    return max(maxFruits, currFruits)",208
py_good_answer.csv,"class Flashcard:
    def __init__(self, question, answer):
        self.question = question
        self.answer = answer

    def show_question(self):
        print(self.question)

    def show_answer(self):
        print(self.answer)

flashcard1 = Flashcard(""What is the capital of France?"", ""Paris"")
flashcard2 = Flashcard(""What is the largest planet in our solar system?"", ""Jupiter"")

flashcard1.show_question()
flashcard1.show_answer()

flashcard2.show_question()
flashcard2.show_answer()",Write Python program build flashcard using class Python,0,"class Flashcard:
    def __init__(self, question, answer):
        self.question = question
        self.answer = answer
    def show_question(self):
        print(self.question)
    def show_answer(self):
        print(self.answer)
flashcard1 = Flashcard(""What is the capital of France?"", ""Paris"")
flashcard2 = Flashcard(""What is the largest planet in our solar system?"", ""Jupiter"")
flashcard1.show_question()
flashcard1.show_answer()
flashcard2.show_question()
flashcard2.show_answer()",209
py_1700_data.csv,"def find_special_integer(arr):
    count = len(arr)//4
    for num in arr:
        if arr.count(num) > count:
            return num","Given integer array sorted non-decreasing order, exactly one integer array occurs 25% time, return integer.",1,"def find_special_integer(arr):
    count = len(arr)//4
    for num in arr:
        if arr.count(num) > count:
            return num",210
py_1700_data.csv,"def firstBadVersion(n):
    left = 1
    right = n
    while left < right:
        mid = (left + right) // 2
        if isBadVersion(mid):
            right = mid
        else:
            left = mid + 1
    return left","product manager currently leading team develop new product. Unfortunately, latest version product fails quality check. Since version developed based previous version, versions bad version also bad. Suppose n versions [1, 2, ..., n] want find first bad one, causes following ones bad. given API bool isBadVersion(version) returns whether version bad. Implement function find first bad version. minimize number calls API.",0,"def firstBadVersion(n):
    left = 1
    right = n
    while left < right:
        mid = (left + right) // 2
        if isBadVersion(mid):
            right = mid
        else:
            left = mid + 1
    return left",211
py_good_answer.csv,"def insertAtBottom(stack, item): 
    if isEmpty(stack): 
        push(stack, item) 
    else: 
        temp = pop(stack) 
        insertAtBottom(stack, item) 
        push(stack, temp) 
  
def reverse(stack): 
    if not isEmpty(stack): 
        temp = pop(stack) 
        reverse(stack) 
        insertAtBottom(stack, temp) 

def createStack(): 
    stack = [] 
    return stack 
  
def isEmpty( stack ): 
    return len(stack) == 0
  
def push( stack, item ): 
    stack.append( item ) 
  
def pop( stack ): 
    if(isEmpty( stack )): 
        print(""Stack is empty"") 
        exit(1) 
  
    return stack.pop() 
  
def prints(stack): 
    for i in range(len(stack)-1, -1, -1): 
        print(stack[i], end=' ') 
    print() 
  
stack = createStack() 
push( stack, str(1) ) 
push( stack, str(2) ) 
push( stack, str(3) ) 
push( stack, str(4) ) 
push( stack, str(5) ) 
  
print(""Original Stack "") 
prints(stack) 
  
reverse(stack) 
  
print(""Reversed Stack "") 
prints(stack)",Python Program Reverse Stack using Recursion,0,"def insertAtBottom(stack, item): 
    if isEmpty(stack): 
        push(stack, item) 
    else: 
        temp = pop(stack) 
        insertAtBottom(stack, item) 
        push(stack, temp) 
def reverse(stack): 
    if not isEmpty(stack): 
        temp = pop(stack) 
        reverse(stack) 
        insertAtBottom(stack, temp) 
def createStack(): 
    stack = [] 
    return stack 
def isEmpty( stack ): 
    return len(stack) == 0
def push( stack, item ): 
    stack.append( item ) 
def pop( stack ): 
    if(isEmpty( stack )): 
        print(""Stack is empty"") 
        exit(1) 
    return stack.pop() 
def prints(stack): 
    for i in range(len(stack)-1, -1, -1): 
        print(stack[i], end=' ') 
    print() 
stack = createStack() 
push( stack, str(1) ) 
push( stack, str(2) ) 
push( stack, str(3) ) 
push( stack, str(4) ) 
push( stack, str(5) ) 
print(""Original Stack "") 
prints(stack) 
reverse(stack) 
print(""Reversed Stack "") 
prints(stack)",212
py_good_answer.csv,"class Node:
  def __init__(self, data=None):
    self.data = data
    self.next = None
    
class LinkedList:
  def __init__(self):
    self.head = None
    
  def append(self, data):
    new_node = Node(data)
    
    if self.head is None:
      self.head = new_node
      return
    
    last_node = self.head
    while last_node.next is not None:
      last_node = last_node.next
    
    last_node.next = new_node
    
  def get_node_by_index(self, index):
    current_node = self.head
    current_index = 0
    
    while current_node is not None and current_index < index:
      current_node = current_node.next
      current_index += 1
    
    if current_node is None:
      return None
    
    return current_node.data",Write Python program access specific item singly linked list using index value.,3,"class Node:
  def __init__(self, data=None):
    self.data = data
    self.next = None
class LinkedList:
  def __init__(self):
    self.head = None
  def append(self, data):
    new_node = Node(data)
    if self.head is None:
      self.head = new_node
      return
    last_node = self.head
    while last_node.next is not None:
      last_node = last_node.next
    last_node.next = new_node
  def get_node_by_index(self, index):
    current_node = self.head
    current_index = 0
    while current_node is not None and current_index < index:
      current_node = current_node.next
      current_index += 1
    if current_node is None:
      return None
    return current_node.data",213
py_1700_data.csv,"import math

def network_quality(towers, radius):
    max_quality = -1
    best_coord = [float('inf'), float('inf')]
    
    for x in range(min(t[0] for t in towers)-radius, max(t[0] for t in towers)+radius+1):
        for y in range(min(t[1] for t in towers)-radius, max(t[1] for t in towers)+radius+1):
            signal_quality = 0
            for t in towers:
                if math.sqrt((t[0]-x)**2 + (t[1]-y)**2) <= radius:
                    signal_quality += t[2] // (1 + math.sqrt((t[0]-x)**2 + (t[1]-y)**2))
            if signal_quality > max_quality:
                max_quality = signal_quality
                best_coord = [x, y]
            elif signal_quality == max_quality:
                if (x, y) < tuple(best_coord):
                    best_coord = [x, y]
    
    return best_coord","given array network towers towers, towers[i] = [xi, yi, qi] denotes ith network tower location (xi, yi) quality factor qi. coordinates integral coordinates X-Y plane, distance two coordinates Euclidean distance. also given integer radius tower reachable distance less equal radius. Outside distance, signal becomes garbled, tower reachable. signal quality ith tower coordinate (x, y) calculated formula ?qi / (1 + d)?, distance tower coordinate. network quality coordinate sum signal qualities reachable towers. Return array [cx, cy] representing integral coordinate (cx, cy) network quality maximum. multiple coordinates network quality, return lexicographically minimum non-negative coordinate. Note: coordinate (x1, y1) lexicographically smaller (x2, y2) either: x1 < x2, x1 == x2 y1 < y2. ?val? greatest integer less equal val (the floor function).",0,"import math
def network_quality(towers, radius):
    max_quality = -1
    best_coord = [float('inf'), float('inf')]
    for x in range(min(t[0] for t in towers)-radius, max(t[0] for t in towers)+radius+1):
        for y in range(min(t[1] for t in towers)-radius, max(t[1] for t in towers)+radius+1):
            signal_quality = 0
            for t in towers:
                if math.sqrt((t[0]-x)**2 + (t[1]-y)**2) <= radius:
                    signal_quality += t[2] // (1 + math.sqrt((t[0]-x)**2 + (t[1]-y)**2))
            if signal_quality > max_quality:
                max_quality = signal_quality
                best_coord = [x, y]
            elif signal_quality == max_quality:
                if (x, y) < tuple(best_coord):
                    best_coord = [x, y]
    return best_coord",214
py_1700_data.csv,"def lengthOfLIS(nums):
    if not nums:
        return 0
    n = len(nums)
    dp = [1] * n
    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)","Given integer array nums, return number longest increasing subsequences. Notice sequence strictly increasing.",0,"def lengthOfLIS(nums):
    if not nums:
        return 0
    n = len(nums)
    dp = [1] * n
    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",215
py_1700_data.csv,"def pathSum(root: TreeNode, targetSum: int) -> List[List[int]]:
    paths = []
    def traverse(node, path, total):
        if node is None:
            return
        path.append(node.val)
        total += node.val
        if node.left is None and node.right is None and total == targetSum:
            paths.append(path[:])
        traverse(node.left, path, total)
        traverse(node.right, path, total)
        path.pop()
        total -= node.val
    traverse(root, [], 0)
    return paths","Given root binary tree integer targetSum, return root-to-leaf paths sum node values path equals targetSum. path returned list node values, node references. root-to-leaf path path starting root ending leaf node. leaf node children.",0,"def pathSum(root: TreeNode, targetSum: int) -> List[List[int]]:
    paths = []
    def traverse(node, path, total):
        if node is None:
            return
        path.append(node.val)
        total += node.val
        if node.left is None and node.right is None and total == targetSum:
            paths.append(path[:])
        traverse(node.left, path, total)
        traverse(node.right, path, total)
        path.pop()
        total -= node.val
    traverse(root, [], 0)
    return paths",216
py_1700_data.csv,"
class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        if word.upper() == word or word.lower() == word or word.capitalize() == word:
            return True
        return False
","define usage capitals word right one following cases holds: letters word capitals, like ""USA"". letters word capitals, like ""leetcode"". first letter word capital, like ""Google"". Given string word, return true usage capitals right.",3,"class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        if word.upper() == word or word.lower() == word or word.capitalize() == word:
            return True
        return False
",217
py_good_answer.csv," python
def smallest_multiple(n):
    factors = []
    num = 1
    while len(factors) < n:
        for i in range(1, num+1):
            if num % i == 0:
                if i not in factors:
                    factors.append(i)
        num += 1
    return factors[-1]
    
n = int(input(""Enter a value for n: ""))
print(""The smallest multiple of first"",n,""numbers is:"",smallest_multiple(n))

","Write Python program find smallest multiple first n numbers. Also, display factors.",3," python
def smallest_multiple(n):
    factors = []
    num = 1
    while len(factors) < n:
        for i in range(1, num+1):
            if num % i == 0:
                if i not in factors:
                    factors.append(i)
        num += 1
    return factors[-1]
n = int(input(""Enter a value for n: ""))
print(""The smallest multiple of first"",n,""numbers is:"",smallest_multiple(n))
",218
py_good_answer.csv,"def count_upper_lower(string):
    upper_count = 0
    lower_count = 0
    for letter in string:
        if letter.isupper():
            upper_count += 1
        elif letter.islower():
            lower_count += 1
    return (upper_count, lower_count)",Write Python function accepts string calculate number upper case letters lower case letters.,2,"def count_upper_lower(string):
    upper_count = 0
    lower_count = 0
    for letter in string:
        if letter.isupper():
            upper_count += 1
        elif letter.islower():
            lower_count += 1
    return (upper_count, lower_count)",219
py_1700_data.csv,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        nums.sort(key=int, reverse=True)
        return nums[k-1]","given array strings nums integer k. string nums represents integer without leading zeros. Return string represents kth largest integer nums. Note: Duplicate numbers counted distinctly. example, nums [""1"",""2"",""2""], ""2"" first largest integer, ""2"" second-largest integer, ""1"" third-largest integer.",0,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        nums.sort(key=int, reverse=True)
        return nums[k-1]",220
py_1700_data.csv,"def isAlienSorted(words, order):
    alien_dict = {}
    for index, char in enumerate(order):
        alien_dict[char] = index

    for i in range(len(words) - 1):
        word1 = words[i]
        word2 = words[i + 1]

        for j in range(min(len(word1), len(word2))):
            if word1[j] != word2[j]:
                if alien_dict[word1[j]] > alien_dict[word2[j]]:
                    return False
                break
        else:
            if len(word1) > len(word2):
                return False

    return True","alien language, surprisingly, also use English lowercase letters, possibly different order. order alphabet permutation lowercase letters. Given sequence words written alien language, order alphabet, return true given words sorted lexicographically alien language.",3,"def isAlienSorted(words, order):
    alien_dict = {}
    for index, char in enumerate(order):
        alien_dict[char] = index
    for i in range(len(words) - 1):
        word1 = words[i]
        word2 = words[i + 1]
        for j in range(min(len(word1), len(word2))):
            if word1[j] != word2[j]:
                if alien_dict[word1[j]] > alien_dict[word2[j]]:
                    return False
                break
        else:
            if len(word1) > len(word2):
                return False
    return True",221
py_1700_data.csv,"from collections import Counter
from typing import List

def watchedVideosByFriends(watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:
    queue = [(id, 0)]
    visited = set([id])
    while queue:
        person, distance = queue.pop(0)
        if distance == level:
            videos = []
            for friend in friends[person]:
                for video in watchedVideos[friend]:
                    videos.append(video)
            counter = Counter(videos)
            return [video for video, freq in sorted(counter.items(), key=lambda x: (x[1], x[0]))]
        for friend in friends[person]:
            if friend not in visited:
                visited.add(friend)
                queue.append((friend, distance + 1))","n people, person unique id 0 n-1. Given arrays watchedVideos friends, watchedVideos[i] friends[i] contain list watched videos list friends respectively person id = i. Level 1 videos watched videos friends, level 2 videos watched videos friends friends on. general, level k videos watched videos people shortest path exactly equal k you. Given id level videos, return list videos ordered frequencies (increasing). videos frequency order alphabetically least greatest.",0,"from collections import Counter
from typing import List
def watchedVideosByFriends(watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:
    queue = [(id, 0)]
    visited = set([id])
    while queue:
        person, distance = queue.pop(0)
        if distance == level:
            videos = []
            for friend in friends[person]:
                for video in watchedVideos[friend]:
                    videos.append(video)
            counter = Counter(videos)
            return [video for video, freq in sorted(counter.items(), key=lambda x: (x[1], x[0]))]
        for friend in friends[person]:
            if friend not in visited:
                visited.add(friend)
                queue.append((friend, distance + 1))",222
py_good_answer.csv,"def product(x, y):
    if y == 0:
        return 0
    else:
        return x + product(x, y-1)
    
x = int(input(""Enter first number: ""))
y = int(input(""Enter second number: ""))
print(""Product of"", x, ""and"", y, ""is"", product(x, y))",Python Program Find Product two Numbers Using Recursion,2,"def product(x, y):
    if y == 0:
        return 0
    else:
        return x + product(x, y-1)
x = int(input(""Enter first number: ""))
y = int(input(""Enter second number: ""))
print(""Product of"", x, ""and"", y, ""is"", product(x, y))",223
py_good_answer.csv,"
# import necessary libraries
import numpy as np

# function to find the transitive closure of a graph
def transitive_closure(graph):
    """"""
    Find the transitive closure of a graph.
    """"""
    n = len(graph)
    closure = np.copy(graph)

    for k in range(n):
        for i in range(n):
            for j in range(n):
                closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j])
  
    return closure
",Python Program Find Transitive Closure Graph,0,"import numpy as np
def transitive_closure(graph):
    n = len(graph)
    closure = np.copy(graph)
    for k in range(n):
        for i in range(n):
            for j in range(n):
                closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j])
    return closure
",224
py_good_answer.csv,"lst_int = [1, 2, 2, 3, 3, 3, 4, 5, 5, 5]
lst_char = ['a', 'a', 'b', 'c', 'c', 'd', 'd', 'd', 'd', 'e']

def run_length_encoding(lst_int, lst_char):
    encoding = []
    count = 1
    for i in range(1, len(lst_int)):
        if lst_int[i] == lst_int[i-1]:
            count += 1
        else:
            encoding.append((count, lst_char[i-1]))
            count = 1
    encoding.append((count, lst_char[-1]))
    return encoding

print(run_length_encoding(lst_int, lst_char))",Write Python program create list reflecting run-length encoding given list integers given list characters.,0,"lst_int = [1, 2, 2, 3, 3, 3, 4, 5, 5, 5]
lst_char = ['a', 'a', 'b', 'c', 'c', 'd', 'd', 'd', 'd', 'e']
def run_length_encoding(lst_int, lst_char):
    encoding = []
    count = 1
    for i in range(1, len(lst_int)):
        if lst_int[i] == lst_int[i-1]:
            count += 1
        else:
            encoding.append((count, lst_char[i-1]))
            count = 1
    encoding.append((count, lst_char[-1]))
    return encoding
print(run_length_encoding(lst_int, lst_char))",225
py_1700_data.csv,"def minDays(tasks: List[int], space: int) -> int:
    intervals = defaultdict(int)
    max_frequency = 0
    
    for i in range(len(tasks)):
        if tasks[i] not in intervals or (i - intervals[tasks[i]] > space):
            intervals[tasks[i]] = i
        else:
            intervals[tasks[i]] = intervals[tasks[i]] + space + 1
        
        max_frequency = max(max_frequency, len(intervals))
    
    return len(tasks) + (max_frequency - 1) * (space + 1) if max_frequency > 0 else len(tasks)","given 0-indexed array positive integers tasks, representing tasks need completed order, tasks[i] represents type ith task. also given positive integer space, represents minimum number days must pass completion task another task type performed. day, tasks completed, must either: Complete next task tasks, Take break. Return minimum number days needed complete tasks.",0,"def minDays(tasks: List[int], space: int) -> int:
    intervals = defaultdict(int)
    max_frequency = 0
    for i in range(len(tasks)):
        if tasks[i] not in intervals or (i - intervals[tasks[i]] > space):
            intervals[tasks[i]] = i
        else:
            intervals[tasks[i]] = intervals[tasks[i]] + space + 1
        max_frequency = max(max_frequency, len(intervals))
    return len(tasks) + (max_frequency - 1) * (space + 1) if max_frequency > 0 else len(tasks)",226
py_1700_data.csv,"def countIdealArrays(n, maxValue):
    mod = 1000000007
    dp = [[0 for i in range(maxValue+1)] for j in range(n)]
    for j in range(1,maxValue+1):
        dp[0][j] = 1
    for i in range(1,n):
        for j in range(1,maxValue+1):
            for k in range(1,maxValue//j+1):
                dp[i][j*k] = (dp[i][j*k]+dp[i-1][j])%mod
    return sum(dp[n-1])%mod","given two integers n maxValue, used describe ideal array. 0-indexed integer array arr length n considered ideal following conditions hold: Every arr[i] value 1 maxValue, 0 <= < n. Every arr[i] divisible arr[i - 1], 0 < < n. Return number distinct ideal arrays length n. Since answer may large, return modulo 109 + 7.",3,"def countIdealArrays(n, maxValue):
    mod = 1000000007
    dp = [[0 for i in range(maxValue+1)] for j in range(n)]
    for j in range(1,maxValue+1):
        dp[0][j] = 1
    for i in range(1,n):
        for j in range(1,maxValue+1):
            for k in range(1,maxValue//j+1):
                dp[i][j*k] = (dp[i][j*k]+dp[i-1][j])%mod
    return sum(dp[n-1])%mod",227
py_1700_data.csv,"def num_captures(board):
    white_rook_pos = None
    pawns_pos = []
    white_bishops_pos = []

    # finding positions
    for i in range(len(board)):
        for j in range(len(board[0])):
            
            if board[i][j] == 'R':
                white_rook_pos = (i, j)
            
            elif board[i][j] == 'p':
                pawns_pos.append((i, j))
            
            elif board[i][j] == 'B':
                white_bishops_pos.append((i, j))
    
    captures = 0
    
    # finding captures
    for pawn_pos in pawns_pos:
        
        # same row
        if pawn_pos[0] == white_rook_pos[0]:
            
            if pawn_pos[1] > white_rook_pos[1]:
                blocked = False
                for bishop_pos in white_bishops_pos:
                    if bishop_pos[1] > white_rook_pos[1] and bishop_pos[1] < pawn_pos[1] and bishop_pos[0] == pawn_pos[0]:
                        blocked = True
                        break
                if not blocked:
                    captures += 1
                        
            else:
                blocked = False
                for bishop_pos in white_bishops_pos:
                    if bishop_pos[1] < white_rook_pos[1] and bishop_pos[1] > pawn_pos[1] and bishop_pos[0] == pawn_pos[0]:
                        blocked = True
                        break
                if not blocked:
                    captures += 1
        
        # same col
        elif pawn_pos[1] == white_rook_pos[1]:
            
            if pawn_pos[0] > white_rook_pos[0]:
                blocked = False
                for bishop_pos in white_bishops_pos:
                    if bishop_pos[0] > white_rook_pos[0] and bishop_pos[0] < pawn_pos[0] and bishop_pos[1] == pawn_pos[1]:
                        blocked = True
                        break
                if not blocked:
                    captures += 1
                        
            else:
                blocked = False
                for bishop_pos in white_bishops_pos:
                    if bishop_pos[0] < white_rook_pos[0] and bishop_pos[0] > pawn_pos[0] and bishop_pos[1] == pawn_pos[1]:
                        blocked = True
                        break
                if not blocked:
                    captures += 1
                    
    return captures","8 x 8 chessboard, exactly one white rook 'R' number white bishops 'B', black pawns 'p', empty squares '.'. rook moves, chooses one four cardinal directions (north, east, south, west), moves direction chooses stop, reaches edge board, captures black pawn, blocked white bishop. rook considered attacking pawn rook capture pawn rook's turn. number available captures white rook number pawns rook attacking. Return number available captures white rook.",3,"def num_captures(board):
    white_rook_pos = None
    pawns_pos = []
    white_bishops_pos = []
    for i in range(len(board)):
        for j in range(len(board[0])):
            if board[i][j] == 'R':
                white_rook_pos = (i, j)
            elif board[i][j] == 'p':
                pawns_pos.append((i, j))
            elif board[i][j] == 'B':
                white_bishops_pos.append((i, j))
    captures = 0
    for pawn_pos in pawns_pos:
        if pawn_pos[0] == white_rook_pos[0]:
            if pawn_pos[1] > white_rook_pos[1]:
                blocked = False
                for bishop_pos in white_bishops_pos:
                    if bishop_pos[1] > white_rook_pos[1] and bishop_pos[1] < pawn_pos[1] and bishop_pos[0] == pawn_pos[0]:
                        blocked = True
                        break
                if not blocked:
                    captures += 1
            else:
                blocked = False
                for bishop_pos in white_bishops_pos:
                    if bishop_pos[1] < white_rook_pos[1] and bishop_pos[1] > pawn_pos[1] and bishop_pos[0] == pawn_pos[0]:
                        blocked = True
                        break
                if not blocked:
                    captures += 1
        elif pawn_pos[1] == white_rook_pos[1]:
            if pawn_pos[0] > white_rook_pos[0]:
                blocked = False
                for bishop_pos in white_bishops_pos:
                    if bishop_pos[0] > white_rook_pos[0] and bishop_pos[0] < pawn_pos[0] and bishop_pos[1] == pawn_pos[1]:
                        blocked = True
                        break
                if not blocked:
                    captures += 1
            else:
                blocked = False
                for bishop_pos in white_bishops_pos:
                    if bishop_pos[0] < white_rook_pos[0] and bishop_pos[0] > pawn_pos[0] and bishop_pos[1] == pawn_pos[1]:
                        blocked = True
                        break
                if not blocked:
                    captures += 1
    return captures",228
py_1700_data.csv,"def unique_integers(n):
    arr = []
    for i in range(1, n+1):
        arr.append(i)
    arr.append(0)
    return arr","Given integer n, return array containing n unique integers add 0.",0,"def unique_integers(n):
    arr = []
    for i in range(1, n+1):
        arr.append(i)
    arr.append(0)
    return arr",229
py_1700_data.csv,"class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        if not head or not head.next:
            return False
        slow = head
        fast = head.next
        while slow != fast:
            if not fast or not fast.next:
                return False
            slow = slow.next
            fast = fast.next.next
        return True","Given head, head linked list, determine linked list cycle it. cycle linked list node list reached continuously following next pointer. Internally, pos used denote index node tail's next pointer connected to. Note pos passed parameter. Return true cycle linked list. Otherwise, return false.",3,"class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        if not head or not head.next:
            return False
        slow = head
        fast = head.next
        while slow != fast:
            if not fast or not fast.next:
                return False
            slow = slow.next
            fast = fast.next.next
        return True",230
py_1700_data.csv,"def findKthPositive(arr, k):
    count = 0
    for i in range(1, arr[-1] + k + 1):
        if i not in arr:
            count += 1
            if count == k:
                return i","Given array arr positive integers sorted strictly increasing order, integer k. Return kth positive integer missing array.",3,"def findKthPositive(arr, k):
    count = 0
    for i in range(1, arr[-1] + k + 1):
        if i not in arr:
            count += 1
            if count == k:
                return i",231
py_1700_data.csv,"
from collections import defaultdict

def dfs(node, visited, graph, restricted):
    """"""
    depth first search traversal through the tree
    
    Parameters:
    node (int): current node
    visited (set): set of visited nodes
    graph (dict): adjacency list representation of the tree
    restricted (set): set of restricted nodes
    
    Returns:
    count (int): number of nodes reachable from node 0 without visiting a restricted node
    """"""
    visited.add(node)
    count = 1
    for nei in graph[node]:
        if nei in visited or nei in restricted:
            continue
        count += dfs(nei, visited, graph, restricted)
    return count

def max_nodes_reachable(n: int, edges: List[List[int]], restricted: List[int]) -> int:
    """"""
    find maximum number of nodes that can be reached from node 0 without visiting any restricted node
    
    Parameters:
    n (int): number of nodes
    edges (List[List[int]]): description of edges in the tree (2D integer array)
    restricted (List[int]): nodes that cannot be visited
    
    Returns:
    max_count (int): maximum number of nodes that can be reached from node 0 without visiting any restricted node
    """"""
    # build adjacency list to represent tree
    graph = defaultdict(list)
    for edge in edges:
        u, v = edge[0], edge[1]
        graph[u].append(v)
        graph[v].append(u)
    
    # DFS traversal to count number of reachable nodes
    visited = set()
    max_count = 0
    for nei in graph[0]:
        if nei not in restricted:
            count = dfs(nei, visited, graph, restricted)
            max_count = max(max_count, count)
    return max_count
","undirected tree n nodes labeled 0 n - 1 n - 1 edges. given 2D integer array edges length n - 1 edges[i] = [ai, bi] indicates edge nodes ai bi tree. also given integer array restricted represents restricted nodes. Return maximum number nodes reach node 0 without visiting restricted node. Note node 0 restricted node.",1,"from collections import defaultdict
def dfs(node, visited, graph, restricted):
    visited.add(node)
    count = 1
    for nei in graph[node]:
        if nei in visited or nei in restricted:
            continue
        count += dfs(nei, visited, graph, restricted)
    return count
def max_nodes_reachable(n: int, edges: List[List[int]], restricted: List[int]) -> int:
    graph = defaultdict(list)
    for edge in edges:
        u, v = edge[0], edge[1]
        graph[u].append(v)
        graph[v].append(u)
    visited = set()
    max_count = 0
    for nei in graph[0]:
        if nei not in restricted:
            count = dfs(nei, visited, graph, restricted)
            max_count = max(max_count, count)
    return max_count
",232
py_1700_data.csv,"def maxSumAfterPartitioning(arr, k):
    n = len(arr)
    dp = [0] * (n+1)
    for i in range(n):
        curr_max = 0
        for j in range(1, k+1):
            if i-j+1 >= 0:
                curr_max = max(curr_max, arr[i-j+1])
                dp[i] = max(dp[i], dp[i-j] + curr_max*j)
    return dp[n-1]","Given integer array arr, partition array (contiguous) subarrays length k. partitioning, subarray values changed become maximum value subarray. Return largest sum given array partitioning. Test cases generated answer fits 32-bit integer.",3,"def maxSumAfterPartitioning(arr, k):
    n = len(arr)
    dp = [0] * (n+1)
    for i in range(n):
        curr_max = 0
        for j in range(1, k+1):
            if i-j+1 >= 0:
                curr_max = max(curr_max, arr[i-j+1])
                dp[i] = max(dp[i], dp[i-j] + curr_max*j)
    return dp[n-1]",233
py_1700_data.csv,"def findEqualPairs(grid):
    pairs = []
    n = len(grid)
    for i in range(n):
        for j in range(n):
            for m in range(i, n):
                start = j if i == m else 0
                for k in range(start, n):
                    if i != m or j < k:
                        if grid[i][j] == grid[m][k]:
                            pairs.append((i,j))
                            pairs.append((m,k))
    return pairs","Given 0-indexed n x n integer matrix grid, return number pairs (ri, cj) row ri column cj equal. row column pair considered equal contain elements order (i.e., equal array).",0,"def findEqualPairs(grid):
    pairs = []
    n = len(grid)
    for i in range(n):
        for j in range(n):
            for m in range(i, n):
                start = j if i == m else 0
                for k in range(start, n):
                    if i != m or j < k:
                        if grid[i][j] == grid[m][k]:
                            pairs.append((i,j))
                            pairs.append((m,k))
    return pairs",234
py_1700_data.csv,"
def maxLines(nums1, nums2):
    dp = [[0 for j in range(len(nums2) + 1)] for i in range(len(nums1) + 1)]
    for i in range(1, len(nums1) + 1):
        for j in range(1, len(nums2) + 1):
            if nums1[i - 1] == nums2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]
","given two integer arrays nums1 nums2. write integers nums1 nums2 (in order given) two separate horizontal lines. may draw connecting lines: straight line connecting two numbers nums1[i] nums2[j] that: nums1[i] == nums2[j], line draw intersect connecting (non-horizontal) line. Note connecting line cannot intersect even endpoints (i.e., number belong one connecting line). Return maximum number connecting lines draw way.",3,"def maxLines(nums1, nums2):
    dp = [[0 for j in range(len(nums2) + 1)] for i in range(len(nums1) + 1)]
    for i in range(1, len(nums1) + 1):
        for j in range(1, len(nums2) + 1):
            if nums1[i - 1] == nums2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]
",235
py_1700_data.csv,"def longestSubsequence(nums, k):
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] - nums[j] == k:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp) if max(dp) > 1 else 0",given integer array nums integer k. Find longest subsequence nums meets following requirements: subsequence strictly increasing difference adjacent elements subsequence k. Return length longest subsequence meets requirements. subsequence array derived another array deleting elements without changing order remaining elements.,1,"def longestSubsequence(nums, k):
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] - nums[j] == k:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp) if max(dp) > 1 else 0",236
py_good_answer.csv,"
def find_index(lst, func):
    for i in range(len(lst)):
        if func(lst[i]):
            return i
    return -1
",Write Python program find index first element given list satisfies provided testing function.,2,"def find_index(lst, func):
    for i in range(len(lst)):
        if func(lst[i]):
            return i
    return -1
",237
py_1700_data.csv,"def isIdealPermutation(nums):
    num_globals = 0
    num_locals = 0
    for i in range(len(nums)):
        for j in range(i+1, len(nums)):
            if nums[i] > nums[j]:
                num_globals += 1
                if j == i+1:
                    num_locals += 1
    return num_globals == num_locals","given integer array nums length n represents permutation integers range [0, n - 1]. number global inversions number different pairs (i, j) where: 0 <= < j < n nums[i] > nums[j] number local inversions number indices where: 0 <= < n - 1 nums[i] > nums[i + 1] Return true number global inversions equal number local inversions.",3,"def isIdealPermutation(nums):
    num_globals = 0
    num_locals = 0
    for i in range(len(nums)):
        for j in range(i+1, len(nums)):
            if nums[i] > nums[j]:
                num_globals += 1
                if j == i+1:
                    num_locals += 1
    return num_globals == num_locals",238
py_good_answer.csv,"items = {(60, 10), (100, 20), (120, 30)} # (value, weight) pairs
capacity = 50
value = 0

def fractional_knapsack(items, capacity):
    total_weight = 0
    for v, w in sorted(items, key=lambda i: -i[0]/i[1]):
        if total_weight + w <= capacity:
            value += v
            total_weight += w
        else:
            value += (capacity - total_weight) * (v / w)
            break
    return value

print(fractional_knapsack(items, capacity))",Python Program Solve Fractional Knapsack Problem using Greedy Algorithm,0,"items = {(60, 10), (100, 20), (120, 30)} 
capacity = 50
value = 0
def fractional_knapsack(items, capacity):
    total_weight = 0
    for v, w in sorted(items, key=lambda i: -i[0]/i[1]):
        if total_weight + w <= capacity:
            value += v
            total_weight += w
        else:
            value += (capacity - total_weight) * (v / w)
            break
    return value
print(fractional_knapsack(items, capacity))",239
py_1700_data.csv,"
def countVowelSubstrings(word: str) -> int:
    n = len(word)
    count = 0
    for i in range(n):
        if word[i] in 'aeiou':
            count += (n-i)
    return count
","Given string word, return sum number vowels ('a', 'e', 'i', 'o', 'u') every substring word. substring contiguous (non-empty) sequence characters within string. Note: Due large constraints, answer may fit signed 32-bit integer. Please careful calculations.",0,"def countVowelSubstrings(word: str) -> int:
    n = len(word)
    count = 0
    for i in range(n):
        if word[i] in 'aeiou':
            count += (n-i)
    return count
",240
py_1700_data.csv,"
def triangleNumber(nums):
    nums.sort()
    n = len(nums)
    count = 0
    for i in range(n-2):
        k = i+2
        for j in range(i+1, n-1):
            while k < n and nums[i]+nums[j] > nums[k]:
                k += 1
            count += k-j-1
    return count
","Given integer array nums, return number triplets chosen array make triangles take side lengths triangle.",3,"def triangleNumber(nums):
    nums.sort()
    n = len(nums)
    count = 0
    for i in range(n-2):
        k = i+2
        for j in range(i+1, n-1):
            while k < n and nums[i]+nums[j] > nums[k]:
                k += 1
            count += k-j-1
    return count
",241
py_1700_data.csv,"def find_max_good_integer(num):
    max_good = """"
    for i in range(len(num)):
        for j in range(i+3, len(num)+1):
            sub_str = num[i:j]
            if len(sub_str) == 3 and len(set(sub_str)) == 1:
                if int(sub_str) > int(max_good):
                    max_good = sub_str
    return max_good","given string num representing large integer. integer good meets following conditions: substring num length 3. consists one unique digit. Return maximum good integer string empty string """" integer exists. Note: substring contiguous sequence characters within string. may leading zeroes num good integer.",1,"def find_max_good_integer(num):
    max_good = """"
    for i in range(len(num)):
        for j in range(i+3, len(num)+1):
            sub_str = num[i:j]
            if len(sub_str) == 3 and len(set(sub_str)) == 1:
                if int(sub_str) > int(max_good):
                    max_good = sub_str
    return max_good",242
py_1700_data.csv,"def findLengthOfLCIS(nums):
    if len(nums) == 0:
        return 0
    max_length = 1
    length = 1
    for i in range(1, len(nums)):
        if nums[i] > nums[i-1]:
            length += 1
        else:
            max_length = max(max_length, length)
            length = 1
    return max(max_length, length)","Given unsorted array integers nums, return length longest continuous increasing subsequence (i.e. subarray). subsequence must strictly increasing. continuous increasing subsequence defined two indices l r (l < r) [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] l <= < r, nums[i] < nums[i + 1].",3,"def findLengthOfLCIS(nums):
    if len(nums) == 0:
        return 0
    max_length = 1
    length = 1
    for i in range(1, len(nums)):
        if nums[i] > nums[i-1]:
            length += 1
        else:
            max_length = max(max_length, length)
            length = 1
    return max(max_length, length)",243
py_1700_data.csv,"def poorPigs(buckets: int, minutesToDie: int, minutesToTest: int) -> int:
    rounds = minutesToTest // minutesToDie + 1
    pigs = 0
    while pow(rounds, pigs) < buckets:
        pigs += 1
    return pigs","buckets buckets liquid, exactly one buckets poisonous. figure one poisonous, feed number (poor) pigs liquid see whether die not. Unfortunately, minutesToTest minutes determine bucket poisonous. feed pigs according steps: Choose live pigs feed. pig, choose buckets feed it. pig consume chosen buckets simultaneously take time. pig feed number buckets, bucket fed number pigs. Wait minutesToDie minutes. may feed pigs time. minutesToDie minutes passed, pigs fed poisonous bucket die, others survive. Repeat process run time. Given buckets, minutesToDie, minutesToTest, return minimum number pigs needed figure bucket poisonous within allotted time.",3,"def poorPigs(buckets: int, minutesToDie: int, minutesToTest: int) -> int:
    rounds = minutesToTest // minutesToDie + 1
    pigs = 0
    while pow(rounds, pigs) < buckets:
        pigs += 1
    return pigs",244
py_1700_data.csv,"def split_message(message: str, limit: int) -> List[str]:
    if limit >= len(message):
        return [message]
    elif len(message) % limit > 0 or len(message) // limit == 0:
        return []
    else:
        parts = []
        num_parts = len(message) // limit
        for i in range(num_parts):
            part_suffix = ""<{}/{}>"".format(i+1, num_parts)
            part = message[i*limit:(i+1)*limit] + part_suffix
            parts.append(part)
        last_suffix = ""<{}/{}>"".format(num_parts+1, num_parts+1)
        last_part = message[num_parts*limit:] + last_suffix
        parts.append(last_part)
        return parts","given string, message, positive integer, limit. must split message one parts based limit. resulting part suffix ""<a/b>"", ""b"" replaced total number parts ""a"" replaced index part, starting 1 going b. Additionally, length resulting part (including suffix) equal limit, except last part whose length limit. resulting parts formed suffixes removed concatenated order, equal message. Also, result contain parts possible. Return parts message would split array strings. impossible split message required, return empty array.",1,"def split_message(message: str, limit: int) -> List[str]:
    if limit >= len(message):
        return [message]
    elif len(message) % limit > 0 or len(message) // limit == 0:
        return []
    else:
        parts = []
        num_parts = len(message) // limit
        for i in range(num_parts):
            part_suffix = ""<{}/{}>"".format(i+1, num_parts)
            part = message[i*limit:(i+1)*limit] + part_suffix
            parts.append(part)
        last_suffix = ""<{}/{}>"".format(num_parts+1, num_parts+1)
        last_part = message[num_parts*limit:] + last_suffix
        parts.append(last_part)
        return parts",245
py_good_answer.csv,"def check_sequence(seq, patterns):
    for pattern in patterns:
        i = 0
        for s in seq:
            if s == pattern[i]:
                i += 1
                if i == len(pattern):
                    break
        if i == len(pattern):
            return True
    return False",Write Python program check whether follows sequence given patterns array.,3,"def check_sequence(seq, patterns):
    for pattern in patterns:
        i = 0
        for s in seq:
            if s == pattern[i]:
                i += 1
                if i == len(pattern):
                    break
        if i == len(pattern):
            return True
    return False",246
py_1700_data.csv,"class Solution:
    def rob(self, nums: List[int]) -> int:
        
        prev_max = curr_max = 0
        
        for num in nums:
            temp = curr_max
            curr_max = max(prev_max + num, curr_max)
            prev_max = temp
            
        return curr_max","professional robber planning rob houses along street. house certain amount money stashed, constraint stopping robbing adjacent houses security systems connected automatically contact police two adjacent houses broken night. Given integer array nums representing amount money house, return maximum amount money rob tonight without alerting police.",3,"class Solution:
    def rob(self, nums: List[int]) -> int:
        prev_max = curr_max = 0
        for num in nums:
            temp = curr_max
            curr_max = max(prev_max + num, curr_max)
            prev_max = temp
        return curr_max",247
py_1700_data.csv,"
def concat_str(s, n):
    return s * n

def remove_chars(s1, s2):
    for c in s1:
        s2 = s2.replace(c, '')
    return s2

def max_concat(str1, str2, n1, n2):
    max_len = 0
    for i in range(1, n2+1):
        s2 = concat_str(str2, i)
        s1 = remove_chars(str1, s2)
        length = len(concat_str(str2, i+n1))
        if length > max_len:
            max_len = length
    return max_len
","define str = [s, n] string str consists string concatenated n times. example, str == [""abc"", 3] ==""abcabcabc"". define string s1 obtained string s2 remove characters s2 becomes s1. example, s1 = ""abc"" obtained s2 = ""abdbec"" based definition removing bolded underlined characters. given two strings s1 s2 two integers n1 n2. two strings str1 = [s1, n1] str2 = [s2, n2]. Return maximum integer str = [str2, m] obtained str1.",0,"def concat_str(s, n):
    return s * n
def remove_chars(s1, s2):
    for c in s1:
        s2 = s2.replace(c, '')
    return s2
def max_concat(str1, str2, n1, n2):
    max_len = 0
    for i in range(1, n2+1):
        s2 = concat_str(str2, i)
        s1 = remove_chars(str1, s2)
        length = len(concat_str(str2, i+n1))
        if length > max_len:
            max_len = length
    return max_len
",248
py_good_answer.csv,"import itertools 

def interleave(*lists): 
    ziplists = (itertools.zip_longest(*lists)) 
    flattened = itertools.chain.from_iterable(ziplists) 
    return (i for i in flattened if i is not None) 

a = [1, 2, 3] 
b = ['a', 'b', 'c', 'd'] 
c = [True, False] 

for i in interleave(a, b, c): 
    print(i)",Write Python program interleave multiple lists length. Use itertools module.,0,"import itertools 
def interleave(*lists): 
    ziplists = (itertools.zip_longest(*lists)) 
    flattened = itertools.chain.from_iterable(ziplists) 
    return (i for i in flattened if i is not None) 
a = [1, 2, 3] 
b = ['a', 'b', 'c', 'd'] 
c = [True, False] 
for i in interleave(a, b, c): 
    print(i)",249
py_1700_data.csv,"
def min_work_sessions(tasks, sessionTime):
    time_left = [0] * sessionTime
    
    for task in sorted(tasks, reverse=True):
        for i in range(sessionTime-1, -1, -1):
            if time_left[i] <= task:
                task -= time_left[i]
                time_left[i] = sessionTime
                if task == 0:
                    break
        if task > 0:
            return -1
        
    return sum(1 for t in time_left if t == sessionTime)
","n tasks assigned you. task times represented integer array tasks length n, ith task takes tasks[i] hours finish. work session work sessionTime consecutive hours take break. finish given tasks way satisfies following conditions: start task work session, must complete work session. start new task immediately finishing previous one. may complete tasks order. Given tasks sessionTime, return minimum number work sessions needed finish tasks following conditions above. tests generated sessionTime greater equal maximum element tasks[i].",0,"def min_work_sessions(tasks, sessionTime):
    time_left = [0] * sessionTime
    for task in sorted(tasks, reverse=True):
        for i in range(sessionTime-1, -1, -1):
            if time_left[i] <= task:
                task -= time_left[i]
                time_left[i] = sessionTime
                if task == 0:
                    break
        if task > 0:
            return -1
    return sum(1 for t in time_left if t == sessionTime)
",250
py_70_data.csv,"
def count_char_occurrence(string, char):
    count = 0
    for c in string:
        if c == char:
            count += 1
    return count

string = ""hello world""
char = ""l""
print(count_char_occurrence(string, char)) # Output: 3
",Python Program count occurrence given characters string.,3,"def count_char_occurrence(string, char):
    count = 0
    for c in string:
        if c == char:
            count += 1
    return count
string = ""hello world""
char = ""l""
print(count_char_occurrence(string, char)) 
",251
py_1700_data.csv,"
import itertools

def latestTime(arr):
    perms = itertools.permutations(arr)
    valid_times = []
    for perm in perms:
        hours = 10*perm[0] + perm[1]
        mins = 10*perm[2] + perm[3]
        if hours < 24 and mins < 60:
            valid_times.append(f""{hours:02}:{mins:02}"")
    if valid_times:
        return max(valid_times)
    else:
        return """"
","Given array arr 4 digits, find latest 24-hour time made using digit exactly once. 24-hour times formatted ""HH:MM"", HH 00 23, MM 00 59. earliest 24-hour time 00:00, latest 23:59. Return latest 24-hour time ""HH:MM"" format. valid time made, return empty string.",0,"import itertools
def latestTime(arr):
    perms = itertools.permutations(arr)
    valid_times = []
    for perm in perms:
        hours = 10*perm[0] + perm[1]
        mins = 10*perm[2] + perm[3]
        if hours < 24 and mins < 60:
            valid_times.append(f""{hours:02}:{mins:02}"")
    if valid_times:
        return max(valid_times)
    else:
        return """"
",252
py_1700_data.csv,"def average(salary: List[int]) -> float:
    salary.sort()
    return sum(salary[1:-1]) / (len(salary) - 2)",given array unique integers salary salary[i] salary ith employee. Return average salary employees excluding minimum maximum salary. Answers within 10-5 actual answer accepted.,3,"def average(salary: List[int]) -> float:
    salary.sort()
    return sum(salary[1:-1]) / (len(salary) - 2)",253
py_1700_data.csv,"def perform_replacements(s, indices, sources, targets):
    for i in range(len(indices)):
        if sources[i] in s[indices[i]:]:
            s = s[:indices[i]] + s[indices[i]:].replace(sources[i], targets[i], 1)
    return s","given 0-indexed string must perform k replacement operations on. replacement operations given three 0-indexed parallel arrays, indices, sources, targets, length k. complete ith replacement operation: Check substring sources[i] occurs index indices[i] original string s. occur, nothing. Otherwise occur, replace substring targets[i]. example, = ""abcd"", indices[i] = 0, sources[i] = ""ab"", targets[i] = ""eee"", result replacement ""eeecd"". replacement operations must occur simultaneously, meaning replacement operations affect indexing other. testcases generated replacements overlap. example, testcase = ""abc"", indices = [0, 1], sources = [""ab"",""bc""] generated ""ab"" ""bc"" replacements overlap. Return resulting string performing replacement operations s. substring contiguous sequence characters string.",3,"def perform_replacements(s, indices, sources, targets):
    for i in range(len(indices)):
        if sources[i] in s[indices[i]:]:
            s = s[:indices[i]] + s[indices[i]:].replace(sources[i], targets[i], 1)
    return s",254
py_good_answer.csv,"class Node:
    def __init__(self, data):
        self.item = data
        self.next = None
        self.prev = None
        
class DoublyLinkedList:
    def __init__(self):
        self.head = None
        
    def insert_front(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        if self.head is not None:
            self.head.prev = new_node
        self.head = new_node
        
    def print_list(self):
        node = self.head
        while node is not None:
            print(node.item)
            node = node.next",Write Python program insert item front given doubly linked list.,0,"class Node:
    def __init__(self, data):
        self.item = data
        self.next = None
        self.prev = None
class DoublyLinkedList:
    def __init__(self):
        self.head = None
    def insert_front(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        if self.head is not None:
            self.head.prev = new_node
        self.head = new_node
    def print_list(self):
        node = self.head
        while node is not None:
            print(node.item)
            node = node.next",255
py_1700_data.csv,"def countCharacters(words, chars):
    res = 0
    for word in words:
        if all(word.count(c) <= chars.count(c) for c in set(word)):
            res += len(word)
    return res",given array strings words string chars. string good formed characters chars (each character used once). Return sum lengths good strings words.,3,"def countCharacters(words, chars):
    res = 0
    for word in words:
        if all(word.count(c) <= chars.count(c) for c in set(word)):
            res += len(word)
    return res",256
py_good_answer.csv,"
def change_occurrences(string):
    first_char = string[0]
    changed_string = string.replace(first_char, '$')
    return first_char + changed_string[1:]
","Write Python program get string given string occurrences first char changed '$', except first char itself.",3,"def change_occurrences(string):
    first_char = string[0]
    changed_string = string.replace(first_char, '$')
    return first_char + changed_string[1:]
",257
py_1700_data.csv,"def total_strength(strength):
    MOD = 10**9 + 7
    n = len(strength)
    ans = 0
    for i in range(n):
        cur_min = strength[i]
        cur_sum = strength[i]
        for j in range(i+1, n):
            cur_min = min(cur_min, strength[j])
            cur_sum += strength[j]
            ans += cur_min * cur_sum
            ans %= MOD
    return ans","ruler kingdom, army wizards command. given 0-indexed integer array strength, strength[i] denotes strength ith wizard. contiguous group wizards (i.e. wizards' strengths form subarray strength), total strength defined product following two values: strength weakest wizard group. total individual strengths wizards group. Return sum total strengths contiguous groups wizards. Since answer may large, return modulo 109 + 7. subarray contiguous non-empty sequence elements within array.",0,"def total_strength(strength):
    MOD = 10**9 + 7
    n = len(strength)
    ans = 0
    for i in range(n):
        cur_min = strength[i]
        cur_sum = strength[i]
        for j in range(i+1, n):
            cur_min = min(cur_min, strength[j])
            cur_sum += strength[j]
            ans += cur_min * cur_sum
            ans %= MOD
    return ans",258
py_good_answer.csv,"
def remove_words(char, string_list):
    new_list = []
    for string in string_list:
        new_string = string.replace(char, """")
        new_list.append(new_string)
    return new_list
",Write Python program remove words given list strings containing character string.,0,"def remove_words(char, string_list):
    new_list = []
    for string in string_list:
        new_string = string.replace(char, """")
        new_list.append(new_string)
    return new_list
",259
py_1700_data.csv,"
def can_reach_end(s: str, min_jump: int, max_jump: int) -> bool:
    if s[-1] != '0':
        return False
    dp = [False] * len(s)
    dp[0] = True
    for i in range(1, len(s)):
        if s[i] == '0':
            for j in range(max(min_jump, i - max_jump), i):
                if j >= 0 and dp[j]:
                    dp[i] = True
                    break
    return dp[-1]
","given 0-indexed binary string two integers minJump maxJump. beginning, standing index 0, equal '0'. move index index j following conditions fulfilled: + minJump <= j <= min(i + maxJump, s.length - 1), s[j] == '0'. Return true reach index s.length - 1 s, false otherwise.",1,"def can_reach_end(s: str, min_jump: int, max_jump: int) -> bool:
    if s[-1] != '0':
        return False
    dp = [False] * len(s)
    dp[0] = True
    for i in range(1, len(s)):
        if s[i] == '0':
            for j in range(max(min_jump, i - max_jump), i):
                if j >= 0 and dp[j]:
                    dp[i] = True
                    break
    return dp[-1]
",260
py_good_answer.csv,"def add_strings(str1, str2):
    num1 = int(str1)
    num2 = int(str2)
    sum_str = str(num1 + num2)
    return ""The sum of "" + str1 + "" and "" + str2 + "" is "" + sum_str + "".""",Write Python program add two strings numbers (Positive integer values). Return message numbers string.,0,"def add_strings(str1, str2):
    num1 = int(str1)
    num2 = int(str2)
    sum_str = str(num1 + num2)
    return ""The sum of "" + str1 + "" and "" + str2 + "" is "" + sum_str + "".""",261
py_1700_data.csv,"
def get_max_gold(grid):
    def backtrack(i, j, visited):
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0 or (i, j) in visited:
            return 0
        visited.add((i, j))
        gold = grid[i][j]
        max_gold = max(backtrack(i+1, j, visited), backtrack(i-1, j, visited), 
                       backtrack(i, j+1, visited), backtrack(i, j-1, visited))
        visited.remove((i, j))
        return gold + max_gold
    
    max_gold = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] != 0:
                max_gold = max(max_gold, backtrack(i, j, set()))
    return max_gold
","gold mine grid size x n, cell mine integer representing amount gold cell, 0 empty. Return maximum amount gold collect conditions: Every time located cell collect gold cell. position, walk one step left, right, up, down. can't visit cell once. Never visit cell 0 gold. start stop collecting gold position grid gold.",1,"def get_max_gold(grid):
    def backtrack(i, j, visited):
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0 or (i, j) in visited:
            return 0
        visited.add((i, j))
        gold = grid[i][j]
        max_gold = max(backtrack(i+1, j, visited), backtrack(i-1, j, visited), 
                       backtrack(i, j+1, visited), backtrack(i, j-1, visited))
        visited.remove((i, j))
        return gold + max_gold
    max_gold = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] != 0:
                max_gold = max(max_gold, backtrack(i, j, set()))
    return max_gold
",262
py_1700_data.csv,"
def subtreeSize(node, parents, counts):
    counts[node] = 1
    for child in range(len(parents)):
        if parents[child] == node:
            counts[node] += subtreeSize(child, parents, counts)
    return counts[node]

def findScore(node, parents, counts, scores):
    subtreeScore = counts[node]
    for child in range(len(parents)):
        if parents[child] == node:
            subtreeScore += findScore(child, parents, counts, scores)
    scores[node] = subtreeScore
    return scores[node] * counts[0] - subtreeScore**2

def getMaxScoreNode(parents):
    n = len(parents)
    counts = [0] * n
    subtreeSize(0, parents, counts)
    scores = [0] * n
    scores[0] = findScore(0, parents, counts, scores)
    maxScore, maxNode = -1, -1
    for node, score in enumerate(scores):
        if score > maxScore:
            maxScore, maxNode = score, node
    return maxNode
","binary tree rooted 0 consisting n nodes. nodes labeled 0 n - 1. given 0-indexed integer array parents representing tree, parents[i] parent node i. Since node 0 root, parents[0] == -1. node score. find score node, consider node edges connected removed. tree would become one non-empty subtrees. size subtree number nodes it. score node product sizes subtrees. Return number nodes highest score.",0,"def subtreeSize(node, parents, counts):
    counts[node] = 1
    for child in range(len(parents)):
        if parents[child] == node:
            counts[node] += subtreeSize(child, parents, counts)
    return counts[node]
def findScore(node, parents, counts, scores):
    subtreeScore = counts[node]
    for child in range(len(parents)):
        if parents[child] == node:
            subtreeScore += findScore(child, parents, counts, scores)
    scores[node] = subtreeScore
    return scores[node] * counts[0] - subtreeScore**2
def getMaxScoreNode(parents):
    n = len(parents)
    counts = [0] * n
    subtreeSize(0, parents, counts)
    scores = [0] * n
    scores[0] = findScore(0, parents, counts, scores)
    maxScore, maxNode = -1, -1
    for node, score in enumerate(scores):
        if score > maxScore:
            maxScore, maxNode = score, node
    return maxNode
",263
py_1700_data.csv,"class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        res = []
        for hour in range(0, 12):
            for minute in range(0, 60):
                if (bin(hour) + bin(minute)).count('1') == turnedOn:
                    res.append(f""{hour:0>2}:{minute:0>2}"")
        return res","binary watch 4 LEDs top represent hours (0-11), 6 LEDs bottom represent minutes (0-59). LED represents zero one, least significant bit right. example, binary watch reads ""4:51"". Given integer turnedOn represents number LEDs currently (ignoring PM), return possible times watch could represent. may return answer order. hour must contain leading zero. example, ""01:00"" valid. ""1:00"". minute must consist two digits may contain leading zero. example, ""10:2"" valid. ""10:02"".",1,"class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        res = []
        for hour in range(0, 12):
            for minute in range(0, 60):
                if (bin(hour) + bin(minute)).count('1') == turnedOn:
                    res.append(f""{hour:0>2}:{minute:0>2}"")
        return res",264
py_1700_data.csv,"MOD = 10**9 + 7

class Solution:
    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:
        count = [0] * len(nums)
        for start, end in requests:
            count[start] += 1
            if end + 1 < len(nums):
                count[end + 1] -= 1
                
        for i in range(1, len(count)):
            count[i] += count[i-1]
                
        sorted_nums = sorted(nums, reverse=True)
        sorted_count = sorted(count, reverse=True)
        
        ans = 0
        for i in range(len(nums)):
            ans += sorted_nums[i] * sorted_count[i]
            
        return ans % MOD","array integers, nums, array requests requests[i] = [starti, endi]. ith request asks sum nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]. starti endi 0-indexed. Return maximum total sum requests among permutations nums. Since answer may large, return modulo 109 + 7.",0,"MOD = 10**9 + 7
class Solution:
    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:
        count = [0] * len(nums)
        for start, end in requests:
            count[start] += 1
            if end + 1 < len(nums):
                count[end + 1] -= 1
        for i in range(1, len(count)):
            count[i] += count[i-1]
        sorted_nums = sorted(nums, reverse=True)
        sorted_count = sorted(count, reverse=True)
        ans = 0
        for i in range(len(nums)):
            ans += sorted_nums[i] * sorted_count[i]
        return ans % MOD",265
py_1700_data.csv,"def strong_password(password):
    if len(password) >= 6 and len(password) <= 20:
        lowercase = False
        uppercase = False
        digit = False
        repeat = False
        for i in range(len(password)):
            if password[i].islower():
                lowercase = True
            elif password[i].isupper():
                uppercase = True
            elif password[i].isdigit():
                digit = True
            if i < len(password) - 2:
                if password[i] == password[i+1] and password[i+1] == password[i+2]:
                    repeat = True
        steps = 0
        if not lowercase:
            steps += 1
        if not uppercase:
            steps += 1
        if not digit:
            steps += 1
        if repeat:
            for i in range(len(password)-2):
                if password[i] == password[i+1] and password[i+1] == password[i+2]:
                    steps += 1
                    break
        if len(password) + steps < 6:
            steps += 6 - (len(password) + steps)
        return steps
    else:
        steps = 0
        if len(password) < 6:
            steps += 6 - len(password)
        if len(password) > 20:
            steps += len(password) - 20
        return steps","password considered strong conditions met: least 6 characters 20 characters. contains least one lowercase letter, least one uppercase letter, least one digit. contain three repeating characters row (i.e., ""Baaabb0"" weak, ""Baaba0"" strong). Given string password, return minimum number steps required make password strong. password already strong, return 0. one step, can: Insert one character password, Delete one character password, Replace one character password another character.",0,"def strong_password(password):
    if len(password) >= 6 and len(password) <= 20:
        lowercase = False
        uppercase = False
        digit = False
        repeat = False
        for i in range(len(password)):
            if password[i].islower():
                lowercase = True
            elif password[i].isupper():
                uppercase = True
            elif password[i].isdigit():
                digit = True
            if i < len(password) - 2:
                if password[i] == password[i+1] and password[i+1] == password[i+2]:
                    repeat = True
        steps = 0
        if not lowercase:
            steps += 1
        if not uppercase:
            steps += 1
        if not digit:
            steps += 1
        if repeat:
            for i in range(len(password)-2):
                if password[i] == password[i+1] and password[i+1] == password[i+2]:
                    steps += 1
                    break
        if len(password) + steps < 6:
            steps += 6 - (len(password) + steps)
        return steps
    else:
        steps = 0
        if len(password) < 6:
            steps += 6 - len(password)
        if len(password) > 20:
            steps += len(password) - 20
        return steps",266
py_1700_data.csv,"def numSubmatrixSumTarget(matrix: List[List[int]], target: int) -> int:
    n, m = len(matrix), len(matrix[0])
    for i in range(n):
        for j in range(1, m):
            matrix[i][j] += matrix[i][j-1]
    res = 0
    for i in range(m):
        for j in range(i, m):
            preSum = {0: 1}
            cur = 0
            for k in range(n):
                cur += matrix[k][j] - (matrix[k][i-1] if i > 0 else 0)
                res += preSum.get(cur - target, 0)
                preSum[cur] = preSum.get(cur, 0) + 1
    return res","Given matrix target, return number non-empty submatrices sum target. submatrix x1, y1, x2, y2 set cells matrix[x][y] x1 <= x <= x2 y1 <= <= y2. Two submatrices (x1, y1, x2, y2) (x1', y1', x2', y2') different coordinate different: example, x1 != x1'.",3,"def numSubmatrixSumTarget(matrix: List[List[int]], target: int) -> int:
    n, m = len(matrix), len(matrix[0])
    for i in range(n):
        for j in range(1, m):
            matrix[i][j] += matrix[i][j-1]
    res = 0
    for i in range(m):
        for j in range(i, m):
            preSum = {0: 1}
            cur = 0
            for k in range(n):
                cur += matrix[k][j] - (matrix[k][i-1] if i > 0 else 0)
                res += preSum.get(cur - target, 0)
                preSum[cur] = preSum.get(cur, 0) + 1
    return res",267
py_1700_data.csv,"def maximumNumber(num: str, change: List[int]) -> str:
    nums = list(num)
    is_mutated = False
    
    for i in range(len(nums)):
        digit = int(nums[i])
        if change[digit] > digit:
            nums[i] = str(change[digit])
            is_mutated = True
        elif change[digit] == digit:
            continue
        else:
            if is_mutated:
                break
    
    return """".join(nums)","given string num, represents large integer. also given 0-indexed integer array change length 10 maps digit 0-9 another digit. formally, digit maps digit change[d]. may choose mutate single substring num. mutate substring, replace digit num[i] digit maps change (i.e. replace num[i] change[num[i]]). Return string representing largest possible integer mutating (or choosing to) single substring num. substring contiguous sequence characters within string.",3,"def maximumNumber(num: str, change: List[int]) -> str:
    nums = list(num)
    is_mutated = False
    for i in range(len(nums)):
        digit = int(nums[i])
        if change[digit] > digit:
            nums[i] = str(change[digit])
            is_mutated = True
        elif change[digit] == digit:
            continue
        else:
            if is_mutated:
                break
    return """".join(nums)",268
py_1700_data.csv,"class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        sums = {}
        count = 0
        for a in nums1:
            for b in nums2:
                if a + b in sums:
                    sums[a + b] += 1
                else:
                    sums[a + b] = 1
        
        for c in nums3:
            for d in nums4:
                if -c - d in sums:
                    count += sums[-c - d]
        
        return count","Given four integer arrays nums1, nums2, nums3, nums4 length n, return number tuples (i, j, k, l) that: 0 <= i, j, k, l < n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0",3,"class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        sums = {}
        count = 0
        for a in nums1:
            for b in nums2:
                if a + b in sums:
                    sums[a + b] += 1
                else:
                    sums[a + b] = 1
        for c in nums3:
            for d in nums4:
                if -c - d in sums:
                    count += sums[-c - d]
        return count",269
py_1700_data.csv,"def check_line(board, row, col, d_row, d_col, color):
    if board[row][col] == color:
        return False
    for i in range(1, 3):
        r = row + i*d_row
        c = col + i*d_col
        if r < 0 or r > 7 or c < 0 or c > 7 or board[r][c] == '.':
            return False
        if board[r][c] == color:
            return True
    return False

def check_move(board, rMove, cMove, color):
    if board[rMove][cMove] != '.':
        return False
    for d_row, d_col in [(0,1),(1,0),(1,1),(1,-1)]:
        if check_line(board, rMove, cMove, d_row, d_col, color):
            return True
    return False

board = [['.','.','.','.','.','.','.','.'],
         ['.','W','B','B','W','W','W','.'],
         ['.','B','W','W','B','B','B','.'],
         ['.','W','B','W','W','W','B','.'],
         ['.','W','B','W','.','W','B','.'],
         ['.','W','B','B','W','W','B','.'],
         ['.','B','W','W','B','B','B','.'],
         ['.','.','.','.','.','.','.','.']]

print(check_move(board, 3, 5, 'W')) # True
print(check_move(board, 5, 5, 'W')) # False","given 0-indexed 8 x 8 grid board, board[r][c] represents cell (r, c) game board. board, free cells represented '.', white cells represented 'W', black cells represented 'B'. move game consists choosing free cell changing color playing (either white black). However, move legal if, changing it, cell becomes endpoint good line (horizontal, vertical, diagonal). good line line three cells (including endpoints) endpoints line one color, remaining cells middle opposite color (no cells line free). find examples good lines figure below: Given two integers rMove cMove character color representing color playing (white black), return true changing cell (rMove, cMove) color color legal move, false legal.",3,"def check_line(board, row, col, d_row, d_col, color):
    if board[row][col] == color:
        return False
    for i in range(1, 3):
        r = row + i*d_row
        c = col + i*d_col
        if r < 0 or r > 7 or c < 0 or c > 7 or board[r][c] == '.':
            return False
        if board[r][c] == color:
            return True
    return False
def check_move(board, rMove, cMove, color):
    if board[rMove][cMove] != '.':
        return False
    for d_row, d_col in [(0,1),(1,0),(1,1),(1,-1)]:
        if check_line(board, rMove, cMove, d_row, d_col, color):
            return True
    return False
board = [['.','.','.','.','.','.','.','.'],
         ['.','W','B','B','W','W','W','.'],
         ['.','B','W','W','B','B','B','.'],
         ['.','W','B','W','W','W','B','.'],
         ['.','W','B','W','.','W','B','.'],
         ['.','W','B','B','W','W','B','.'],
         ['.','B','W','W','B','B','B','.'],
         ['.','.','.','.','.','.','.','.']]
print(check_move(board, 3, 5, 'W')) 
print(check_move(board, 5, 5, 'W')) ",270
py_1700_data.csv,"from collections import Counter

def maxFrequency(nums: List[int], k: int) -> int:
    freq = Counter(nums)
    max_freq = max(freq.values())
    
    for i in range(len(nums)):
        if k <= 0:
            break
        if freq[nums[i]] != max_freq:
            diff = max_freq - freq[nums[i]]
            if k >= diff:
                freq[nums[i]] = max_freq
                k -= diff
            else:
                freq[nums[i]] += k
                k = 0
    
    return max(freq.values())","frequency element number times occurs array. given integer array nums integer k. one operation, choose index nums increment element index 1. Return maximum possible frequency element performing k operations.",1,"from collections import Counter
def maxFrequency(nums: List[int], k: int) -> int:
    freq = Counter(nums)
    max_freq = max(freq.values())
    for i in range(len(nums)):
        if k <= 0:
            break
        if freq[nums[i]] != max_freq:
            diff = max_freq - freq[nums[i]]
            if k >= diff:
                freq[nums[i]] = max_freq
                k -= diff
            else:
                freq[nums[i]] += k
                k = 0
    return max(freq.values())",271
