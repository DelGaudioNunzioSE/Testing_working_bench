[
  [
    "  def get_kth_substring(s, k):\n    substrings = []\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substrings.append(s[i:j])\n    substrings.sort()\n    return substrings[k-1]"
  ],
  [
    "from fractions import gcd\ndef create_primeNum(N):\n    if N == 1:\n        return 1\n    primeNum = 1\n    for k in range(2, N + 1):\n        if k % 2 == 0 and k!= 2:\n            continue\n        if pow(2, k - 1, k) == 1:\n            primeNum += 1\n    return primeNum\ndef count_coprime_divisors(a, b):\n    g = gcd(a, b)\n    prime_factors = set()\n    i = 2\n    while i * i <= g:\n        if g % i:\n            i += 1\n        else:\n            g //= i\n            prime_factors.add(i)\n    if g > 1:\n        prime_factors.add(g)\n    return len(prime_factors)\nif __name__ == \"__main__\":\n    a, b = map(int, input().split())\n    print(count_coprime_divisors(a, b))"
  ],
  [
    "  import string\ndef find_smallest_letter(s):\n    letters = string.ascii_lowercase\n    for letter in letters:\n        if letter not in s:\n            return letter\n    return None\nif __name__ == \"__main__\":\n    s = input()\n    print(find_smallest_letter(s))"
  ],
  [
    "N, C = map(int, input().split())\nX, V = [], []\nfor i in range(N):\n    x, v = map(int, input().split())\n    X.append(x)\n    V.append(v)\nXa, Xb = [X[0]] + [0] * (N - 1), [0] * (N - 1) + [C - X[N - 1]]\nfor i in range(1, N):\n    Xa[i] = X[i] - X[i - 1]\nfor i in range(N - 1):\n    Xb[N - 2 - i] = X[N - 1 - i] - X[N - 2 - i]\nPoint1, Point2 = [], []\npoint = 0\nfor i in range(N):\n    point = point - Xa[i] + V[i]\n    Point1.append(point)\npoint = 0\nfor i in range(N):\n    point = point - Xb[N - 1 - i] + V[N - 1 - i]\n    Point2.append(point)\nN1, N2 = [], []\nif Point1[0] > Point1[1]:\n    N1.append(0)\nfor i in range(1, N - 1):\n    if Point1[i + 1] < Point1[i] and Point1[i - 1] < Point1[i]:\n        N1.append(i)\nif Point1[N - 1] == max(Point1):\n    N1.append(N - 1)\nif Point2[0] > Point2[1]:\n    N2.append(0)\nfor i in range(1, N - 1):\n    if Point2[i + 1] < Point2[i] and Point2[i - 1] < Point2[i]:\n        N2.append(i)\nif Point2[N - 1] == max(Point2):\n    N2.append(N - 1)\nAns = 0\nfor i in N1:\n    point = Point1[i]\n    Ans = max(Ans, point)\n    point -= X[i]\n    for j in N2:\n        if j < N - 1 - i:\n            point += Point2[j]\n            Ans = max(Ans, point)\nfor i in N2:\n    point = Point2[i]\n    Ans = max(Ans, point)\n    point -= (C - X[N - 1 - i])\n    for j in N1:\n        if j < N - 1 - i:\n            point += Point1[j]\n            Ans = max(Ans, point)\nprint(Ans)"
  ],
  [
    "h, w = map(int, input().split())\na = {}\nfor i in range(26):\n    a[chr(i + 97)] = 0\nfor i in range(h):\n    s = input()\n    for j in s:\n        a[j] += 1\nif h == 1 and w == 1:\n    print(\"Yes\")\nelif h == 1 or w == 1:\n    cnt = 0\n    for i in a.values():\n        if i % 2 == 1:\n            cnt += 1\n    if cnt > 1:\n        print(\"No\")\n    else:\n        print(\"Yes\")\nelif h % 2 == 0 and w % 2 == 0:\n    for i in a.values():\n        if i % 4!= 0:\n            print(\"No\")\n            exit()\n    print(\"Yes\")\nelif h % 2 == 1 and w % 2 == 0:\n    cnt = 0\n    for i in a.values():\n        if i % 4 == 1 or i % 4 == 3:\n            print(\"No\")\n            exit()\n        if i % 4 == 2:\n            cnt += 1\n    if cnt > w // 2:\n        print(\"No\")\n    else:\n        print(\"Yes\")\nelif h % 2 == 0 and w % 2 == 1:\n    cnt = 0\n    for i in a.values():\n        if i % 4 == 1 or i % 4 == 3:\n            print(\"No\")\n            exit()\n        if i % 4 == 2:\n            cnt += 1\n    if cnt > h // 2:\n        print(\"No\")\n    else:\n        print(\"Yes\")\nelse:\n    cnt3 = 0\n    cnt2 = 0\n    cnt1 = 0\n    for i in a.values():\n        if i % 4 == 1:\n            cnt1 += 1\n        elif i % 4 == 2:\n            cnt2 += 1\n        elif i % 4 == 3:\n            cnt3 += 1\n    rem = 1 - cnt1\n    if cnt1 + cnt3!= 1:\n        print(\"No\")\n    elif cnt2 + cnt3 - rem > (h - 1) // 2 + (w - 1) // 2:\n        print(\"No\")\n    else:\n        print(\"Yes\")"
  ],
  [
    "N, M = map(int, input().split())\nAB = [list(map(int, input().split())) for _ in range(N)]\nAB.sort(key=lambda x: x[0])\ndp = [0] * (M + 1)\nfor i in range(N):\n    a, b = AB[i]\n    for j in range(M, a - 1, -1):\n        dp[j] = max(dp[j], dp[j - a] + b)\nprint(dp[M])"
  ],
  [
    "n, k = map(int, input().split())\na = list(map(int, input().split()))\nfor _ in range(k):\n    b = [0] * (n + 1)\n    for i in range(n):\n        left = max(1, i - a[i])\n        right = min(n + 1, i + a[i] + 1)\n        for j in range(left, right):\n            b[j] += 1\n    a = b[1:]\nprint(*a)"
  ],
  [
    "s = input()\ndef cal(n):\n    if len(s) == 1:\n        return 0\n    else:\n        new = s[0]\n        ans = 0\n        cnt = 0\n        for i in range(1, n):\n            if s[i] != new:\n                new = s[i]\n                cnt = 0\n                ans += (i + 1)\n            else:\n                cnt += 1\n                ans += cnt\n        return ans"
  ],
  [
    "def main():\n    n, k, s = map(int, input().split())\n    ans = [str(s)] * k + [str(s + 1)] * (n - k)\n    print(' '.join(ans))\nif __name__ == '__main__':\n    main()"
  ],
  [
    "A, B = map(int, input().split())\ncount = 0\nfor num in range(A, B + 1):\n    num_str = str(num)\n    if num_str == num_str[::-1]:\n        count += 1\nprint(count)\n"
  ],
  [
    "X, Y = map(int, input().split())\nif X % Y == 0:\n    print(-1)\nelse:\n    print(X)\n"
  ],
  [
    "import math\ns = input().rstrip()\nalpha = set()\nfor i in range(len(s)):\n  alpha.add(s[i])\nif len(alpha) == len(s):\n  print(math.ceil(len(s)//2))\nelif len(alpha) == 1:\n  print(0)\nelse:\n  freq = 1\n  for j in range(1,len(s)-1):\n    if freq < s.count(s[j]):\n      freq = s.count(s[j])\n  targets = set()\n  for z in range(1,len(s)-1):\n    if s.count(s[z]) == freq:\n      targets.add(s[z])\n  mincount = 10**12\n  for X in targets:\n    tmp = list(s)\n    count = 0\n    while len(set(tmp)) > 1:\n      count += 1\n      work = []\n      for k in range(len(tmp)-1):\n        if tmp[k] == X or tmp[k+1] == X:\n          work.append(X)\n        else:\n          work.append(tmp[k])\n      tmp = work\n    mincount = min(count,mincount)    \n  print(mincount)"
  ],
  [
    "a, b = map(int, input().split())\ndiff = b - a\ndef func(x):\n    if x == 0:\n        return 0\n    else:\n        return x + func(x - 1)\nprint(func(diff) - b)"
  ],
  [
    "a, b, c = map(int, input().split())\nprint(min(a + b, a + c, b + c))\n"
  ],
  [
    "import sys\nN, M = map(int, input().split())\ngrid = []\nfor i in range(N):\n    array = list(map(int, input().strip().split(' ')))\n    grid.append(array)\npre = []\npos = []\nfor ships in grid:\n    if ships[0] == 1:\n        pre.append(ships[1])\n    if ships[1] == N:\n        pos.append(ships[0])\npre.sort()\nfor islands in pre:\n    if islands in pos:\n        print('POSSIBLE')\n        sys.exit()\nprint('IMPOSSIBLE')"
  ],
  [
    "MOD = 10**9 + 7\ns = input()\nn = len(s)\na_cnt = [0] * (n + 1)\nb_cnt = [0] * (n + 1)\nc_cnt = [0] * (n + 1)\nfor i in range(n):\n    if s[i] == 'A':\n        a_cnt[i + 1] = a_cnt[i] + 1\n    else:\n        a_cnt[i + 1] = a_cnt[i]\n    if s[i] == 'B':\n        b_cnt[i + 1] = b_cnt[i] + 1\n    else:\n        b_cnt[i + 1] = b_cnt[i]\n    if s[i] == 'C':\n        c_cnt[i + 1] = c_cnt[i] + 1\n    else:\n        c_cnt[i + 1] = c_cnt[i]\nans = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        for k in range(j + 1, n + 1):\n            if s[i] == '?' and s[j] == '?' and s[k - 1] == '?':\n                ans += (a_cnt[i] * b_cnt[j] * c_cnt[k]) % MOD\n            elif s[i] == '?' and s[j] == '?':\n                if s[k - 1] == 'A':\n                    ans += (a_cnt[i] * b_cnt[j] * (c_cnt[k] - c_cnt[k - 1])) % MOD\n                elif s[k - 1] == 'B':\n                    ans += ((a_cnt[i] * (b_cnt[j] - b_cnt[j - 1])) * c_cnt[k]) % MOD\n                elif s[k - 1] == 'C':\n                    ans += (a_cnt[i] * b_cnt[j] * (c_cnt[k] - c_cnt[k - 1])) % MOD\n            elif s[i] == '?':\n                if s[j] == 'A':\n                    if s[k - 1] == 'B':\n                        ans += (a_cnt[i] * (b_cnt[j] - b_cnt[j - 1]) * (c_cnt[k] - c_cnt[k - 1])) % MOD\n                    elif s[k - 1] == 'C':\n                        ans += (a_cnt[i] * (b_cnt[j] - b_cnt[j - 1]) * (c_cnt[k] - c_cnt[k - 1])) % MOD\n                elif s[j] == 'B':\n                    if s[k - 1] == 'C':\n                        ans += ((a_cnt[i] - a_cnt[i - 1]) * (b_cnt[j] - b_cnt[j - 1]) * (c_cnt[k] - c_cnt[k - 1])) % MOD\n                elif s[j] == 'C':\n                    if s[k - 1] == 'A':\n                        ans += ((a_cnt[i] - a_cnt[i - 1]) * (b_cnt[j] - b_cnt[j - 1]) * (c_cnt[k] - c_cnt[k - 1])) % MOD\n            elif s[j] == '?':\n                if s[i] == 'A':\n                    if s[k - 1] == 'B':\n                        ans += ((a_cnt[i] - a_cnt[i - 1]) * (b_cnt[j] - b_cnt[j - 1]) * (c_cnt[k] - c_cnt[k - 1])) % MOD\n                    elif s[k - 1] == 'C':\n                        ans += ((a_cnt[i] - a_cnt[i - 1]) * (b_cnt[j] - b_cnt[j - 1]) * (c_cnt[k] - c_cnt[k - 1])) % MOD\n                elif s[i] == 'B':\n                    if s[k - 1] == 'C':\n                        ans += ((a_cnt[i] - a_cnt[i - 1]) * (b_cnt[j] - b_cnt[j - 1]) * (c_cnt[k] - c_cnt[k - 1])) % MOD\n                elif s[i] == 'C':\n                    if s[k - 1] == 'A':\n                        ans += ((a_cnt[i] - a_cnt[i - 1]) * (b_cnt[j] - b_cnt[j - 1]) * (c_cnt[k] - c_cnt[k - 1])) % MOD\n            elif s[k - 1] == '?':\n                if s[i] == 'A':\n                    if s[j] == 'B':\n                        ans += ((a_cnt[i] - a_cnt[i - 1]) * (b_cnt[j] - b_cnt[j - 1]) * (c_cnt[k] - c_cnt[k - 1])) % MOD\n                    elif s[j] == 'C':\n                        ans += ((a_cnt[i] - a_cnt[i - 1]) * (b_cnt[j] - b_cnt[j - 1]) * (c_cnt[k] - c_cnt[k - 1])) % MOD\n                elif s[i] == 'B':\n                    if s[j] == 'C':\n                        ans += ((a_cnt[i] - a_cnt[i - 1]) * (b_cnt[j] - b_cnt[j - 1]) * (c_cnt[k] - c_cnt[k - 1])) % MOD\n                elif s[i] == 'C':\n                    if s[j] == 'A':\n                        ans += ((a_cnt[i] - a_cnt[i - 1]) * (b_cnt[j] - b_cnt[j - 1]) * (c_cnt[k] - c_cnt[k - 1])) % MOD\n            else:\n                if s[i] == 'A' and s[j] == 'B' and s[k - 1] == 'C':\n                    ans += ((a_cnt[i] - a_cnt[i - 1]) * (b_cnt[j] - b_cnt[j - 1]) * (c_cnt[k] - c_cnt[k - 1])) % MOD\nprint(ans)\n"
  ],
  [
    "N = int(input())\ncount = 0\nfor K in range(2, N + 1):\n    temp = N\n    while temp >= K:\n        if temp % K == 0:\n            temp = temp // K\n        else:\n            temp = temp - K\n        if temp == 1:\n            count += 1\n            break\nprint(count)\n"
  ],
  [
    "X = int(input())\nyear = 0\nbalance = 100\nwhile balance < X:\n  balance = int(balance * 1.01)\n  year += 1\nprint(year)\n"
  ],
  [
    "number_of_elements = int(input())\nelements = list(map(int, input().split()))\nxor_sum = 0\nfor element in elements:\n    xor_sum ^= element\nif xor_sum == 0:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n"
  ],
  [
    "n = int(input())\nsquares = list(map(int, input().split(\" \")))\nodd = 0\nfor i in range(1, n + 1, 2):\n  if squares[i - 1] % 2 == 1:\n    odd += 1\nprint(odd)"
  ],
  [
    "import sys\nfrom collections import defaultdict\nreadline=sys.stdin.readline\nread=sys.stdin.read\ndef main():\n    n=int(readline())\n    a=[list(map(int,sys.stdin.readline().split())) for _ in range(n)]\n    wts=dict(((i,j),a[i][j]) for i in range(n) for j in range(n))\n    cost=defaultdict(int)\n    cost.update(wts)\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                cost[(i,j)]=min(cost[(i,j)],cost[(i,k)]+cost[(k,j)])\n    edges=[e for e in wts.keys() if e[0]<e[1]]\n    edges.sort(key=wts.get,reverse=True)\n    s=0\n    for e in edges:\n        if cost[e]<wts[e]:\n            print(-1)\n            return None\n        detour=min([cost[(e[0],i)]+cost[(i,e[1])] for i in range(n) if i!=e[0] and i!=e[1]])\n        if detour>=cost[e]:\n            s+=wts[e]\n    print(s)\nif __name__=='__main__':\n    main()"
  ],
  [
    "  from typing import List\ndef min_colors(arr: List[int]) -> int:\n    arr.sort()\n    colors = 1\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            colors += 1\n    return colors\ndef main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(min_colors(arr))\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "N, A, B = map(int, input().split())\nprint(min(A, B), max(0, A + B - N))"
  ],
  [
    "N = int(input())\nA = []\nB = []\ntotal_add = 0\nfor _ in range(N):\n    a, b = map(int, input().split())\n    A.append(a)\n    B.append(b)\nans = 0\ninc = 0\nfor i in range(N):\n    a = A[i]\n    b = B[i]\n    a += inc\n    if a % b!= 0:\n        inc += b - a % b\n    ans += inc\nprint(ans)"
  ],
  [
    "N = int(input())\nif (N < 10) or (N % 2 != 0):\n    print(0)\ndef calc(N):\n    S = str(N)\n    cnt = 0\n    for x in S:\n        if(x == \"0\"):\n            cnt +=1\n    return cnt\nnumber = 0\nplus = 10\nwhile N >= 10:\n    if(N / 10 >= 10):\n        number += plus\n        plus *= 10\n    N = N // 10\nprint(number+int(N))"
  ],
  [
    "A,B,N = map(int,input().split())\nm=0\nif B<N:\n    N=B\ns=int(B/A)\nif s>N:\n    print(0)\n    exit()\nfor x in range(s,N+1,s):\n    num=int(A*x/B) - A * int(x/B)\n    m=max(num,m)\nprint(m)"
  ],
  [
    "  def count_ways(N, P, A):\n    MOD = 10**9 + 7\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for i in range(N):\n        for j in range(A[i], N + 1):\n            dp[j] += dp[j - A[i]]\n            dp[j] %= MOD\n    return dp[N] if P == 0 else MOD - dp[N] - 1\nN, P = map(int, input().split())\nA = list(map(int, input().split()))\nprint(count_ways(N, P, A))"
  ],
  [
    "N, A, B = map(int, input().split())\nX = list(map(int, input().split()))\nres = 0\nfor i in range(N - 1):\n  res += min(A * (X[i + 1] - X[i]), B)\nprint(res)"
  ],
  [
    "import numpy as np\nN, M, X = map(int, input().split())\nC = []\nfor _ in range(N):\n    C.append(list(map(int, input().split())))\nC_np = np.array(C)\nif np.sum(C_np, axis=0)[1:] < X:\n    print(-1)\n    exit()\nelse:\n    for i in C_np:\n        pass"
  ],
  [
    "lst=[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\nmoji = str(input())\nans = None\nfor i in range(26):\n  if lst[i] not in moji:\n    ans = lst[i]\n    break\nprint(ans)"
  ],
  [
    "  def count_final_sequences(colors):\n    n = len(colors)\n    dp = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i):\n            if colors[j] == colors[i]:\n                dp[i] += dp[j]\n                dp[i] %= 1000000007\n    return dp[n]\ndef main():\n    n = int(input())\n    colors = list(map(int, input().split()))\n    print(count_final_sequences(colors))\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "N = int(input())\nMAX = N\ncheck = [0]\npre = 0\nfor i in range(1, MAX+1):\n    pre += i\n    if pre <= MAX:\n        check.append(pre)\n    else:\n        break\nlen_ = len(check)\nfor i in range(len_, 0, -1):\n    if N >= i:\n        N -= i\n        print(i)"
  ],
  [
    "K = int(input())\nS = str(input())\nmod = pow(10, 9) + 7\nn_ = 2 * pow(10, 6) + 1\nfun = [1] * (n_+1)\nfor i in range(1, n_+1):\n    fun[i] = fun[i-1] * i % mod\nrev = [1] * (n_+1)\nrev[n_] = pow(fun[n_], mod-2, mod)\nfor i in range(n_-1, 0, -1):\n    rev[i] = rev[i+1] * (i+1) % mod\ndef cmb(n,r):\n    if n <= 0 or r < 0 or r > n: return 0\n    return fun[n] * rev[r] % mod * rev[n-r] % mod\nN = len(S)\nanswer = 0\nfor i in range(K+1):\n    answer += pow(25, i, mod) * pow(26, K-i, mod) * cmb(N+i, N) % mod\nprint(answer % mod)"
  ],
  [
    "from functools import reduce\nfrom operator import and_\nN = int(input())\nans = reduce(and_, [(i%3==0) or (i%5==0) for i in map(int,input().split()) if i%2==0])\nprint(\"APPROVED\" if ans else \"DENIED\")"
  ],
  [
    "X, Y = map(int, input().split())\na = 0\nif X == 1:\n  a += 300000\nelif X == 2:\n  a += 200000\nelif X == 3:\n  a += 100000\nif Y == 1:\n  a += 300000\nelif Y == 2:\n  a += 200000\nelif Y == 3:\n  a += 100000\nif X == 1 and Y == 1:\n  a += 400000\nprint(a)\n```"
  ],
  [
    "import sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10**7)\ndef input():\n    return sys.stdin.readline()[:-1]\nmod = 10**9 + 7\ndef I(): return int(input())\ndef II(): return map(int, input().split())\ndef III(): return list(map(int, input().split()))\ndef Line(N):\n    read_all = [tuple(map(int, input().split())) for _ in range(N)]\n    return map(list,zip(*read_all))\nH,W = II()\na = [III() for _ in range(H)]\nnum = 0\nmove = []\nfor i in range(H):\n    for j in range(W-1):\n        if a[i][j]%2==1:\n            num += 1\n            move.append([i+1,j+1,i+1,j+2])\nfor i in range(H-1):\n    if a[i][W-1]%2==1:\n        num += 1\n        move.append([i+1,W,i+2,W])\nprint(num)\nfor i in move:\n    print(*i, sep=' ')"
  ],
  [
    "from collections import defaultdict\nfrom math import gcd\nMOD = 10**9 + 7\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    g = a[0]\n    for i in range(1, n):\n        g = gcd(g, a[i])\n    for i in range(n):\n        a[i] //= g\n    freq = defaultdict(int)\n    for i in range(n):\n        freq[a[i]] += 1\n    ans = 0\n    for k, v in freq.items():\n        ans = (ans + k * pow(v, MOD - 2, MOD)) % MOD\n    print(ans)\nsolve()\n"
  ],
  [
    "from scipy.sparse.csgraph import bellman_ford\nfrom scipy.sparse import csr_matrix\nimport numpy as np\nn, m = map(int, input().split())\nabc = [list(map(int, input().split())) for _ in range(m)]\nadj = [[] for _ in range(n)]\nfor a, b, c in abc:\n\ta -= 1\n\tb -= 1\n\tadj[a].append([b, -c])\ng = [[np.inf] * n for _ in range(n)]\ndef dfs(s):\n\tstack = [s]\n\tpassed = [0] * n\n\tpassed[s] = 1\n\twhile stack:\n\t\tu = stack.pop()\n\t\tfor v, c in adj[u]:\n\t\t\tif passed[v] == 0:\n\t\t\t\tpassed[v] = 1\n\t\t\t\tstack.append(v)\n\t\t\tg[u][v] = c\n\treturn passed\nconnected = dfs(0)\nconnected_nodes = [i for i, e in enumerate(connected) if e]\nnew = [-1] * n\nfor i, e in enumerate(connected_nodes):\n\tnew[e] = i\nl = len(connected_nodes)\ng2 = [[np.inf] * l for _ in range(l)]\nfor i, e in enumerate(connected_nodes):\n\tfor j, c in enumerate(g[e]):\n\t\tif new[j] != -1:\n\t\t\tg2[i][new[j]] = c\ntry:\n\tgraph = csr_matrix(g2)\n\tdist = bellman_ford(graph, indices=0)\n\tans = -int(dist[new[n-1]])\n\tprint(ans)\nexcept:\n\tprint(\"inf\")"
  ],
  [
    "from heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, Counter\nimport itertools\nfrom itertools import permutations, combinations, accumulate\nimport sys\nimport bisect\nimport string\nimport math\nimport time\ndef I(): return int(input())\ndef S(): return input()\ndef MI(): return map(int, input().split())\ndef MS(): return map(str, input().split())\ndef LI(): return [int(i) for i in input().split()]\ndef LI_(): return [int(i)-1 for i in input().split()]\ndef StoI(): return [ord(i)-97 for i in input()]\ndef ItoS(nn): return chr(nn+97)\ndef input(): return sys.stdin.readline().rstrip()\ndef show(*inp, end='\\n'):\n    if show_flg:\n        print(*inp, end=end)\nYNL = {False: 'No', True: 'Yes'}\nYNU = {False: 'NO', True: 'YES'}\nMOD = 10**9+7\ninf = float('inf')\nIINF = 10**10\nl_alp = string.ascii_lowercase\nu_alp = string.ascii_uppercase\nts = time.time()\nsys.setrecursionlimit(10**6)\nnums = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']\nshow_flg = False\ndef base_10_to_n(X, n):\n    if int(X / n):\n        return base_10_to_n(int(X/n), n) + str(X % n)\n    return str(X % n)\ndef main():\n    A = I()\n    for i in range(2, 10000+1):\n        if str(i) == base_10_to_n(A, i):\n            print(i)\n            return\n    print(-1)\nif __name__ == '__main__':\n    main()"
  ],
  [
    "import heapq\nX, Y, A, B, C = map(int, input().split())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\nR = list(map(int, input().split()))\nP.sort(reverse=True)\nQ.sort(reverse=True)\nP = sorted(P[:X])\nQ = sorted(Q[:Y])\nR.sort()\nwhile R and (P[0] < R[-1] or Q[0] < R[-1]):\n    if P[0] < Q[-1]:\n        heapq.heappush(P, R.pop())\n        heapq.heappop(P)\n    else:\n        heapq.heappush(Q, R.pop())\n        heapq.heappop(Q)\nprint(sum(P) + sum(Q))"
  ],
  [
    "N = int(input())\nA = list(map(int,input().split()))\nfor i in range(N-1):\n    if A[i] + A[i+1] < -1 * (A[i] + A[i+1]):\n        A[i] = A[i] * -1\n        A[i+1] = A[i+1] * -1\nsum(A)"
  ],
  [
    "from scipy.special import comb\nN, K = map(int, input().split())\nA = [int(x) for x in input().split()]\nA.sort()\nres = 0\nMOD = 10**9+7\nnCk_2 = dict()\nfor k in range(K-2,N):\n    nCk_2[k] = int(comb(k, K-2))%MOD\nfor i in range(N):\n    for j in range(N):\n        if N-i-j >= K:\n            res += int((A[N-1-j]-A[i])*nCk_2[N-j-2-i]%MOD)\n        if N-1-j < i:\n            break\nprint(res%MOD)"
  ],
  [
    "import copy, sys\nn = int(input())\na_ls = list(map(int, input().split()))\nb_ls = []\nfor i in range(n-1):\n    if a_ls[i] != a_ls[i+1]:\n        b_ls.append(a_ls[i])\nif a_ls[-1] != a_ls[-2]:\n    b_ls.append(a_ls[-1])\nif not b_ls:\n    print(1000)\n    sys.exit()\nc_ls = [b_ls[0]]\nfor i in range(1,len(b_ls)-1):\n    if not (b_ls[i-1] < b_ls[i] < b_ls[i+1] or b_ls[i-1] > b_ls[i] > b_ls[i+1]):\n        c_ls.append(b_ls[i])\nc_ls.append(b_ls[-1])\nmoney = 1000\nstock = 0\nm = len(c_ls)\nfor i in range(m-1):\n    if c_ls[i] < c_ls[i+1]:\n        money += c_ls[i] * stock\n        stock = 0 \n    else:  \n        if money > 0:\n            stock, money = divmod(money, c_ls[i])\nif len(c_ls) > 1 and c_ls[-1] > c_ls[-2]:\n    money += c_ls[-1] * stock\nprint(money)"
  ],
  [
    "def euclid(x, y):\n    while x % y!= 0:\n        temp = x\n        x = y\n        y = temp % y\n    return y\nn = int(input())\ndata = list(map(int, input().split()))\nmax_gcd = 0\nfor i in range(n):\n    array = data[:i] + data[i+1:]\n    array.append(1)\n    x = array[0]\n    for j in array:\n        x = euclid(x, j)\n    if x > max_gcd:\n        max_gcd = x\nprint(max_gcd)"
  ],
  [
    "import sys\ndef query(i):\n    print(i, flush=True)\n    return input()\ndef find_empty_seat(n):\n    i = 0\n    while True:\n        response = query(i)\n        if response == \"Vacant\":\n            return i\n        elif response == \"Male\":\n            i = (i + 2) % n\n        else:\n            i = (i + 1) % n\nn = int(input())\nempty_seat = find_empty_seat(n)\nprint(empty_seat)\n"
  ],
  [
    "N, M = map(int, input().split())\nAB = [list(map(int, input().split())) for _ in range(N)]\nAB.sort(key=lambda x: x[0])\ndp = [0] * (M + 1)\nfor i in range(N):\n    a, b = AB[i]\n    for j in range(M, a - 1, -1):\n        dp[j] = max(dp[j], dp[j - a] + b)\nprint(dp[M])"
  ],
  [
    "N = int(input())\nl = []\nfor i in range(N):\n  x = input()\n  l.append(x)\ns = len(set(l))\nprint(s)"
  ],
  [
    "S = input()\nal = 'abcdefghijklmnopqrstuvwxyz'\nfor i in al:\n  if i not in S:\n    print(i)\n    break\nelse:\n  print(\"None\")"
  ],
  [
    "import itertools\nn, m = map(int, input().split())\ncakes = []\nfor i in range(n):\n    x, y, z = map(int, input().split())\n    cakes.append((x, y, z))\nmax_value = 0\nfor combination in itertools.combinations(cakes, m):\n    total_beauty = sum(x for x, y, z in combination)\n    total_tastiness = sum(y for x, y, z in combination)\n    total_popularity = sum(z for x, y, z in combination)\n    current_value = abs(total_beauty) + abs(total_tastiness) + abs(total_popularity)\n    max_value = max(max_value, current_value)\nprint(max_value)\n"
  ],
  [
    "x, a, b = map(int, input().split())\ncloser_store = 'A' if abs(x - a) < abs(x - b) else 'B'\nprint(closer_store)\n"
  ],
  [
    "n = int(input())\na = list(map(int, input().split()))\nans = 0\nfor i in range(n):\n  ans += abs(a[i] - (i + 1))\nprint(ans)\n"
  ],
  [
    "def index_bin(l, x):\n    n = len(l)\n    b = 0\n    e = n\n    while(b != e):\n        if x > l[(b+e)//2]:\n            b = (b+e)//2 + 1\n        else:\n            e = (b+e)//2\n    return b\nN, M = map(int, input().split())\nP = []\nY = []\nPY = [[] for _ in range(N)]\nfor i in range(M):\n    p, y = map(int, input().split())\n    P.append(p)\n    Y.append(y)\n    PY[p-1].append(y)\nfor i in range(N):\n    PY[i].sort()\nfor i in range(M):\n    x = index_bin(PY[P[i]-1], Y[i]) + 1\n    print(\"%06d%06d\" % (P[i], x))"
  ],
  [
    "import math\nS = int(input())\na = int(math.sqrt(2 * S) * 2)\nb = int(math.sqrt(a * a - 4 * S))\nX1 = (a + b) // 2\nY1 = 0\nX2 = (a - b) // 2\nY2 = a\nX3 = 0\nY3 = 0\nprint(X1, Y1, X2, Y2, X3, Y3)\n"
  ],
  [
    "import sys\nans = 0\nall_list = [input().split() for l in sys.stdin]\nnumOfFavoritesList = [int(x[0]) for x in all_list]\ntarget_idx = numOfFavoritesList.index(min(numOfFavoritesList))\nfor checkedFavorite in all_list[target_idx][1:]:\n  sumNum = sum([int(x) for x in all_list[i][1:] if int(x) == int(checkedFavorite) for i in range(len(all_list))])\n  if sumNum == len(numOfFavoritesList):\n    ans = ans + 1\nprint(ans)"
  ],
  [
    "from math import gcd\ndef count_coprime_divisors(a, b):\n    g = gcd(a, b)\n    count = 0\n    for i in range(1, int(g**0.5) + 1):\n        if g % i == 0:\n            if gcd(i, g // i) == 1:\n                count += 2\n            elif i == g // i:\n                count += 1\n    return count\nA, B = map(int, input().split())\nprint(count_coprime_divisors(A, B))\n"
  ],
  [
    "S = input()\nw = int(input())\nprint(''.join([S[i] for i in range(0, len(S), w)]))\n"
  ],
  [
    "MODULO = 10**9 + 7\ndef main():\n    number_of_elements, kth_element = map(int, input().split())\n    elements = sorted(map(int, input().split()))\n    factorial = [1]\n    for i in range(1, number_of_elements + 1):\n        factorial.append(factorial[-1] * i % MODULO)\n    inverse_factorial = [1]\n    for i in range(1, number_of_elements + 1):\n        inverse_factorial.append(pow(factorial[i], MODULO - 2, MODULO))\n    def nCr(n, r):\n        return factorial[n] * inverse_factorial[r] * inverse_factorial[n - r] % MODULO\n    result = 0\n    for i in range(kth_element - 1, number_of_elements):\n        result += elements[i] * nCr(i, kth_element - 1)\n        result -= elements[i - kth_element + 1] * nCr(i + 1, kth_element)\n        result %= MODULO\n    print(result)\nif __name__ == \"__main__\":\n    main()\n"
  ],
  [
    "n = int(input())\nv = list(map(int, input().split()))\nc = list(map(int, input().split()))\nans = 0\nfor i in range(1 << n):\n  x = 0\n  y = 0\n  for j in range(n):\n    if (i >> j) & 1:\n      x += v[j]\n      y += c[j]\n  ans = max(ans, x - y)\nprint(ans)\n"
  ],
  [
    "def solve(n):\n    problems = []\n    for i in range(1, n + 1):\n        if i % n == 0:\n            problems.append(i)\n    return problems\n"
  ],
  [
    "from bisect import bisect\nn=int(input())\na=[0]*n\nfor i in range(n):\n   a[i]=int(input())\ndef loopa():\n    n=len(a)\n    dp = [10**10]*(n+1)\n    dp[0] = -1\n    dq = [0]*(n+1)    \n    for i in range(n):\n        idx = bisect(dp, a[i]-1)\n        if dp[idx]==10**10:\n            if dp[idx]>a[i]:\n                dp[idx]=a[i]\n                dq[idx]=i\n            dp2=dp[1:idx+1]\n            dq2=dq[1:idx+1]\n        else:\n            if dp[idx]>a[i]:\n                dp[idx]=a[i]\n                dq[idx]=i\n    for i in range(len(dq2)-1,-1,-1):\n        del a[dq2[i]]\nicnt=0\nwhile len(a)>0:\n    loopa()        \n    icnt+=1\nprint(icnt)"
  ],
  [
    "def main():\n  n, r = map(int,input().split())\n  if n < 10:\n    return r + 100 * (10 - n)\n  else:\n    return r"
  ],
  [
    "s = input()\nstr_list = list(s)\nfor i in range(len(str_list)):\n    if str_list[i] == '?':\n        if i > 0 and str_list[i-1] == 'P':\n            str_list[i] = 'D'\n        elif i < len(str_list) - 1 and str_list[i+1] == 'D':\n            str_list[i] = 'P'\n        elif i > 0 and str_list[i-1] == 'D':\n            str_list[i] = 'P'\n        else:\n            str_list[i] = 'D'\nstr_changed = \"\".join(str_list)\nprint(str_changed)"
  ],
  [
    "S = input()\nn = len(S)\nans = 0\nfor bit in range(1 << (n-1)):\n  f = S[0]\n  for i in range(n-1):\n    if bit & (1 << i):\n      f += \"+\"\n    f += S[i+1]\n  ans += sum(map(int,f.split(\"+\")))\nprint(ans)"
  ],
  [
    "n, m, x = map(int, input().split())\nprace = []\nknow = []\nfor i in range(n):\n    acc = list(map(int, input().split()))\n    prace.append(acc[0])\n    know.append(acc[1:])\nans = 10**10\nfor i in range(2**n):\n    und = [0 for _ in range(m)]\n    f = \"{:b}\".format(i)\n    s = f.zfill(n)\n    mm = 0\n    for j in range(len(s)):\n        if s[j] == '1':\n            for k in range(m):\n                und[k] += know[j][k]\n            mm += prace[j]\n    if all(u >= x for u in und):\n        ans = min(ans, mm)\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)"
  ],
  [
    "def primes(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = False\n    is_prime[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if not is_prime[i]:\n            continue\n        for j in range(i * 2, n + 1, i):\n            is_prime[j] = False\n    return [i for i in range(n + 1) if is_prime[i]], is_prime\nli_p, is_prime = primes(10 ** 5 + 1)\nfor i in li_p:\n    if is_prime[(i + 1) // 2]:\n        is_prime[i] = False\nres = [0] * (10 ** 5 + 1)\nfor i in range(10 ** 5 + 1):\n    if i == 0:\n        continue\n    if is_prime[i]:\n        res[i] = res[i - 1] + 1\n    else:\n        res[i] = res[i - 1]\nq = int(input())\nfor _ in range(q):\n    l, r = map(int, input().split())\n    if l > 0:\n        print(res[r] - res[l - 1])\n    else:\n        print(res[r])"
  ],
  [
    "x,a,b=map(int,input().split())\nprint('delicious' if 0<=(b-a)<=x else 'dangerous' if x<(b-a) else'safe')"
  ],
  [
    "N,C = map(int,input().split())\nX = []\nV = []\nfor _ in range(N):\n    x,v = map(int,input().split())\n    X.append(x)\n    V.append(v)\nA = [0 for _ in range(N)]\nA[0] = V[0]-X[0]\nB = [0 for _ in range(N)]\nB[0] = max(0,A[0])\nfor i in range(1,N):\n    A[i] = A[i-1]+V[i]-X[i]+X[i-1]\n    B[i] = max(A[i],B[i-1])\ncmax = B[-1]\nv =0\nfor i in range(1,N):\n    v += V[-i]\n    cmax = max(cmax,v-(C-X[-i]),v-2*(C-X[-i])+B[-i-1])\ncmax = max(cmax,v+V[0]-(C-X[0]))\nprint(cmax)"
  ],
  [
    "print(\"Yes\" if int(str(int(input()))[::-1]) == int(input()) else \"No\")"
  ],
  [
    "def mod_pow(a, b, mod):\n    if b == 0:\n        return 1\n    elif b % 2 == 0:\n        return mod_pow(a * a % mod, b // 2, mod)\n    else:\n        return a * mod_pow(a, b - 1, mod) % mod\ndef comb(n, r, mod):\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    return (comb(n - 1, r - 1, mod) + comb(n - 1, r, mod)) % mod\nn, m, k = map(int, input().split())\nmod = 10**9 + 7\ntotal = 0\nfor i in range(1, k + 1):\n    total += (n * m * mod_pow(k - 1, i - 1, mod) * mod_pow(n * m - k, k - i, mod) * i * (k - i)) % mod\ntotal = (total * comb(n * m, k, mod)) % mod\nprint(total)\n"
  ],
  [
    "import sys\nsys.setrecursionlimit(10**6)\nfrom math import floor,ceil,sqrt,factorial,log\nfrom heapq import heappop, heappush, heappushpop\nfrom collections import Counter,defaultdict,deque\nfrom itertools import accumulate,permutations,combinations,product,combinations_with_replacement\nfrom bisect import bisect_left,bisect_right\nfrom copy import deepcopy\nfrom operator import itemgetter\nfrom fractions import gcd\nmod = 10 ** 9 + 7\ninf = float('inf')\nninf = -float('inf')\ndef ii(): return int(sys.stdin.readline().rstrip()) \ndef mii(): return map(int,sys.stdin.readline().rstrip().split())\ndef limii(): return list(mii()) \ndef lin(n:int): return [ii() for _ in range(n)]\ndef llint(n: int): return [limii() for _ in range(n)]\ndef ss(): return sys.stdin.readline().rstrip() \ndef mss(): return sys.stdin.readline().rstrip().split()\ndef limss(): return list(mss()) \ndef lst(n:int): return [ss() for _ in range(n)]\ndef llstr(n: int): return [limss() for _ in range(n)]\nn,m=mii()\nans=[[0]*2 for _ in range(m)]\nused=[False]*(n+1)\nfor i in range(m):\n    for j in range(2):\n        for k in range(1,n+1):\n            if not used[k]:\n                ans[i][j]=k\n                used[k]=True\n                break\n    for i in range(m):\n        print(*ans[i])"
  ],
  [
    "n, m = map(int, input().split())\nheight1 = (n * (n + 1)) // 2\nheight2 = (m * (m + 1)) // 2\ndiff = height2 - height1\nsnow_depth = diff\nprint(snow_depth)"
  ],
  [
    "import numpy as np\nN, M, C = map(int, input().split())\nB = np.ndarray([M, 1])\nB = list(map(int, input().split()))\nA = np.ndarray([N, M])\nfor i in range(N):\n    A[i, :] = list(map(int, input().split()))\nans = sum((A @ B + C) > 0)\nprint(ans)\n```\nThe error in the original code was in the line `ans = sum((A @ B + C) > 0)`. The `@` operator is used for matrix multiplication, but in this case, `A` and `B` are not matrices, they are lists of integers. To fix this, we can use the `np.dot()` function to perform the matrix multiplication.\nHere is the corrected code:\n```\nimport numpy as np\nN, M, C = map(int, input().split())\nB = np.ndarray([M, 1])\nB = list(map(int, input().split()))\nA = np.ndarray([N, M])\nfor i in range(N):\n    A[i, :] = list(map(int, input().split()))\nans = sum((np.dot(A, B) + C) > 0)\nprint(ans)"
  ],
  [
    "N = int(input())\nM = int(input())\ncost = 0\nfor i in range(M):\n    key_cost = int(input())\n    boxes = list(map(int, input().split()))\n    for box in boxes:\n        if box not in boxes:\n            cost += key_cost\n            boxes.append(box)\nif len(boxes) == N:\n    print(cost)\nelse:\n    print(-1)\n"
  ],
  [
    "N = int(input())\nseat = [0]*100000\nfor i in range(N):\n    li,ri = map(int,input().split())\n    for j in range(li-1,ri):\n        seat[j] = 1\nprint(sum(seat))"
  ],
  [
    "import sys\ninput = sys.stdin.readline\nn = int(input())\nc = []\ntmp = 0\nnum = 0\nfor i in range(n):\n    m = int(input())\n    if m!= tmp:\n        c.append(m)\n        tmp = m\n        num += 1\nn = num\nfrom collections import Counter\ndp = Counter()\nans = 1\nmod = 10**9 + 7\nfor i in range(n):\n    if i == 0 or i == n - 1:\n        dp[c[i]] += 1\n    else:\n        if c[i] == c[i - 1]:\n            dp[c[i]] += dp[c[i - 1]]\n        else:\n            dp[c[i]] += 1\n    ans = (ans * dp[c[i]]) % mod\nprint(ans)"
  ],
  [
    "import heapq\nfrom collections import defaultdict\ndef dijkstra(graph, start, fuel_limit):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [(0, start, 0)]  \n    while queue:\n        dist, node, refuel_count = heapq.heappop(queue)\n        if dist > distances[node]:\n            continue\n        for neighbor, distance in graph[node].items():\n            new_dist = dist + distance\n            new_refuel_count = refuel_count\n            if new_dist > fuel_limit:\n                new_dist = distance\n                new_refuel_count += 1\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor, new_refuel_count))\n    return distances\ndef main():\n    N, M, L = map(int, input().split())\n    graph = defaultdict(dict)\n    for _ in range(M):\n        A, B, C = map(int, input().split())\n        graph[A][B] = C\n        graph[B][A] = C\n    Q = int(input())\n    for _ in range(Q):\n        s, t = map(int, input().split())\n        distances = dijkstra(graph, s, L)\n        if distances[t] == float('inf'):\n            print(-1)\n        else:\n            print(distances[t])\nif __name__ == '__main__':\n    main()\n"
  ],
  [
    "import copy, sys\nn = int(input())\na_ls = list(map(int, input().split()))\nb_ls = []\nfor i in range(n-1):\n    if a_ls[i] != a_ls[i+1]:\n        b_ls.append(a_ls[i])\nif a_ls[-1] != a_ls[-2]:\n    b_ls.append(a_ls[-1])\nif not b_ls:\n    print(1000)\n    sys.exit()\nc_ls = [b_ls[0]]\nfor i in range(1,len(b_ls)-1):\n    if not (b_ls[i-1] < b_ls[i] < b_ls[i+1] or b_ls[i-1] > b_ls[i] > b_ls[i+1]):\n        c_ls.append(b_ls[i])\nc_ls.append(b_ls[-1])\nmoney = 1000\nstock = 0\nm = len(c_ls)\nfor i in range(m-1):\n    if c_ls[i] < c_ls[i+1]:\n        money += c_ls[i] * stock\n        stock = 0 \n    else:  \n        if money > 0:\n            stock, money = divmod(money, c_ls[i])\nif len(c_ls) > 1 and c_ls[-1] > c_ls[-2]:\n    money += c_ls[-1] * stock\nprint(money)"
  ],
  [
    "  import math\ndef calculate_total_value(x, u, rate):\n    total = 0\n    for i in range(len(x)):\n        if u[i] == \"JPY\":\n            total += x[i]\n        else:\n            total += x[i] * rate\n    return total\ndef main():\n    n = int(input())\n    x = list(map(float, input().split()))\n    u = input().split()\n    rate = 380000.0\n    total = calculate_total_value(x, u, rate)\n    print(total)\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "N, K = map(int, input().split())\nsnacks = [set(map(int, input().split()[1:])) for _ in range(K)]\nall_snukes = set(range(1, N+1))\nsnukes_with_snacks = set()\nfor snack in snacks:\n    snukes_with_snacks |= snack\nvictims = all_snukes - snukes_with_snacks\nprint(len(victims))\n"
  ],
  [
    "N = int(input())\na_list = [[0 for _ in range(3)] for _ in range(N)]\nfor i in range(N):\n    a, b, c = map(int, input().split())\n    a_list[i][0] = a\n    a_list[i][1] = b\n    a_list[i][2] = c\ndp = [[-1 for _ in range(3)] for _ in range(N + 1)]\nfor i in range(1, N + 1):\n    for j in range(3):\n        for k in range(3):\n            if i == 1:\n                dp[i][j] = a_list[i - 1][k]\n            if j == k:\n                continue\n            else:\n                dp[i][j] = max(dp[i][j], dp[i - 1][k] + a_list[i - 1][j])\nprint(max(dp[N]))"
  ],
  [
    "n,m = map(int,input().split())\nVLIST = [[] for i in range(n)]\nfor i in range(m):\n  v1,v2 = map(int,input().split())\n  VLIST[v1-1].append(v2-1)\ns,t = map(int,input().split())\ns0 = s-1\nt0 = t-1\nq = []\nq.extend(VLIST[s0])\nd = 0\nchk = [0]*n\ndp = [0]*n\ndp[s0] = 0\nwhile len(q)>0:\n  i = q.pop(0)\n  d = dp[i]\n  if chk[i]==1:\n    continue\n  if i==t0:\n    print(int(d//3 + 1))\n    exit()\n  q.extend(VLIST[i])\n  for j in VLIST[i]:\n    dp[j] = d+1\n  chk[i] = 1\nprint(-1)"
  ],
  [
    "import math\nn = int(input())\nmin_digits = math.ceil(math.log10(n))\nprint(min_digits)\n"
  ],
  [
    "n = int(input())\na = list(map(int, input().split()))\ncount = 0\nwhile all(i % 2 == 0 for i in a):\n    a = [i // 2 for i in a]\n    count += 1\nprint(count)"
  ],
  [
    "n = int(input())\ns = [input() for _ in range(n)]\na_count = [0] * n\nb_count = [0] * n\nfor i in range(n):\n    if s[i][-1] == 'A':\n        a_count[i] = 1\n    if s[i][0] == 'B':\n        b_count[i] = 1\nmax_ab = sum(a * b for a, b in zip(a_count, b_count))\nfor i in range(n):\n    if a_count[i] == 1 and b_count[i] == 1:\n        max_ab -= 1\n        break\nprint(max_ab)\n"
  ],
  [
    "n, k = list(map(int,input().split()))\nx = 0\nsum = 0\nfor y in range(1, k + 1):\n  x = k // y\n  sum += (x ** n) * y\n  if x > 1:\n    for z in range(1, x):\n      sum -= ((k // ((z + 1) * y)) ** n) * y\nprint(sum % (10 ** 9 + 7))"
  ],
  [
    "N = int(input())\nS = input()\nuse_list = []\nnum = 0\ndef DFS(i,used_list,num):\n    if i == N:\n        num += 1\n        return num\n    s = S[i]\n    num = DFS(i+1,used_list,num)\n    if s not in used_list:\n        used_list.append(s)\n        num = DFS(i+1,used_list,num)\n        used_list.pop()\n    return num\nans = DFS(0,use_list,num)\nprint(ans-1)"
  ],
  [
    "  import math\ndef is_tree(n, m, a, b):\n    graph = [[0] * n for _ in range(n)]\n    for i in range(m):\n        graph[a[i] - 1][b[i] - 1] = 1\n        graph[b[i] - 1][a[i] - 1] = 1\n    if len(graph) != n:\n        return False\n    visited = [False] * n\n    queue = [0]\n    while queue:\n        node = queue.pop(0)\n        if not visited[node]:\n            visited[node] = True\n            queue.extend(graph[node])\n    return all(visited)\ndef solve(n, m, a, b):\n    if not is_tree(n, m, a, b):\n        return \"NO\"\n    num_edges = 0\n    for i in range(m):\n        if graph[a[i] - 1][b[i] - 1] == 0:\n            num_edges += 1\n            graph[a[i] - 1][b[i] - 1] = 1\n            graph[b[i] - 1][a[i] - 1] = 1\n    if num_edges % 2 == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\nn = 14\nm = 4\na = [1, 2, 1, 3]\nb = [2, 4, 3, 4]\nprint(solve(n, m, a, b))\nn = 25\nm = 5\na = [1, 3, 5, 3, 2]\nb = [2, 5, 1, 4, 3]\nprint(solve(n, m, a, b))"
  ],
  [
    "def solve(n, m, q, conditions):\n    max_score = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            for k in range(1, m + 1):\n                score = 0\n                for a, b, c, d in conditions:\n                    if a == i and b == j and k - i == c:\n                        score += d\n                max_score = max(max_score, score)\n    return max_score\nn, m, q = map(int, input().split())\nconditions = []\nfor _ in range(q):\n    a, b, c, d = map(int, input().split())\n    conditions.append((a, b, c, d))\nprint(solve(n, m, q, conditions))\n"
  ],
  [
    "N = int(input())\nfor X in range(1, N + 1):\n  if int(X * 1.08) == N:\n    print(X)\n    break\nelse:\n  print(\":(\")\n"
  ],
  [
    "def get_max_score(graph):\n    score = 0\n    current_vertex = 1\n    while current_vertex != len(graph):\n        neighbors = graph[current_vertex]\n        max_weight = -1\n        max_neighbor = None\n        for neighbor in neighbors:\n            if neighbor[1] > max_weight:\n                max_weight = neighbor[1]\n                max_neighbor = neighbor[0]\n        current_vertex = max_neighbor\n        score += max_weight\n    return score\n"
  ],
  [
    "k = int(input())\nans = [i for i in range(50)]\ndef inv_process(arr,i):\n    arr[i] += 49\n    for j in range(50):\n        if j == i:\n            continue\n        else:\n            arr[j]-=1\nloop = k//50\nsup = k-loop*50\nfor i in range(50):\n    ans[i] += loop\nfor i in range(sup):\n    inv_process(ans,i)\nfor i in range(49):\n    print(ans[i],\" \")\nprint(ans[-1])"
  ],
  [
    "def search(search_map, group, current_h, current_w, group_index):\n    num = 0\n    return num\nH, W = map(int, input().split())\nA = [input() for _ in range(H)]\ns_map = {}\ngroup = {}\nsearched_map = {}\nfor i in range(H):\n    s_map[i] = {}\n    group[i] = {}\n    w = list(A[i])\n    for j in range(W):\n        s_map[i][j] = w[j]\n        group[i][j] = 0\nans = 0\ngroup_index = 1\ngroup_cnt = {}\ngroup_cnt[0] = 0\nfor i in range(H):\n    for j in range(W):\n        if s_map[i][j] == '\n            if group[i][j] != 0:\n                ans += group_cnt[group[i][j]]\n            else:\n                cnt = search(searched_map, group, i, j, group_index)\n                group_cnt[group_index] = cnt\n                group_index += 1\n                ans += cnt\nprint(ans)\n"
  ],
  [
    "import heapq\nN,K = (int(x) for x in input().split())\nH = list((-1)*(int(x)) for x in input().split())\nheapq.heapify(H)\nfor _ in range(K):\n    if len(H) == 1:\n        print(0)\n        break\n    heapq.heappop(H)\nif len(H) != 1:\n    sum = 0\n    while len(H) > 0:\n        sum -= heapq.heappop(H)\n    print(sum)"
  ],
  [
    "n, k = map(int, input().split())\nMOD = 10**9 + 7\nans = 0\nfor i in range(k, n + 2):\n    ans = (ans + (i - k + 1) * (n - i + 2)) % MOD\nprint(ans)\n"
  ],
  [
    "s = input()\ns1 = []\nle = []\ncnt = 0\nfor i in list(s):\n    if i!= \"x\":\n        le.append(cnt)\n        s1.append(i)\n    cnt += 1\nif s1!= s1[::-1]:\n    print(-1)\nelse:\n    print(le[len(le) // 2])"
  ],
  [
    "h, w, k = map(int, input().split())\nmod = 10 ** 9 + 7\ndp = [[0] * (w + 1) for _ in range(h + 1)]\nfor i in range(w + 1):\n  dp[0][i] = 1 if i == 1 else 0\ndef calc_pow(from_col, to_col):\n  assert(1<=from_col<=w and 1<=to_col<=w)\n  if from_col == 1 or to_col == 1 or from_col == w or to_col == w:\n    return pow(2, max(w-1-2, 0), mod)\n  else:\n    return pow(2, max(w-1-3, 0), mod)\nfor t in range(1, h + 1):\n  for i in range(1, w + 1):\n    pattern_1 = dp[t-1][i-1] * calc_pow(i-1, i) if i > 1 else 0\n    pattern_2 = dp[t-1][i+1] * calc_pow(i+1, i) if i < w else 0\n    pattern_3 = dp[t-1][i] * (pow(2, max(w-1-2, 0), mod) if 1 < i < w else pow(2, max(w-1-1, 0), mod))\n    dp[t][i] = (pattern_1 + pattern_2 + pattern_3) % mod\nprint(dp[h][k])"
  ],
  [
    "data1 = list(map(int,input().split(\" \")))\nN = data1[0]\nA = data1[1]\nB = data1[2]\ndata2 = list(map(int,input().split(\" \")))\ndata2.sort(reverse=True)\nmax_avr = sum(data2[:A]) / A\na_num = 0\na_pos = 0\nfor i in range(N):\n    if data2[i] == data2[A-1]:\n        a_num += 1\n        if i < A:\n            a_pos += 1\nimport math\ndef nCr(n,r):\n    f = math.factorial\n    return f(n) / f(r) / f(n-r)\ncnt = 0\nif a_pos == A:\n    while a_pos <= B:\n        cnt += nCr(a_num,a_pos)\n        a_pos += 1\nelse:\n    cnt = nCr(a_num,a_pos)\nprint(\"{0:.6f}\".format(max_avr))\nprint(int(cnt))"
  ],
  [
    "def main():\n    l = {}\n    lR = {}\n    l = input()\n    lR = l[::-1]\n    givenLen = len(l)\n    if l == lR:\n        return 0\n    temp = {}\n    temp[0] = 0\n    for i, e in enumerate(l):\n        temp[i+1] = e\n    l = dict(temp)\n    temp = {}\n    temp[0] = 0\n    for i, e in enumerate(lR):\n        temp[i+1] = e\n    lR = dict(temp)\n    LCStable = [[0 for _ in range(givenLen+1)]]*(givenLen+1)\n    for i in l:\n        for j in lR:\n            if i == 0 or j == 0:\n                LCStable[i][j] = 0\n            elif l[i] == lR[j]:\n                LCStable[i][j] = LCStable[i-1][j-1]+1\n            else:\n                LCStable[i][j] = max(LCStable[i][j-1], LCStable[i-1][j])\n    return givenLen-LCStable[-1][-1]\nprint(main())"
  ],
  [
    "a, b, c = (int(x) for x in input().split())\nif a < b < c or a > b > c:\n    print('No')\nelif c < b or b < a:\n    print('No')\nelse:\n    print('Yes')"
  ],
  [
    "import numpy as np\nN = int(input())\na = [int(input()) for i in range(N)]\ncnt = 0\nfor i in range(N // 2 - 1, 0, -1):\n    if a[i] > a[i + 1]:\n        a.insert(0, a[i])\n        a.pop(i + 1)\n        cnt += 1\nfor i in range(N // 2, N - 1):\n    if a[i] > a[i + 1]:\n        a.append(a[i])\n        a.pop(i)\n        cnt += 1\nprint(cnt)"
  ],
  [
    "k = int(input())\nn = 50\na = [0] * n\nfor i in range(n):\n    a[i] = k // n\n    k %= n\nfor i in range(n - 1, n - 1 - k, -1):\n    a[i] += 1\nprint(n)\nprint(*a)"
  ],
  [
    "a, b, k = map(int, input().split())\nif k <= a:\n  a -= k\nelse:\n  k -= a\n  a = 0\n  if k <= b:\n    b -= k\n  else:\n    b = 0\nprint(a, b)"
  ],
  [
    "import math\nN = int(input())\nfor X in range(1, N + 1):\n  if math.floor(X * 1.08) == N:\n    print(X)\n    break\nelse:\n  print(\":(\")"
  ],
  [
    "n, m = map(int, input().split())\nA = sorted(list(map(int, input().split())))\nbc = []\nfor i in range(2):\n    b, c = map(int, input().split())\n    bc.append([b,c])\nfrom operator import itemgetter\nbc.sort(key=itemgetter(1))\nk = 0\nc = bc[0][1]\nb = bc[0][1]\nbn = 0\nwhile A[k] < c:\n    A[k]=c\n    k+=1\n    if k >= len(A):\n        break\n    b-=1\n    if b  == 0:\n        bn += 1\n        if bn > len(bc):\n            break\n        b = bc[bn][0]\n        c = bc[bn][1]\nprint(sum(A))"
  ],
  [
    "n, m = list(map(int, input().split()))\nheight = [int(i) for i in input().split()]\ntele = {}\nfor num, h in enumerate(height, 1):\n    tele[num] = [h, \"G\"]\nfor roads in range(m):\n    a, b = list(map(int, input().split()))\n    if (tele[a][0] < tele[b][0]):\n        tele[a][1] = \"N\"\n    elif (tele[b][0] < tele[a][0]):\n        tele[b][1] = \"N\"\nans_list = tele.values()\nans = 0\nfor a in ans_list:\n    if (a[1] == \"G\"):\n        ans += 1\nprint(ans)"
  ],
  [
    "n = int(input())\na = []\nfor i in range(n):\n    b = int(input())\n    a.append(b)\na.sort()\nans = [\"\" for i in range(n)]\nans[n // 2] = a[-1]\na.remove(a[-1])\nl = (n // 2) - 1\nr = (n // 2) + 1\nfor i in range(n - 1):\n    if i % 4 == 0:\n        ans[l] = a[0]\n        a.remove(a[0])\n        l -= 1\n    elif i % 4 == 1:\n        ans[r] = a[0]\n        a.remove(a[0])\n        r += 1\n    elif i % 4 == 2:\n        ans[l] = a[-1]\n        a.remove(a[-1])\n        l -= 1\n    elif i % 4 == 3:\n        ans[r] = a[-1]\n        a.remove(a[-1])\n        r -= 1\nans.append(ans[0])\nnum = 0\nnum2 = 0\nnum3 = 0\nfor i in range(n):\n    num += abs(ans[i] - ans[i + 1])\nnum -= min(abs(ans[0] - ans[1]), abs(ans[-1] - ans[-2]), abs(ans[-2] - ans[-3]))\nprint(num)"
  ],
  [
    "n, p = map(int, input().split())\na = [int(i) for i in input().split()]\nb = [i % 2 for i in a]\nodd_count = b.count(1)\nif p == 0:\n    ans = 2 ** (n - odd_count)\nelse:\n    if odd_count == 0:\n        ans = 0\n    else:\n        ans = 2 ** (n - 1) - 2 ** (n - odd_count)\nprint(ans)"
  ],
  [
    "A, B = map(int, input().split())\nfor price in range(1, 10001):\n    tax_8 = price * 0.08\n    tax_10 = price * 0.1\n    if int(tax_8) == A and int(tax_10) == B:\n        print(price)\n        break\nelse:\n    print(-1)\n"
  ],
  [
    "S = str(input())\nlist = list(S)\nnum = int(list.count('+'))\nprint(num - (4-num))\n```\nThe error in the code is that the variable `list` is not defined. It should be defined as `list = list(S)` instead of `list = lisr(S)`. Additionally, the variable `num` should be defined as `num = int(list.count('+'))` instead of `num = int(list.count('+'))`.\nThe corrected code should be:\n```\nS = str(input())\nlist = list(S)\nnum = int(list.count('+'))\nprint(num - (4-num))"
  ],
  [
    "n = int(input())\np = list(map(int, input().split()))\nans = 0\nfor i in range(1, n - 1):\n    if (p[i - 1] < p[i] < p[i + 1]) or (p[i + 1] < p[i] < p[i - 1]):\n        ans += 1\nprint(ans)"
  ],
  [
    "nm = list(map(int,input().split()))\nN = nm[0]\nM = nm[1]\np = list(map(int,input().split()))\nxy = []\nfor i in range(M):\n    xy_ = tuple(map(int,input().split()))\n    xy.append(xy_)\ndef count00():\n    cnt00 = 0\n    for i in range(N):\n        if i+1==p[i]:\n            cnt00+=1\n    return cnt00\ndef swap(a,x,y):\n    a[x],a[y] = a[y],a[x]\ndef count01():\n    cnt01 = 0\n    for j in range(N):\n        if j+1==p[j]:\n            cnt01+=1\n    return cnt01\ndef judge():\n    cnt00 = count00()\n    for i in range(M):\n        swap(p,xy[i][0]-1,xy[i][1]-1)\n        cnt01 = count01()\n        if cnt01 > cnt00:\n            cnt00 = cnt01\n        swap(p,xy[i][0]-1,xy[i][1]-1) \n    return cnt00\nprint(judge())"
  ],
  [
    "import sys\nMOD = 10**9 + 7\ndef main():\n  K = int(sys.stdin.readline())\n  S = sys.stdin.readline().strip()\n  n = len(S)\n  ans = 1\n  for i in range(K):\n    ans = (ans * (n + i + 1)) % MOD\n  print(ans)\nif __name__ == \"__main__\":\n  main()\n"
  ],
  [
    "import sys\ninput = sys.stdin.readline\nH,W,N=map(int,input().split())\nab=[tuple(map(int,input().split())) for i in range(N)]\nab.sort()\nr_b=[0]\nr_b_app=r_b.append\nfor i in range(1,N):\n  if ab[i][0]!=ab[i-1][0]:\n    r_b_app(i)\nif N>0:\n  r_b_app(N)\nrows=tuple(ab[b][0] for b in r_b if b<N)\ncols=tuple(tuple(ab[j][1] for j in range(r_b[i],r_b[i+1])) for i in range(len(r_b)-1))\nrN=len(cols)\nched_box0=[[[False]*3 for k in range(3)] for j in range((len(cols[0]) if 0<rN else 0))]\nched_box1=[[[False]*3 for k in range(3)] for j in range((len(cols[1]) if 1<rN else 0))]\nched_box2=[[[False]*3 for k in range(3)] for j in range((len(cols[2]) if 2<rN else 0))]\ndic_cn0=dict(zip(cols[0],list(range(len(cols[0]))))) if 0<rN else {}\ndic_cn1=dict(zip(cols[1],list(range(len(cols[1]))))) if 1<rN else {}\ndic_cn2=dict(zip(cols[2],list(range(len(cols[2]))))) if 2<rN else {}\narea_n=[0]*9\ncount=[[1]*3 for i in range(3)]\nfind_cn=[0]*12\nfor rn in range(rN):\n  cN=len(cols[rn])\n  row=rows[rn]\n  if rn!=0:\n    ched_box0=ched_box1\n    dic_cn0=dic_cn1\n    ched_box1=ched_box2\n    dic_cn1=dic_cn2\n    if rn<rN-2:\n      cN2_range=range(len(cols[rn+2]))\n      ched_box2=[[[False]*3 for k in range(3)] for j in cN2_range]\n      dic_cn2=dict(zip(cols[rn+2],list(cN2_range)))\n  if (rows[rn+1] is row+1 if rn<rN-1 else False):\n    row1=row+1\n    if (rows[rn+2] is row+2 if rn<rN-2 else False):\n      row2=row+2\n    else:\n      row2=None\n  elif (rows[rn+1] is row+2 if rn<rN-1 else False):\n    row1=row+2\n    row2=None\n  else:\n    row1=None\n    row2=None\n  for cn in range(cN):\n    col=cols[rn][cn]\n    ched_box=ched_box0[cn]\n    box_row_0_col=[]\n    box_row_1_col=[]\n    box_row_2_col=[]\n    for box_col in range(3):\n      if not ched_box[0][box_col]:\n        if col-2+box_col>=1 and col+box_col<=W and row-2>=1 and row<=H:\n          box_row_0_col.append(box_col)\n        else:\n          ched_box[0][box_col]=True\n      if not ched_box[1][box_col]:\n        if col-2+box_col>=1 and col+box_col<=W and row-2+1>=1 and row+1<=H:\n          box_row_1_col.append(box_col)\n        else:\n          ched_box[1][box_col]=True\n      if not ched_box[2][box_col]:\n        if col-2+box_col>=1 and col+box_col<=W and row-2+2>=1 and row+2<=H:\n          box_row_2_col.append(box_col)\n        else:\n          ched_box[2][box_col]=True\n    find_rowcol=[]\n    find_rowcol_app=find_rowcol.append\n    find_cn_n=0\n    if (col+1 in dic_cn0 if col+1<=W else False):\n      find_rowcol_app((row,col+1))\n      find_cn[find_cn_n]=dic_cn0[col+1]\n      find_cn_n+=1\n    if (col+2 in dic_cn0 if col+2<=W else False):\n      find_rowcol_app((row,col+2))\n      find_cn[find_cn_n]=dic_cn0[col+2]\n      find_cn_n+=1\n    if (row1<=H if row1 is not None else False):\n      for ch_col in range(max(col-2,1),min(col+3,W+1)):\n        if ch_col in dic_cn1:\n          find_rowcol_app((row1,ch_col))\n          find_cn[find_cn_n]=dic_cn1[ch_col]\n          find_cn_n+=1\n    if (row2<=H if row2 is not None else False):\n      for ch_col in range(max(col-2,1),min(col+3,W+1)):\n        if ch_col in dic_cn2:\n          find_rowcol_app((row2,ch_col))\n          find_cn[find_cn_n]=dic_cn2[ch_col]\n          find_cn_n+=1\n    for i,(find_row,find_col) in enumerate(find_rowcol):\n      if find_row is row:\n        ch_rn=0\n        ch_cn=find_cn[i]\n      elif find_row is row1:\n        ch_rn=1\n        ch_cn=find_cn[i]\n      elif find_row is row2:\n        ch_rn=2\n        ch_cn=find_cn[i]\n      for box_row in range(find_row-row,3):\n        for box_col in range(max(find_col-col,0),min(3,3+find_col-col)):\n          if not ched_box[box_row][box_col]:\n            count[box_row][box_col]+=1\n            if ch_rn is 0:\n              ched_box0[ch_cn][box_row-find_row+row][box_col-find_col+col]=True\n            elif ch_rn is 1:\n              ched_box1[ch_cn][box_row-find_row+row][box_col-find_col+col]=True\n            else:\n              ched_box2[ch_cn][box_row-find_row+row][box_col-find_col+col]=True\n    for box_row in range(3):\n      for box_col in range(3):\n        if not ched_box[box_row][box_col]:\n          area_n[count[box_row][box_col]-1]+=1\n          count[box_row][box_col]=1\nprint((W-2)*(H-2)-sum(area_n))\nfor i in range(9):\n  print(area_n[i])"
  ],
  [
    "N, H = map(int, input().split())\nA = []\nB = []\nfor i in range(N):\n    a, b = map(int, input().split())\n    A.append(a)\n    B.append(b)\nA = numpy.array(A)\nB = numpy.array(B)\nAsortA = numpy.sort(A)[::-1]\nBsortB = numpy.sort(B)[::-1]\nans = 0\nmaxattack = AsortA[0]\nthrow = BsortB[maxattack < BsortB]\nif sum(throw) >= H:\n    for i in range(1, len(throw) + 1)[::-1]:\n        if sum(throw[:i]) < H:\n            ans = i + 1\n            break\nelse:\n    resH = H - sum(throw)\n    ak = int(numpy.ceil(resH / maxattack))\n    ans = ak + len(throw)\nprint(ans)"
  ],
  [
    "n = int(input())\na = list(map(int, input().split()))\ncount = 0\nfor i in range(n):\n  if (i+1)%2 == 1 and a[i]%2 == 1:\n    count += 1\nprint(count)\n"
  ],
  [
    "import fractions\ndef main():\n    n = int(input())\n    a = list(map(int,input().split()))\n    a.sort()\n    ans = a[0]\n    for i,a_i in enumerate(a,1):\n        if ans == a_i:\n            continue\n        elif ans % a_i == 0 or a_i % ans == 0:\n            ans = min(ans, fractions.gcd(ans,a_i))\n        elif ans % 2 == 0 and a_i % 2 == 0:\n            ans = 2\n        else:\n            ans = 1\n    print(ans)\nif __name__=='__main__':\n    main()"
  ],
  [
    "import sys\ndef main():\n    n = int(sys.stdin.readline())\n    numbers = list(map(int, sys.stdin.readline().split()))\n    result = 1\n    for num in numbers:\n        result *= num\n        if result > 10**18:\n            print(-1)\n            return\n    print(result)\nif __name__ == \"__main__\":\n    main()\n"
  ],
  [
    "n, m = [int(_) for _ in input().split()]\nH = [int(_) for _ in input().split()]\nHlist = [(set() for a in range(n))]\ncount = 0\nfor a in range(m):\n    a, b = [int(_) for _ in input().split()]\n    Hlist[a - 1].add(b - 1)\n    Hlist[b - 1].add(a - 1)\nfor i, j in enumerate(Hlist):\n    flag = 1\n    for a in j:\n        if H[a] >= H[i]:\n            flag = 0\n    if flag == 1:\n        count += 1\n    flag = 1\nprint(count)"
  ],
  [
    "x, a, b = map(int, input().split())\nif abs(x - a) < abs(x - b):\n  print(\"A\")\nelse:\n  print(\"B\")\n"
  ],
  [
    "a, b, c = map(int, input().split())\nif (a + b == c) or (a + c == b) or (b + c == a) or (a == b == c):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n"
  ],
  [
    "N, M = [int(x) for x in input().split()]\nlikes = [0 for x in range(M)]\nfor n in range(N):\n    s = [int(x) for x in input().split()]\n    K = s[0]\n    for k in range(K):\n        likes[s[1+k] - 1] += 1\nprint(likes.count(N))"
  ],
  [
    "X, Y = map(int, input().split())\nif Y >= 2 * X and Y <= 4 * X and Y % 2 == 0:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n"
  ],
  [
    "import numpy as np\nn, k = map(int, input().split())\nli = np.array([0] * (n + 2))\nlis2 = np.array([0] * (3 * n))\nlis2[1] = 1\nfor i in range(k):\n    l, r = map(int, input().split())\n    li[l] = 1\n    li[r + 1] = -1\nfor i in range(1, n + 1):\n    li[i] += li[i - 1]\nfor i in range(1, n):\n    lis2[i] %= 998244353\n    lis2[i:i + n + 2] += li * lis2[i]\nprint(lis2[n] % 998244353)"
  ],
  [
    "def max_contests(N, A, B, P):\n    max_contests = 0\n    used_problems = set()\n    P.sort(reverse=True)\n    for i in range(N):\n        if P[i] not in used_problems and A <= P[i] <= B:\n            used_problems.add(P[i])\n            for j in range(i+1, N):\n                if P[j] not in used_problems and A < P[j] <= B:\n                    for k in range(j+1, N):\n                        if P[k] not in used_problems and B < P[k]:\n                            max_contests += 1\n                            used_problems.add(P[j])\n                            used_problems.add(P[k])\n                            break\n    return max_contests\n"
  ],
  [
    "  def solve(N, S, A):\n    MOD = 998244353\n    dp = [0] * (N + 1)\n    for i in range(1, N + 1):\n        for j in range(S + 1):\n            if j - A[i - 1] >= 0:\n                dp[j] = (dp[j] + dp[j - A[i - 1]]) % MOD\n    return sum(dp) % MOD"
  ],
  [
    "A, B, C, K = map(int, input().split())\nmax_sum = min(A, K)  \nK -= max_sum  \nmax_sum += min(B, K)  \nK -= min(B, K)  \nmax_sum -= min(C, K)  \nprint(max_sum)\n"
  ],
  [
    "h,w = map(int, input().split())\ns = []\nfor i in range(h):\n    s.append(input())\ndx = [0,0,1,-1]\ndy = [1,-1,0,0]\ndef dfs(y,x):\n    global check\n    global was\n    was[y][x] = 1\n    if s[y][x] == \"\n        check[0] += 1\n    else:\n        check[1] += 1\n    for k in range(4):\n        nx = x + dx[k]\n        ny = y + dy[k]\n        if 0 <= ny < h and 0 <= nx < w and s[ny][nx] != s[y][x] and not was[ny][nx]:\n            dfs(ny,nx)\nans = 0\nwas = [[0 for i in range(w)] for j in range(h)]\nfor i in range(h):\n    for j in range(w):\n        if not was[i][j]:\n            check = [0,0]\n            dfs(i,j)\n            ans += check[0] * check[1]\nprint(ans)"
  ],
  [
    "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf,comb\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\nh, w, k = MAP()\ns = []\np = []\nq = []\nfor i in range(h):\n    s.append(input())\n    if s[i].count('\n        p.append(i)\n    else:\n        q.append(i)\na = [[0]*w for i in range(h)]\nnum = 0\nfor i in p:\n    num += 1\n    k = 0\n    while s[i][k] == '.':\n        a[i][k] = num\n        k += 1\n    a[i][k] = num\n    k += 1\n    if k < w:\n        for j in range(k, w):\n            if s[i][j] == '\n                num += 1\n            a[i][j] = num\nfor i in q:\n    k = i - 1\n    while k >= 0 and a[k][0] == 0:\n        k -= 1\n    if k < 0:\n        k = i + 1\n        while k < h and a[k][0] == 0:\n            k += 1\n    for j in range(w):\n        a[i][j] = a[k][j]\nfor i in range(h):\n    print(*a[i][:])"
  ],
  [
    "def main():\n    A = int(input())\n    for i in range(10, 10000+1):\n        if str(i) == base_10_to_n(A, i):\n            print(i)\n            return\n    print(-1)\ndef base_10_to_n(X, n):\n    if int(X / n):\n        return base_10_to_n(int(X/n), n) + str(X % n)\n    return str(X % n)"
  ],
  [
    "H = int(input())\nW = int(input())\nD = int(input())\nA = [[0 for _ in range(W)] for _ in range(H)]\nfor i in range(H):\n    A[i] = [int(x) for x in input().split()]\nQ = int(input())\nL = [int(input()) for _ in range(Q)]\nR = [int(input()) for _ in range(Q)]\ndef magic_points(i, j, x, y):\n    return abs(x-i) + abs(y-j)\ndef solve():\n    result = []\n    for i in range(Q):\n        x = L[i]\n        while x != R[i]:\n            x += D\n        result.append(magic_points(i, j, x, y))\n    return result\nprint(*solve(), sep='\\n')\n"
  ],
  [
    "import sys\ndef input():\n    return sys.stdin.readline()\nn,m=map(int,input().split())\na=[0]*m\nb=[0]*m\nc=[0]*(n+1)\nfor i in range(m):\n    a[i],b[i]=map(int,input().split())\n    if a[i]==1:\n        c[b[i]]=1\nans='IMPOSSIBLE'\nfor i in range(m):\n    if b[i]==n:\n        if c[a[i]]==1:\n            ans='POSSIBLE'\nprint(ans)"
  ],
  [
    "N, M = map(int, input().split())\na = [int(input()) for i in range(M)]\nDP = [0]*(N+1)\npointer = 0\nDP[0] = 1\nDP[1] = 1\nfor i in range(2, N+1):\n    if pointer < M and i == a[pointer]:\n        DP[i] = 0\n        pointer += 1\n    else:\n        DP[i] = (DP[i-1] + DP[i-2]) % 1000000007\nprint(DP[-1])"
  ],
  [
    "a, b, c = map(int, input().split())\nif (a < b and a < c and c < b) or (a > b and a > c and c > b):\n  print(\"Yes\")\nelse:\n  print(\"No\")"
  ],
  [
    "n = int(input())\nl = []\nfor i in range(0, n):\n    l.append(input())\nprint(len(set(l)))"
  ],
  [
    "n = int(input())\na = list(map(int, input().split()))\na.sort()\nans = 0\nfor i in range(1, n):\n  ans += min(a[i], a[i - 1])\nprint(ans)\n"
  ],
  [
    "n = int(input())\nelements = [int(input()) for _ in range(n)]\nmax_element = max(elements)\nmax_index = elements.index(max_element)\nresult = []\nfor i in range(n):\n    if i == max_index:\n        second_max = max(elements[:max_index] + elements[max_index+1:])\n        result.append(second_max)\n    else:\n        result.append(max_element)\nfor r in result:\n    print(r)\n"
  ],
  [
    "import sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\ndef main():\n    n,ma,mb=MI()\n    abc=[LI() for _ in range(n)]\n    inf=10**9\n    pre=[(0,0,0)]\n    for a,b,c in abc[:n//2]:\n        pn=len(pre)\n        for i in range(pn):\n            pa,pb,pc=pre[i]\n            pre.append((a+pa,b+pb,c+pc))\n    pre=[(a*mb-b*ma,c) for a,b,c in pre]\n    pos=[(0,0,0)]\n    for a,b,c in abc[n//2:]:\n        pn=len(pos)\n        for i in range(pn):\n            pa,pb,pc=pos[i]\n            pos.append((a+pa,b+pb,c+pc))\n    pos=[(a*mb-b*ma,c) for a,b,c in pos]\n    pre.sort()\n    pos.sort()\n    j=len(pos)-1\n    ans=inf\n    for val,c in pre:\n        while val+pos[j][0]>0 and j>0:j-=1\n        while val+pos[j][0]==0 and j>=0:\n            now=c+pos[j][1]\n            if now and now<ans:ans=now\n            j-=1\n        if j<0:break\n    if ans==inf:print(-1)\n    else:print(ans)\nmain()"
  ],
  [
    "n=int(input())\nN=int(input())\nfor i in range(1,4):\n  if(i!=n and i!=N):\n    print(i)"
  ],
  [
    "n, y = map(int,input().split())\ny = y / 1000\nf = 0\nfor i in range(n + 1):\n    for j in range(n - i + 1):\n        if 10 * i + 5 * j + (n - i - j) == y:\n            print(i, j, n - i - j)\n            f = 1\n            break\n    if f == 1:\n        break\nif f == 0:\n    print(-1, -1, -1)"
  ],
  [
    "  def get_min_bricks_to_break(arr):\n    n = len(arr)\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + 1\n        for j in range(i - 2, -1, -1):\n            if arr[j] == i - j:\n                dp[i] = min(dp[i], dp[j] + 1)\n                break\n    return dp[n]\ndef main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(get_min_bricks_to_break(arr))\nmain()"
  ],
  [
    "def solve():\n  ans = 0\n  N = int(input())\n  stacks = [list(map(lambda x:int(x)-1, input().split()))[::-1] for _ in range(N)]\n  lis = [0]*N\n  cnt = 0\n  now = 0\n  flag = 0\n  while cnt<N*(N-1)//2:\n    while not stacks[now]:\n      now = (now+1)%N\n    a = stacks[now][-1]\n    if not stacks[a]:\n      return -1\n    if stacks[a][-1] == now:\n      lis[now] = max(lis[now],lis[a])+1\n      lis[a] = lis[now]\n      stacks[a].pop(-1)\n      stacks[now].pop(-1)\n      cnt += 1\n      flag = 0\n    else:\n      now = a\n      flag += 1\n    if flag==N:\n      return -1\n  ans = max(lis)\n  return ans\nprint(solve())"
  ],
  [
    "N = int(input())\nnum = N + 1\nwhile True:\n    if len(set(str(num))) == 1:\n        print(num)\n        break\n    num += 1\n"
  ],
  [
    "S = int(input())\nx1 = 0\ny1 = 0\nif S > 10**9:\n  x2 = 10**9\n  y2 = 1\n  x3 = S//x2\n  y3 = S%x2\nelse:\n  x2 = S\n  y2 = 0\n  x3 = 0\n  y3 = 1\nprint(x1,y1,x2,y2,x3,y3)"
  ],
  [
    "def is_bracket_sequence(strings):\n    stack = []\n    for string in strings:\n        for char in string:\n            if char == \"(\":\n                stack.append(char)\n            elif char == \")\":\n                if not stack:\n                    return False\n                stack.pop()\n    return not stack\n"
  ],
  [
    "import sys\nimport math\nn, k = map(int, input().split())\nls = list(map(int, input().split()))\nif n >= 1000 and k > math.log(n):\n    print(*[n] * n)\n    sys.exit()\nif k >= n:\n    print(*[n] * n)\n    sys.exit()\nfor _ in range(k):\n    new = [0] * n\n    for i in range(n):\n        p = 0\n        for l in range(1, max(n - i, i + 1)):\n            if i + l < n and ls[i + l] >= l:\n                p += 1\n            if i - l >= 0 and ls[i - l] >= l:\n                p += 1\n        new[i] = p\n    ls = new\nprint(*ls)"
  ],
  [
    "import numpy as np\nn=int(input())\na=[int(i) for i in input().split()]\nc=0\nfor i in range(n):\n  while a[i]%2==0:\n    a[i] //= 2\n    c+=1\nprint(c)"
  ],
  [
    "N = int(input())\nAs = list(map(int, input().split()))\nmod = 10**9+7\ndp = [[0]*3 for _ in range(N+1)]\nans = 1\nfor i in range(N):\n    a = As[i]\n    dplis = dp[i]\n    cnt = 0\n    dp[i+1] = dplis[:]\n    for j, d in enumerate(dplis):\n        if a==d:\n            cnt += 1\n            if cnt==1:\n                dp[i+1][j] = a+1\n    if cnt==0:\n        print(0)\n        break\n    ans = ans*cnt%mod\nprint(ans)"
  ],
  [
    "d, n = map(int, input().split())\nif d == 0:\n  if n <= 99:\n    print(n)\n  else:\n    print(101)\nelif d == 1:\n  if n <= 99:\n    print(100*n)\n  else:\n    print(10100)\nelse:\n  if n <= 99:\n    print(10000*n)\n  else:\n    print(1010000)"
  ],
  [
    "N, A, B = map(int, input().split())\nH = []\nfor i in range(N):\n    H.append(int(input()))\nans = 0\nn = N\nwhile n > 0:\n    mi = 0\n    for i in range(n):\n        if H[i] >= 0:\n            H[i] -= B\n    H[mi] -= (A - B)\n    if H[mi] < H[i]:\n        mi = i\n    while n > 0 and H[n - 1] <= 0:\n        n -= 1\n    ans += 1\nprint(ans)"
  ],
  [
    "N = int(input())\nA_list = list(map(int,input().split()))\nB_list = list(map(int,input().split()))\nC_list = list(map(int,input().split()))\nans = sum(B_list)\nfor i in range(1, N):\n    if A_list[i] == A_list[i-1] + 1:\n        ans += C_list[A_list[i] - 2]\nprint(ans)"
  ],
  [
    "def create_grid(a, b):\n    h = max(a, b) * 2\n    w = max(a, b) * 2\n    grid = [['.' for _ in range(w)] for _ in range(h)]\n    white_components = 0\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '.' and white_components < a:\n                grid[i][j] = '\n                white_components += 1\n                if j + 1 < w and grid[i][j + 1] == '.':\n                    grid[i][j + 1] = '\n                if i + 1 < h and grid[i + 1][j] == '.':\n                    grid[i + 1][j] = '\n    black_components = 0\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '.' and black_components < b:\n                grid[i][j] = '\n                black_components += 1\n                if j + 1 < w and grid[i][j + 1] == '.':\n                    grid[i][j + 1] = '.'\n                if i + 1 < h and grid[i + 1][j] == '.':\n                    grid[i + 1][j] = '.'\n    return grid\na, b = map(int, input().split())\ngrid = create_grid(a, b)\nprint(len(grid), len(grid[0]))\nfor row in grid:\n    print(''.join(row))\n"
  ],
  [
    "def can_permute(a):\n    n = len(a)\n    for i in range(n-1):\n        if a[i] % 2 != 0 and a[i+1] % 2 != 0:\n            return False\n    return True\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    if can_permute(a):\n        print(\"Yes\")\n    else:\n        print(\"No\")\nif __name__ == \"__main__\":\n    main()\n"
  ],
  [
    "  import math\ndef find_combination(S):\n    for X_1 in range(0, 10**9 + 1):\n        for Y_1 in range(0, 10**9 + 1):\n            for X_2 in range(0, 10**9 + 1):\n                for Y_2 in range(0, 10**9 + 1):\n                    for X_3 in range(0, 10**9 + 1):\n                        for Y_3 in range(0, 10**9 + 1):\n                            area = math.fabs((X_1 * Y_2 + X_2 * Y_3 + X_3 * Y_1) - (X_2 * Y_1 + X_3 * Y_2 + X_1 * Y_3))\n                            if area == S / 2:\n                                return X_1, Y_1, X_2, Y_2, X_3, Y_3\n    return None\nS = int(input())\nresult = find_combination(S)\nif result is not None:\n    print(*result)"
  ],
  [
    "import sys\nreadline = sys.stdin.readline\nMOD = pow(10,9)+7\ndef combinations(n,k):\n    global fac, finv\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n-k] % MOD) % MOD\ndef main():\n    global fac, finv\n    N, K = map(int, readline().split())\n    A = list(map(int, readline().split()))\n    A.sort()\n    MAX_NUM = N + 1\n    fac  = [0 for _ in range(MAX_NUM)]\n    finv = [0 for _ in range(MAX_NUM)]\n    inv  = [0 for _ in range(MAX_NUM)]\n    fac[0]  = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n    for i in range(2,MAX_NUM):\n        fac[i] = fac[i-1] * i % MOD\n        inv[i] = MOD - inv[MOD%i] * (MOD // i) % MOD\n        finv[i] = finv[i-1] * inv[i] % MOD\n    summax = 0\n    summin = 0\n    for i in range(K):\n        summax += A[N-i-1] * combinations(N-i-1, K-1)\n        summin += A[i] * combinations(i, K-1)\n    ans = (summax - summin) % MOD\n    print(ans)\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "n = int(input())\nl = []\nfor i in range(n):\n  l.append(list(map(int, input().split())))\nfor i in range(n - 1):\n  time = l[i][1]\n  for j in range(i, n - 1):\n    time += l[j][0]\n    if time >= l[j + 1][1]:\n      continue\n    else:\n      wait = (l[j + 1][1] - time) % l[j + 1][2]\n      time += wait\n      break\n  print(time)\nprint(0)"
  ],
  [
    "x = int(input(\"\"))\ny = int(input(\"\"))\nz = int(input(\"\"))\nanswer = (x - z) // (z + y)\nprint(answer)"
  ],
  [
    "N = int(input())\nD = int(input())\ndef min_inspectors(N, D):\n    return (N + D - 1) // D\nprint(min_inspectors(N, D))\n"
  ],
  [
    "v = list(map(int, input().split()))\nc = list(map(int, input().split()))\nn = int(input())\ns = 0\nfor i in range(n):\n  if v[i] - c[i] > 0:\n    s += v[i] - c[i]\nprint(s)"
  ],
  [
    "s = input()\nn = len(s)\ncount = 0\nfor i in range(n // 2):\n    if s[i]!= s[n - i - 1]:\n        count += 1\nprint(count)\n"
  ],
  [
    "  a = int(input())\nb = int(input())\nif (a * b) % 2 == 0:\n    print(\"Even\")\nelse:\n    print(\"Odd\")"
  ],
  [
    "import sys\nimport os\nf = open(\"C:/Users/user/Documents/atCoderProblem/import.txt\",\"r\")\nsys.stdin = f\nn = int(input())\nprint(\"ABC\" + str(n))"
  ],
  [
    "n, k = map(int,input().split())\nfor i in range(0,n):\n    if k**i > n:\n        print(i-1)\n        break"
  ],
  [
    "def count_digits(n, k):\n    count = 0\n    while n > 0:\n        n, remainder = divmod(n, k)\n        count += 1\n    return count\n"
  ],
  [
    "a, b, x = map(int, input().split())\nprint((b // x) - ((a - 1) // x))\n"
  ],
  [
    "N, A, B = map(int, input().split())\nprint(min(A, B), max(0, A + B - N))"
  ],
  [
    "H1, M1, H2, M2, K = map(int, input().split())\nstart_time = H1 * 60 + M1\nend_time = H2 * 60 + M2\nstudy_period = end_time - start_time - K\nstudy_period = max(0, study_period)\nprint(study_period)\n"
  ],
  [
    "import sys\nimport math\nimport itertools\nimport collections\nfrom collections import deque\nfrom collections import defaultdict\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\ndef main():\n    N = NI()\n    A = NLI()\n    cnt = 0\n    minimum_abs = float('inf')\n    ans = 0\n    flag = 0\n    for n in range(N):\n        ans += abs(A[n])\n        minimum_abs = min(minimum_abs, abs(A[n]))\n        if A[n] < 0:\n            cnt += 1\n        elif A[n] == 0:\n            flag = 1\n    if cnt % 2 == 0 or flag == 1:\n        print(ans)\n    else:\n        print(ans - minimum_abs * 2)\nif __name__ == '__main__':\n    main()"
  ],
  [
    "from math import gcd\nfrom math import ceil\nn = int(input())\nT = [0] * n\nA = [0] * n\nfor i in range(n):\n    T[i], A[i] = map(int, input().split())\nnum = 2\nt, a = 1, 1\nfor i in range(n):\n    t_rate, a_rate = T[i], A[i]\n    t_mul, a_mul = ceil(t / t_rate), ceil(a / a_rate)\n    mul_num = max(t_mul, a_mul)\n    t, a = mul_num * t_rate, mul_num * a_rate\nprint(t + a)"
  ],
  [
    "n,m = map(int,input().split())\ndp = [[10**9]*(2**n) for _ in range(m+1)]\ndp[0][0] = 0\nfor i in range(m):\n    a,b = map(int,input().split())\n    c = list(map(int,input().split()))\n    res = 0\n    for x in c:\n        res|=1<<(x-1)\n    for j in range(2**n):\n        ni = i+1\n        nj = j|res\n        dp[ni][j] = min(dp[ni][j],dp[i][j])\n        dp[ni][nj] = min(dp[ni][nj],dp[i][j]+a)\nprint(dp[m][2**n-1])"
  ],
  [
    "MOD = 998244353\ndef power(n, p):\n    result = 1\n    while p > 0:\n        if p % 2 == 1:\n            result = (result * n) % MOD\n        n = (n * n) % MOD\n        p //= 2\n    return result\ndef choose(n, k):\n    if k > n - k:\n        k = n - k\n    result = 1\n    for i in range(k):\n        result = (result * (n - i)) % MOD\n        result = (result * power(i + 1, MOD - 2)) % MOD\n    return result\ndef solve(n, m, k):\n    result = 0\n    for i in range(k + 1):\n        result = (result + power(m, i + 1) * choose(n - 1, i) * power(m - 1, n - i)) % MOD\n    return result\nn, m, k = map(int, input().split())\nprint(solve(n, m, k))"
  ],
  [
    "import sys, math, itertools, collections, bisect\ninput = lambda: sys.stdin.buffer.readline().rstrip().decode('utf-8')\ninf = float('inf') ;mod = 10**9+7\nmans = inf ;ans = 0 ;count = 0 ;pro = 1\ndef check(sets):\n  n = len(sets)\n  data = [0]*n\n  count = 0\n  result_bit = 0\n  for j in range(w):\n    tmp = 0\n    tmp = [0]*n\n    for i in range(h):\n      tmp[bisect.bisect_left(sets,i)]+=S[i][j]\n    F = 0\n    for i in range(n):\n      if tmp[i] > K:return -1\n      if data[i] + tmp[i] > K:\n        F = 1\n      else:\n        data[i] += tmp[i]\n    if F:\n      result_bit |= (1<<j-1)\n      for i in range(n):\n        data[i] = tmp[i]\n  return result_bit\n  return  result_bit\nh,w,K = map(int,input().split())\nS = [list(map(int,input())) for i in range(h)]\nfor bit in range((h-1)**2):\n  sets = []\n  for k in range(h-1):\n    if (bit >> k) & 1:\n      sets.append(k)\n  sets.append(h)\n  re = check(sets)\n  if re == -1: continue\n  mans = min(mans,collections.Counter(bin(bit))[\"1\"] + collections.Counter(bin(re))[\"1\"])\nprint(mans)"
  ],
  [
    "A, B, K = map(int, input().split())\nif K <= A:\n  A -= K\n  print(A, B)\nelse:\n  K -= A\n  A = 0\n  if K <= B:\n    B -= K\n    print(A, B)\n  else:\n    B = 0\n    print(A, B)\n"
  ],
  [
    "import sys\ndef input(): return sys.stdin.readline().rstrip()\nfrom operator import itemgetter\ndef main():\n    n=int(input())\n    graph=[[]for _ in range(n)]\n    AB=[tuple(map(int,input().split())) for i in range(n-1)]\n    for a,b in AB:\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n    C=list(map(int,input().split()))\n    C.sort(reverse=True)\n    node=[[i,0,0]for i in range(n)]\n    for i,g in enumerate(graph):\n        node[i][1]=len(g)\n    node.sort(key=itemgetter(1),reverse=True)\n    for i in range(n):\n        node[i][2]=C[i]\n    node.sort(key=itemgetter(0))\n    ans=0\n    for i in range(n-1):\n        a,b=AB[i]\n        ans+=min(node[a-1][2],node[b-1][2])\n    print(ans)\n    print(' '.join(map(str,[x[2] for x in node])))\nif __name__=='__main__':\n    main()"
  ],
  [
    "N = int(input())\nH = list(map(int, input().split()))\nis_thg = True\nfor i in range(N - 1):\n  if H[i] > H[i + 1]:\n    H[i] -= 1\n    if H[i] > H[i + 1]:\n      is_thg = False\n      break\nprint('Yes' if is_thg else 'No')"
  ],
  [
    "import itertools\nn,m,k = map(int,input().split())\ndef judge_pair(block):\n  total = 0\n  for i in range(len(block)):\n    pair = 0\n    for j in range(n-1):\n      if block[i][j]==block[i][j+1]:\n        pair += 1\n    if pair <= k:\n      total +=1\n  return total%998244353\ncolor = [i for i in range(1,m+1)]\ncolors = color*n\nblock = list(itertools.permutations(colors,n))\nblock = list(set(block))\nprint(judge_pair(block))"
  ],
  [
    "print(max(a, b) * max(c, d))\n"
  ],
  [
    "n, c = map(int, input().split())\ncnt = [[0 for _ in range(c + 1)] for _ in range(10 ** 5 + 2)]\ncnt_sum = [0] * (10 ** 5 + 2)\nfor _ in range(n):\n    s, t, _c = map(int, input().split())\n    cnt[s][_c] += 1\n    cnt[t][_c] -= 1\nfor i in range(1, 10 ** 5 + 2):\n    for j in range(1, c + 1):\n        cnt[i][j] += cnt[i - 1][j]\n    cnt_sum[i] = max(cnt_sum[i - 1], sum(cnt[i]))\nprint(max(cnt_sum))"
  ],
  [
    "  def solve(A, B):\n    if A == B:\n        return \"IMPOSSIBLE\"\n    if A < B:\n        smaller = A\n        larger = B\n    else:\n        smaller = B\n        larger = A\n    for i in range(smaller, larger+1):\n        if abs(A-i) == abs(B-i):\n            return i\n    return \"IMPOSSIBLE\""
  ],
  [
    "from collections import defaultdict\nH, W, M = map(int, input().split())\ntargets = [tuple(map(int, input().split())) for _ in range(M)]\nrow_counts = defaultdict(int)\ncol_counts = defaultdict(int)\nfor h, w in targets:\n    row_counts[h] += 1\n    col_counts[w] += 1\nmax_count = 0\nfor h, w in targets:\n    max_count = max(max_count, row_counts[h] + col_counts[w] - 1)\nprint(max_count)\n"
  ],
  [
    "  a = int(input())\nb = int(input())\nc = int(input())\nif b-a == c-b:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
  ],
  [
    "K = int(input())\nN = 2\nwhile K > 0:\n  if K >= N - 1:\n    K -= N - 1\n    N += 1\n  else:\n    N = K + 2\n    K = 0\nprint(N)\na = [0] * N\na[0] = N - 1\nfor i in range(1, N):\n  a[i] = i\nprint(*a)\n"
  ],
  [
    "import sys\ndef bellman_ford(edges, num_vertices):\n    distances = [float('-inf')] * num_vertices\n    distances[0] = 0\n    for _ in range(num_vertices - 1):\n        for u, v, w in edges:\n            if distances[u] + w > distances[v]:\n                distances[v] = distances[u] + w\n    for u, v, w in edges:\n        if distances[u] + w > distances[v]:\n            return float('inf')\n    return distances[-1]\nnum_vertices, num_edges = map(int, sys.stdin.readline().split())\nedges = []\nfor _ in range(num_edges):\n    u, v, w = map(int, sys.stdin.readline().split())\n    edges.append((u - 1, v - 1, w))\nresult = bellman_ford(edges, num_vertices)\nprint('inf' if result == float('inf') else result)\n"
  ],
  [
    "raw = input()\nx1 = int(raw.split(' ')[0])\ny1 = int(raw.split(' ')[1])\nx2 = int(raw.split(' ')[2])\ny2 = int(raw.split(' ')[3])\nd1 = x2 - x1\nd2 = y2 - y1\nx3 = x2 - d2\ny3 = y2 + d1\nx4 = x1 - d2\ny4 = y1 + d1\nprint(x3,y3,x4,y4)"
  ],
  [
    "  n, k = map(int, input().split())\ndef count_combinations(n, k):\n    dp = [[1] * (k+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % (10**9 + 7)\n    return dp[n][k]\nprint(count_combinations(n, k))"
  ],
  [
    "n, k = map(int, input().split())\nnodes = []\nfor i in range(n-1):\n    nodes.append(list(map(int, input().split())))\nqueue = [1]\ncolored = [0] * n\ndef get_node_1(node, target):\n    n_1 = []\n    for node in nodes:\n        if((node[0] == target) and (colored[node[1]-1] == 0)):\n            n_1.append(node[1])\n        elif((node[1] == target) and (colored[node[0]-1] == 0)):\n            n_1.append(node[0])\n    return n_1\ndef get_node_2(node, target):\n    n_2 = []\n    n_1 = get_node_1(node, target)\n    for n1 in n_1:\n        hoge = get_node_1(node, n1)\n        n_2.extend(hoge)\n    n_1.extend(n_2)\n    n_1 = list(set(n_1))\n    if target in n_1:\n        n_1.remove(target)\n    return n_1\ndef get_color_1(node, target):\n    n_1 = []\n    for node in nodes:\n        if((node[0] == target) and (colored[node[1]-1]!= 0)):\n            n_1.append(node[1])\n        elif((node[1] == target) and (colored[node[0]-1]!= 0)):\n            n_1.append(node[0])\n    return n_1\ndef get_color_2(node, target):\n    n_2 = []\n    n_1 = get_color_1(node, target)\n    for n1 in n_1:\n        hoge = get_color_1(node, n1)\n        n_2.extend(hoge)\n    n_1.extend(n_2)\n    return k - len(set(n_1))\nwhile(queue):\n    target = queue.pop(0)\n    colored[target-1] = get_color_2(nodes, target)\n    queue.extend(get_node_2(nodes, target))\n    queue = list(set(queue))\nx = 1\nfor i in colored:\n    x = (x * i) % 1000000007\nprint(x)"
  ],
  [
    "import numpy as np\nfrom numba import njit\n@njit\ndef solve(n,s):\n    dp=np.zeros((n+1,n+1),dtype=int)\n    for i in range(n):\n        for j in range(i+1,n):\n            if s[i]==s[j]:\n                if dp[i][j]<j-i:\n                    dp[i+1][j+1]=dp[i][j]+1\n    return np.amax(dp)\nn=int(input())\ns=input()\nprint(solve(n,s))"
  ],
  [
    "  def get_bill_combination(n, y):\n    if n == 1:\n        if y % 1000 == 0:\n            return [y // 1000, 0, 0]\n        else:\n            return [-1, -1, -1]\n    else:\n        for i in range(n):\n            if y - i * 10000 >= 0:\n                result = get_bill_combination(n - i, y - i * 10000)\n                if result != [-1, -1, -1]:\n                    return [i] + result\n        return [-1, -1, -1]\ndef main():\n    n, y = map(int, input().split())\n    result = get_bill_combination(n, y)\n    print(*result)\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "n = int(input())\ngroups = n // 3\nprint(groups)"
  ],
  [
    "N, M = map(int, input().split())\nif N > M:\n    N, M = M, N\nif N == 1:\n    if M == 1:\n        print(1)\n    else:\n        print(M - 2)\nelse:\n    print((M - 2) * (N - 2))"
  ],
  [
    "n = int(input())\nfor i in range(n, 10000):\n    if len(set(str(i))) == 1:\n        print(i)\n        break"
  ],
  [
    "n,m = map(int,input().split())\nVLIST = list([] for i in range(n*3))\nfor i in range(m):\n  v1,v2 = map(int,input().split())\n  v1_0 = (v1-1)*3\n  v1_1 = (v1-1)*3 + 1\n  v1_2 = (v1-1)*3 + 2\n  v2_0 = (v2-1)*3\n  v2_1 = (v2-1)*3 + 1\n  v2_2 = (v2-1)*3 + 2\n  VLIST[v1_0].append(v2_1)\n  VLIST[v1_1].append(v2_2)\n  VLIST[v1_2].append(v2_0)\ns,t = map(int,input().split())\ns0 = (s-1)*3\nt0 = (t-1)*3\nq = []\nq.extend(VLIST[s0])\nd = 0\nchk = [0]*len(VLIST)\ndp = [0]*len(VLIST)\ndp[s0] = 0\nwhile len(q)>0:\n  i = q.pop(0)\n  d = dp[i]\n  if chk[i]==1:\n    continue\n  if i==t0:\n    print(int(d//3 + 1))\n    exit()\n  q.extend(VLIST[i])\n  for j in VLIST[i]:\n    dp[j] = d+1\n  chk[i] = 1\nprint(-1)"
  ],
  [
    "N = int(input())\nans = []\nM = N + 1 if N % 2 == 0 else N\nfor i in range(1, N + 1):\n    for j in range(i + 1, N + 1):\n        if i + j == M:\n            continue\n        ans.append('{} {}'.format(i, j))\nprint(len(ans))\nprint('\\n'.join(ans))"
  ],
  [
    "import sys\nn, m = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\nbc = [list(map(int, sys.stdin.readline().split())) for _ in range(m)]\na.sort(reverse=True)\nbc.sort(key=lambda x: x[1], reverse=True)\nfor b, c in bc:\n    for i in range(min(b, len(a))):\n        if a[i] < c:\n            a[i] = c\n        else:\n            break\nprint(sum(a))"
  ],
  [
    "  def get_choices(n):\n    choices = []\n    for k in range(2, n+1):\n        while n > 1:\n            if n % k == 0:\n                n //= k\n            else:\n                n -= k\n        choices.append(k)\n    return choices\ndef main():\n    n = int(input())\n    choices = get_choices(n)\n    print(len(choices))\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "def solve(lst):\n    def rec(left, right):\n        if left == right:\n            return 0\n        res = 0\n        if not 0 in lst[left:right]:\n            m = min(lst)\n            for i in range(left, right):\n                lst[i] = lst[i] - m\n            res += m\n        m = 1000\n        for i in range(left, right):\n            if lst[i] > 0:\n                m = min(m, lst[i])\n            else:\n                for j in range(left, i):\n                    lst[j] = lst[j] - m\n                if left != i:\n                    res += m\n                return res + rec(left, i) + rec(i+1, right)\n    return rec(0, len(lst))\nN = int(input())\nlst = list(map(int, input().split()))\nprint(solve(lst))"
  ],
  [
    "n, d, a = map(int, input().split())\nx = []\nh = []\nfor i in range(n):\n    x_, h_ = map(int, input().split())\n    x.append(x_)\n    h.append(h_)\ncount = 0\nfor i in range(n):\n    if h[i] > 0:\n        bombs_needed = (h[i] + a - 1) // a  \n        count += bombs_needed\n        for j in range(i + 1, n):\n            if x[j] <= x[i] + d:  \n                h[j] -= bombs_needed * a\n                if h[j] <= 0:\n                    h[j] = 0\nprint(count)"
  ],
  [
    "n = int(input())\na = []\nb = []\nfor _ in range(n):\n    a_i, b_i = map(int, input().split())\n    a.append(a_i)\n    b.append(b_i)\nimport math\ndef combinationListRecursive(data, r):\n    if r == 0 or r > len(data):\n        return []\n    result = []\n    _combinationListRecursive(data, r, 0, [], result)\n    return result\ndef _combinationListRecursive(data, r, start, progress, result):\n    if r == 0:\n        result.append(progress)\n        return\n    for i in range(start, len(data)):\n        _combinationListRecursive(data, r - 1, i + 1, progress + [data[i]], result)\nresult = combinationListRecursive(range(n), math.ceil(n/2))\nbest = 0\nfor i in result:\n    atmp = 0\n    btmp = 0\n    for k in range(n):\n        if k in i:\n            atmp += a[k]\n        else:\n            btmp += b[k]\n    if best < atmp - btmp:\n        best = atmp - btmp\nprint(best)"
  ],
  [
    "  import sys\ndef is_possible(n, m, a, b):\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        graph[a[i] - 1].append(b[i] - 1)\n        graph[b[i] - 1].append(a[i] - 1)\n    visited = [False] * n\n    queue = [1]\n    while queue:\n        node = queue.pop(0)\n        if node == n:\n            return \"POSSIBLE\"\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    return \"IMPOSSIBLE\"\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().split())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    b = [int(x) for x in sys.stdin.readline().split()]\n    print(is_possible(n, m, a, b))"
  ],
  [
    "N = int(input())\nM = int(input())\nx = [int(input()) for _ in range(N)]\ny = [int(input()) for _ in range(N)]\nz = [int(input()) for _ in range(N)]\ndp = [[0] * (M + 1) for _ in range(N + 1)]\nfor i in range(1, N + 1):\n    for j in range(1, M + 1):\n        dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + x[i - 1] * y[i - 1] * z[i - 1])\nprint(dp[N][M])"
  ],
  [
    "a, b = map(int, input().split())\ncheck = (a*b)%2\nif check ==0:\n    print(\"Even\")\nelse:\n    print(\"Odd\")"
  ],
  [
    "N, K = [int(n) for n in input().split()]\nA = [int(n) for n in input().split()]\nfor i in range(N+1,K+1):\n    if K % i == 0:\n        K = i\n        break\ncount = 0\nfor i in range(1,N+1):\n    A[i-1] = (A[i-1]-1) % K\ncheck = {0: [0]}\ns = 0\nfor i in range(1,N+1):\n    s += A[i-1]\n    if s >= K:\n        s -= K\n    if s in check:\n        check[s] = [j for j in check[s] if i - j < K]\n        count += len(check[s])\n        check[s].append(i)\n    else:\n        check[s] = [i]\nprint(count)"
  ],
  [
    "number_of_elements = int(input())\ninput_list = list(map(int, input().split()))\nresult_list = []\nfor index in range(number_of_elements):\n    result_list.insert(input_list[index] - 1, index + 1)\nif result_list == list(range(1, number_of_elements + 1)):\n    for element in result_list:\n        print(element)\nelse:\n    print(-1)\n"
  ],
  [
    "N, M = map(int, input().split())\nif N % 2 == 0:\n    for i in range(M):\n        print(i + 1, N - i)\nelse:\n    for i in range(M):\n        print(i + 1, N - i - 1)"
  ],
  [
    "def main():\n    import sys\n    import time\n    input = sys.stdin.buffer.readline\n    start = time.time()\n    N = int(input())\n    A = [tuple(map(int, input().split())) for i in range(N)]\n    id = [0]*N\n    Lock = [-1]*N\n    ans = 0\n    min_id = 0\n    M = (N*(N-1)) // 2\n    while(min_id < N-1):\n        now = time.time()\n        if now - start > 2:\n            ans = M+1\n            break\n        ans += 1\n        if ans > M:\n            break\n        tmp = set()\n        for i in range(N):\n            if id[i] >= N-1:\n                continue\n            else:\n                if Lock[i] >= 0:\n                    continue\n                else:\n                    a = A[i][id[i]]\n                    if Lock[a-1] == i and id[a-1] < N-1 and A[a-1][id[a-1]] == i+1 and i not in tmp:\n                        Lock[a-1] = -1\n                        id[a-1] += 1\n                        tmp.add(a-1)\n                        id[i] += 1\n                    else:\n                        if i not in tmp:\n                            Lock[i] = A[i][id[i]]-1\n        min_id = min(id)\n    if ans > M:\n        print(-1)\n    else:\n        print(ans)\nmain()"
  ],
  [
    "L = int(input())\nMOD = 10**9 + 7\nresult = 1\nfor bit_position in range(60, -1, -1):\n    if L & (1 << bit_position):\n        result = (result * (1 << bit_position + 1)) % MOD\nprint(result)\n"
  ],
  [
    "n=int(input())\nl=[]\nfor i in range(0,n):\n  x=int(input())\n  l.append(x)\nr=set(l)\nprint(len(r))"
  ],
  [
    "A, B, K = map(int, input().split())\nif K <= A:\n    A -= K\nelse:\n    A = 0\n    K -= A\n    if K <= B:\n        B -= K\nprint(A, B)\n"
  ],
  [
    "import math\nx, y = map(int, input().split())\na = x * y // math.gcd(x, y)\na -= x\nif a > 0 and a <= 10**18:\n    print(int(a))\nelse:\n    print(-1)"
  ],
  [
    "n = int(input())\nm = [int(i) for i in input().split()]\nins = []\nl = sorted(m)\nif abs(l[-1]) > abs(l[0]):\n    highest = m.index(l[-1])\n    for i in range(len(m)-1):\n        if m[i] > m[i+1]:\n            m[i+1] += ((abs(m[i+1]-m[i])//abs(highest))+1)\n            ins.extend([str(highest+1)+\" \"+str(i+2)] * ((abs(m[i+1]-m[i])//abs(highest))+1))\nelse:\n    lowest = m.index(l[0])\n    for i in range(len(m)-1,0,-1):\n        if m[i] < m[i-1]:\n            m[i] += ((abs(m[i-1]-m[i])//abs(lowest))+1)\n            ins.extend([str(lowest+1)+\" \"+str(i)] * ((abs(m[i-1]-m[i])//abs(lowest))))\nprint(len(ins))\nfor i in ins:\n    print(i)"
  ],
  [
    "def solve(n, k, v):\n    dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n            if i > 1:\n                dp[i][j] = max(dp[i][j], dp[i - 2][j - 1] + v[i - 1] + v[i])\n            if i < n:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + v[i - 1] + v[i + 1])\n            if i > 1 and i < n:\n                dp[i][j] = max(dp[i][j], dp[i - 2][j - 1] + v[i - 1] + v[i + 1])\n    return dp[n][k]\nn, k = map(int, input().split())\nv = list(map(int, input().split()))\nprint(solve(n, k, v))\n"
  ],
  [
    "n,u,v = map(int,input().split())\nedge = [[] for i in range(n+1)]\ndistt = [0 for i in range(n+1)]\ndista = [0 for i in range(n+1)]\nfor i in range(n-1):\n    a, b = map(int, input().split())\n    edge[a].append(b)\n    edge[b].append(a)\ndef tdfs(x, last = -1):\n    for to in edge[x]:\n        if(to == last):\n            continue\n        distt[to] = distt[x] + 1\n        tdfs(to, x)\ndef adfs(x, last = -1):\n    for to in edge[x]:\n        if(to == last):\n            continue\n        dista[to] = dista[x] + 1\n        adfs(to, x)\ntdfs(u)\nadfs(v)\nans = 0\nfor i in range(1, n+1):\n    if distt[i] >= dista[i]:\n        continue\n    l = distt[i]\n    k = dista[i] - distt[i]\n    ans = max(ans, k - 1 + l)\nprint(ans)"
  ],
  [
    "import sys\nimport bisect\nsys.setrecursionlimit(10 ** 6)\nclass SegTree:\n    def __init__(self, N):\n        self.N = N\n        self.data = [0] * (2 * N)\n    def update(self, i, x):\n        i += self.N - 1\n        self.data[i] = x\n        while i > 0:\n            i = (i - 1) // 2\n            v = self.data[2 * i + 1] + self.data[2 * i + 2]\n            self.data[i] = v\n    def query(self, a, b, k, l, r):\n        if r <= a or b <= l:\n            return 0\n        if a <= l and r <= b:\n            return self.data[k]\n        else:\n            v = self.query(a, b, 2 * k + 1, l, (l + r) // 2)\n            w = self.query(a, b, 2 * k + 2, (l + r) // 2, r)\n            return v + w\ndef main():\n    N, D, A = list(map(int, input().split(' ')))\n    pw2_N = 1\n    while pw2_N < N:\n        pw2_N *= 2\n    monsters = [list(map(int, input().split(' '))) for _ in range(N)]\n    monsters.sort()\n    counts = [(h + A - 1) // A for _, h in monsters]\n    X = [x for x, _ in monsters]\n    diffs = [(counts[i] - counts[i - 1]) if i > 0 else counts[i] for i in range(N)]\n    tree = SegTree(pw2_N)\n    for i, d in enumerate(diffs):\n        tree.update(i, d)\n    ans = 0\n    for i in range(N):\n        ci = tree.query(0, i + 1, 0, 0, pw2_N)\n        if ci <= 0:\n            continue\n        ans += ci\n        r = X[i] + 2 * D\n        j = bisect.bisect_right(X, r)\n        di = tree.query(i, i + 1, 0, 0, pw2_N)\n        dj = tree.query(j, j + 1, 0, 0, pw2_N)\n        tree.update(i, di - ci)\n        tree.update(j, dj + ci)\n    print(ans)\nif __name__ == '__main__':\n    main()"
  ],
  [
    "def solve(s, t):\n    if len(s) != len(t):\n        return \"No\"\n    count = {}\n    for c in s:\n        if c not in count:\n            count[c] = 0\n        count[c] += 1\n    for c in t:\n        if c not in count:\n            return \"No\"\n        count[c] -= 1\n    for v in count.values():\n        if v != 0:\n            return \"No\"\n    return \"Yes\"\ns = input()\nt = input()\nprint(solve(s, t))\n"
  ],
  [
    "N, C = map(int, input().split())\nf = [[0] * 100001 for _ in range(C)]\nfor i in range(N):\n    s, t, c = map(int, input().split())\n    f[c-1][s] += 1\n    f[c-1][t] -= 1\nfor c in range(C):\n    for i in range(1, 100001):\n        f[c][i] += f[c][i-1]\nprint(max(map(sum, zip(*f))))"
  ],
  [
    "  def can_arrange_to_1974(n1, n2, n3, n4):\n    digits = [n1, n2, n3, n4]\n    if len(digits) != 4:\n        return False\n    if digits[0] != 1:\n        return False\n    if digits[1] != 9:\n        return False\n    if digits[2] != 7:\n        return False\n    if digits[3] != 4:\n        return False\n    return True\ndef main():\n    n1, n2, n3, n4 = list(map(int, input().split()))\n    if can_arrange_to_1974(n1, n2, n3, n4):\n        print(\"YES\")\n    else:\n        print(\"NO\")\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "N = int(input())\nseats = set()\nfor i in range(N):\n    l, r = map(int, input().split())\n    for j in range(l, r + 1):\n        seats.add(j)\nprint(len(seats))\n"
  ],
  [
    "def solve(H, spells):\n    dp = [float('inf')] * (H + 1)\n    dp[0] = 0\n    for i in range(1, H + 1):\n        for a, b in spells:\n            if i - a >= 0:\n                dp[i] = min(dp[i], dp[i - a] + b)\n    return dp[H]\nH, N = map(int, input().split())\nspells = []\nfor _ in range(N):\n    a, b = map(int, input().split())\n    spells.append((a, b))\nprint(solve(H, spells))\n"
  ],
  [
    "n, a, b = map(int, input().split())\nresult = 0\nmod = 10**9 + 7\npower_of_2 = [1]\nfor i in range(n):\n    power_of_2.append((power_of_2[-1] * 2) % mod)\nfor i in range(1, n + 1):\n    if i!= a and i!= b:\n        result = (result + power_of_2[i - 1]) % mod\nprint(result)\n"
  ],
  [
    "import math\nn = int(input())\na = list(map(int, input().split()))\nans = a[0]\nA = []\nfor x in a[1:]:\n    ans = math.gcd(ans, x)\n    A.append(x)\nif ans == 1:\n    gcd_values = [math.gcd(A[i], A[j]) for i in range(len(A)) for j in range(i+1, len(A))]\n    if all(gcd_values == [1]):\n        print('pairwise coprime')\n    else:\n        print('setwise coprime')\nelse:\n    print('not coprime')"
  ],
  [
    "x_1, x_2, x_3, x_4, x_5 = map(int, input().split())\nif x_1 == 0:\n    print(1)\nelif x_2 == 0:\n    print(2)\nelif x_3 == 0:\n    print(3)\nelif x_4 == 0:\n    print(4)\nelse:\n    print(5)\n"
  ],
  [
    "d = zip(input(), input())\nprint(\"\".join(i[0] + i[1] for i in d))"
  ],
  [
    "n=int(input())\nabs=[]*n\nfor i in range(n-1):\n    abs.append(list(map(int,input().split())))\ncs=list(map(int,input().split()))\ncnt=[0]*n\nfor i in range(n-1):\n    ma=max(cnt[abs[i][0]-1], cnt[abs[i][1]-1])\n    ma+=1\n    cnt[abs[i][0]-1]=ma\n    cnt[abs[i][1]-1]=ma\nfor i in range(n-1):\n    ma=max(cnt[abs[i][0]-1], cnt[abs[i][1]-1])\n    cnt[abs[i][0]-1]=ma\n    cnt[abs[i][1]-1]=ma\nans=[0]*n\nfor i in range(n):\n    ans[cnt.index(max(cnt))]=max(cs)\n    cnt[cnt.index(max(cnt))]=0\n    cs[cs.index(max(cs))]=0\nprint(sum(ans))\nprint(*ans)"
  ],
  [
    "N = int(input())\na_list = list(map(int, input().split()))\ntotal_sum = sum(a_list)\nmin_diff = float('inf')\nleft_sum = 0\nfor i in range(1, N):\n    left_sum += a_list[i - 1]\n    right_sum = total_sum - left_sum\n    diff = abs(left_sum - right_sum)\n    min_diff = min(min_diff, diff)\nprint(min_diff)"
  ],
  [
    "n = int(input())\na = list(map(int, input().split()))\nans = 0\nfor i in range(n):\n  ans += abs(a[i])\nprint(ans)\n"
  ],
  [
    "n, a, b = map(int, input().split())\nans = 0\nfor i in range(n - 1):\n    ans += max(a * (x[i + 1] - x[i]), b)\nprint(ans)"
  ],
  [
    "  from typing import List\ndef max_happiness(dishes: List[List[int]], time: int) -> int:\n    dishes.sort(key=lambda x: x[1], reverse=True)\n    max_happiness = 0\n    time_spent = 0\n    for dish in dishes:\n        if time_spent + dish[0] <= time:\n            max_happiness += dish[1]\n            time_spent += dish[0]\n    return max_happiness\ndef main():\n    n, t = map(int, input().split())\n    dishes = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        dishes.append([a, b])\n    max_happiness = max_happiness(dishes, t)\n    print(max_happiness)\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "n=int(input())\nx=0\ncnt=0\nfor i in range(n):\n    a=int(input())\n    x=max(a,x)\n    cnt+=a\nif x==1:\n    print(\"first\")\nelse:\n    if (cnt-2)%2==1:\n        print(\"first\")\n    else:\n        print(\"second\")"
  ],
  [
    "import sys\ndef input(): return sys.stdin.readline().rstrip()\nfrom collections import deque\ndef main():\n    n=int(input())\n    A=list(map(int,input().split()))\n    A.sort(reverse=True)\n    Large=deque(A)\n    Small=deque()\n    while len(Large)>=2:\n        if Large[-1]>=0:break\n        Small.append(Large.pop())\n    if not Small:Small.append(Large.pop())\n    ans=[]\n    while len(Large)>=2:\n        a=Large.pop()\n        b=Small.pop()\n        ans.append((b,a))\n        Small.append(b-a)\n    large=Large.pop()\n    while len(Small)>=2:\n        b=Small.popleft()\n        ans.append((b,large))\n        large+=-b\n    small=Small.pop()\n    ans.append((large,small))\n    print(large-small)\n    for a,b in ans:\n        print(a,b)\nif __name__=='__main__':\n    main()"
  ],
  [
    "def longest_even_string(s):\n    n = len(s)\n    for i in range(n // 2, 0, -1):\n        if s[:i] == s[i:2 * i]:\n            return 2 * i\n    return 0\ns = input()\nprint(longest_even_string(s))\n"
  ],
  [
    "n = input()\nb = list(n)\nc = 0\nd = 0\nwhile c <= len(b) - 3:\n    if (b[c+1] > b[c] and b[c+1] < b[c+2]) or (b[c+1] < b[c] and b[c+1] > b[c+2]):\n        d += 1\n        c += 1\n    else:\n        c += 1\nif len(set(b)) == 2 and d == 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
  ],
  [
    "N=int(input())\nA=list(map(int,input().split()))\nA.sort(reverse=True)\nans=A[0]\nif N>2:\n    p = (N-2)//2\n    q = (N-2)%2\n    ans += 2*sum(A[1:min(1+p, len(A))])\n    if q==1 and 1+p<len(A):\n        ans += A[1+p]\nprint(ans)"
  ],
  [
    "N = int(input())\nA = list(map(int,input().split()))\ndp = [0]*(N//2)\ndp[0] = A[0]\ndp[1] = max(A[0], A[1])\nfor i in range(2, N):\n    dp[i//2] = max(dp[(i-2)//2] + A[i], dp[(i-1)//2])\nprint(dp[N//2 - 1])"
  ],
  [
    "v = [int(d) for d in input().split()]\nf = []\nfor e in range(v[0]):\n    f.append(input())\nre = 0\nfor d in f:\n    re += d.count('AB')\ndd = [list(s) for s in f]\nb = 0\na = 0\ncoo= 0\nfor q in dd:\n    if q[0] == 'B':\n        b += 1\n    if q[-1] == 'A':\n        a += 1\n        if q[0] == 'B':\n            coo += 1\nif a > b:\n    ss = b\nelif a < b:\n    ss = a\nelse:\n    ss = a\nif ss == coo:\n    if ss == b:\n        if ss == a:\n            if ss != 0:\n                ss -= 1\nprint(re + ss)"
  ],
  [
    "num = int(input())\nac = 0\nwa = 0\ntle = 0\nre = 0\nfor i in range(num):\n    word = input()\n    if word == \"AC\":\n        ac = ac + 1\n    elif word == \"WA\":\n        wa = wa + 1\n    elif word == \"TLE\":\n        tle = tle + 1\n    elif word == \"RE\":\n        re = re + 1\nprint(\"AC x \",ac)\nprint(\"WA x \",wa)\nprint(\"TLE x \",tle)\nprint(\"RE x \",re)"
  ],
  [
    "n, m, k = map(int, input().split())\nmod = 998244353\nans = (m * (pow(m - 1, n - 1, mod))) % mod\nnCn = 1\nfor i in range(1, k + 1):\n    nCn = (nCn * (n - i)) // i\n    nCn = nCn % mod\n    ans += (((m * (nCn)) % mod) * (pow(m - 1, n - 1 - i, mod))) % mod\n    ans = ans % mod\nprint(ans)"
  ],
  [
    "s=input();print(s[::-1])"
  ],
  [
    "  def get_max_gcd(numbers):\n    max_gcd = 0\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            gcd = math.gcd(numbers[i], numbers[j])\n            if gcd > max_gcd:\n                max_gcd = gcd\n    return max_gcd\ndef main():\n    n = int(input())\n    numbers = list(map(int, input().split()))\n    max_gcd = get_max_gcd(numbers)\n    print(max_gcd)\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "h, w, n = map(int, input().split())\nlst = [tuple(input().split()) for i in range(n)]\nans = [0] * 10\nif n == 0:\n    ans[0] = 999999996000000004\n    ans = map(str, ans)\n    print('\\n'.join(ans))\n    exit(0)\nstage = [[0] * w for i in range(h)]\nfor t in lst:\n    stage[int(t[0]) - 1][int(t[1]) - 1] = 1\ntmp = []\nfor col in range(h - 3 + 1):\n    for row in range(w - 3 + 1):\n        tmp = []\n        for cc in range(3):\n            tmp.append(stage[col + cc][row:row+3])  \n        one_list = sum(tmp, [])\n        c = one_list.count(1)\n        ans[c] += 1\nprint('\\n'.join(map(str, ans)))"
  ],
  [
    "n, p = map(int, input().split())\na = list(map(int, input().split()))\nans = 1\nfor i in range(n):\n  if a[i] % 2 == 1:\n    ans *= 2\nif p == 1:\n  ans //= 2\nprint(ans)\n"
  ],
  [
    "n = int(input())\nd = list(map(int, input().split()))\nd.sort()\ncount = 0\nfor i in range(n):\n    if d[i] <= d[n // 2] and d[n // 2 - 1] < d[i]:\n        count += 1\nprint(count)\n"
  ],
  [
    "N,M = input().split()\nN,M = int(N),int(M)\na = [0 for i in range(M)]\nb = [[] for i in range(M)]\nfor k in range(M):\n    a[k],b_ = input().split()\n    a[k],b_ = int(a[k]),int(b_)\n    b[k] = input().split()\n    b[k] = [int(j)-1 for j in b[k]]\ndef box(i, bo, memo):\n    if i == N:\n        return 0 if all(bo) else float('inf')\n    if (i, tuple(bo)) in memo:\n        return memo[(i, tuple(bo))]\n    p1 = box(i+1, bo, memo)\n    new_bo = list(bo)\n    for k in b[i]:\n        new_bo[k] = 1\n    p2 = box(i+1, new_bo, memo) + a[i]\n    memo[(i, tuple(bo))] = min(p1, p2)\n    return memo[(i, tuple(bo))]\nbox_ = [0 for _ in range(N)]\nmemo = {}\nnum = box(0, box_, memo)\nprint(-1 if num == float('inf') else num)"
  ],
  [
    "  def solve(A, B, K):\n    takahashi = A\n    aoki = B\n    for _ in range(K):\n        if takahashi > 0:\n            takahashi -= 1\n        elif aoki > 0:\n            aoki -= 1\n    return takahashi, aoki"
  ],
  [
    "n = int(input())\nd = list(map(int, input().split()))\nd.sort()\ncnt = 0\nfor i in range(n // 2):\n    if d[i] == d[n // 2 - 1]:\n        cnt += 1\n    elif d[i] < d[n // 2 - 1] and d[i + n // 2] >= d[n // 2 - 1]:\n        cnt += 1\nprint(cnt)\n"
  ],
  [
    "  def get_total_candies(n):\n    return sum(range(1, n + 1))"
  ],
  [
    "N, K = map(int, input().split())\nV = list(map(int, input().split()))\nans = 0\nfor pick in range(min(K+1, N+1)):\n    for right in range(pick+1):\n        left = pick - right\n        pick_list = V[:right] + V[N-left:]\n        pick_list.sort()\n        tmp_ans = sum(pick_list)\n        rem = min(K - pick, len(pick_list))\n        for i in range(rem):\n            if pick_list[i] < 0:\n                tmp_ans -= pick_list[i]\n            else:\n                break\n        ans = max(tmp_ans, ans)\nprint(ans)"
  ],
  [
    "a,b,c=map(int,input().split())\nif a<b:\n      if a<c<b:\n          print(\"Yes\")\n      else:\n          print(\"No\")\nelif b<a:\n      if b<c<a:\n          print(\"Yes\")\n      else:\n          print(\"No\")\nelse:\n      print(\"No\")"
  ],
  [
    "  def get_kth_char(s, k):\n    for i in range(500000000000000):\n        s = s.replace('1', '11').replace('2', '22').replace('3', '333').replace('4', '4444').replace('5', '55555').replace('6', '666666').replace('7', '7777777').replace('8', '88888888').replace('9', '999999999')\n    return s[k-1]\ns = input()\nk = int(input())\nprint(get_kth_char(s, k))"
  ],
  [
    "import sys\nimport collections\nimport copy\nimport math\ninput = sys.stdin.readline\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nA_sum = sum(A)\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i!= n // i:\n                divisors.append(n//i)\n    divisors.sort(reverse=True)\n    return divisors\nchk = make_divisors(A_sum)\nflag = 0\nfor i in range(len(chk)):\n    trial = chk[i]\n    count = 0\n    coll = trial\n    count += A[0] % trial\n    mod_list = [A[0] % trial]\n    for j in range(1, N):\n        count += A[j] % trial\n        mod_list.append(A[j] % trial)\n    ans = count // trial\n    mod_list.sort(reverse=True)\n    test = 0\n    for j in range(ans):\n        test += trial - mod_list[j]\n    if test > K:\n        continue\n    else:\n        print(trial)\n        break"
  ],
  [
    "L, N = map(int, input().split())\nX = []\nfor i in range(N):\n    a = int(input())\n    X.append(a)\nimport math\nif N == 0:\n    result = 0\nelif X[math.ceil(N/2)-1] < L/2:\n    result = X[N-1]\n    i = 0\n    j = N-1\n    while i <= math.floor(N/2)-1 and j >= math.ceil(N/2)-1:\n        result += abs(X[j]-X[i])\n        j -= 1\n        i += 1\nelse:\n    result = 0\n    i = 0\n    j = N-1\n    while i <= math.floor(N/2)-1 and j >= math.ceil(N/2)-1:\n        result += abs(X[i]-X[j])\n        j -= 1\n        i += 1\nprint(result)"
  ],
  [
    "from collections import deque\ninput_string = input()\nstring_length = len(input_string)\nstack = deque()\ncount = 0\nfor char in input_string:\n    if char == 'C':\n        stack.append('C')\n    elif char == 'B':\n        if stack:\n            stack.append('B')\n    elif char == 'A':\n        if stack and stack[-1] == 'B':\n            stack.pop()\n            if stack and stack[-1] == 'B':\n                stack.pop()\n                count += 1\nprint(count)\n"
  ],
  [
    "s = list(input())\nif \"a\" in s and \"b\" in s and \"c\" in s:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
  ],
  [
    "n, k = map(int, input().split())\nmod = pow(10, 9) + 7\ndef cmb(n, r):\n    res = 1\n    fac = 1\n    for i in range(r):\n        res *= (n-i)\n        res %= mod\n        fac *= (i+1)\n        fac %= mod\n    return res*pow(fac, mod-2, mod) % mod\nif n <= k-1:\n    print(cmb(2*n-1, n))\nelse:\n    answer = 0\n    for m in range(k+1):\n        answer += cmb(n, m)*cmb(n-1, k-m) % mod\nprint(answer % mod)"
  ],
  [
    "n = int(input())\na = [int(s) for s in input().split(\" \")]\ndic_a = {}\nfor aa in a:\n  if aa in dic_a:\n    dic_a[aa] += 1\n  else:\n    dic_a[aa] = 1\na_set = list(dic_a.keys())\nn_set = len(a_set)\nif (n < 3):\n  ans = False\nelse:\n  ans = False\n  if 0 in a_set:\n    for k, v in dic_a.items():\n      if v >= 2 and k != 0:\n        ans = True\n        break\n  if not ans:\n    for i in range(n_set):\n      for j in range(i + 1, n_set):\n        a_ij = a_set[i] ^ a_set[j]\n        if a_ij in a_set and\\\n           a_ij != a_set[i] and\\\n           a_ij != a_set[j]:\n          ans = True\n          break\n      if ans:\n        break\nprint(\"Yes\" if ans else \"No\")"
  ],
  [
    "print(a,b)\ns,t = input().split()\na,b = map(int,input().split())\nu = input()\nif u == s:\n    a -= 1\nelse:\n    b -= 1\nprint(a,b)"
  ],
  [
    "import copy\nS_list = list(input())\nK = int(input())\nif len(S_list) == 1:\n    print(K // 2)\nelif len(S_list) == 2:\n    if S_list[0] == S_list[1]:\n        print(K)\n    else:\n        print(0)\nelse:\n    S2_list = copy.copy(S_list)\n    for i in range(1, len(S_list)):\n        if S_list[i - 1] == S_list[i]:\n            S_list[i] = \"change\"\n    if S_list[0] == S_list[-1]:\n        S2_list[0] = \"change\"\n        for i in range(1, len(S2_list)):\n            if S2_list[i - 1] == S2_list[i]:\n                S2_list[i] = \"change\"\n        print((K // 2 + 1) * S_list.count('change') + (K // 2) * S2_list.count('change'))\n    else:\n        print(K * S_list.count('change'))"
  ],
  [
    "n = int(input())\nheights = list(map(int, input().split()))\ntotal_operations = 0\nfor i in range(n):\n    diff = heights[i] - (total_operations if i > 0 else 0)\n    if diff > 0:\n        total_operations += diff\nprint(total_operations)\n"
  ],
  [
    "n = int(input())\nans = 0\nfor i in range(1, n + 1):\n    ans += i\nprint(ans)"
  ],
  [
    "  import math\ndef count_sums(N, K):\n    MOD = 10**9 + 7\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for i in range(1, N + 1):\n        for j in range(1, K + 1):\n            if i - j >= 0:\n                dp[i] += dp[i - j]\n                dp[i] %= MOD\n    return dp[N]\nN, K = map(int, input().split())\nprint(count_sums(N, K))"
  ],
  [
    "a = int(input())\nif 400 <= a <= 599:\n    print(8)\nelif 600 <= a <= 799:\n    print(7)\nelif 800 <= a <= 999:\n    print(6)\nelif 1000 <= a <= 1199:\n    print(5)\nelif 1200 <= a <= 1399:\n    print(4)\nelif 1400 <= a <= 1599:\n    print(3)\nelif 1600 <= a <= 1799:\n    print(2)\nelse:\n    print(1)"
  ],
  [
    "  def get_lunlun_number(k):\n    lunlun_numbers = []\n    for i in range(1, 1000000000):\n        if is_lunlun_number(i):\n            lunlun_numbers.append(i)\n        if len(lunlun_numbers) == k:\n            return lunlun_numbers[-1]\n    return None\ndef is_lunlun_number(n):\n    digits = []\n    while n > 0:\n        digits.append(n % 10)\n        n //= 10\n    for i in range(len(digits) - 1):\n        if abs(digits[i] - digits[i + 1]) > 1:\n            return False\n    return True\ndef main():\n    k = int(input())\n    print(get_lunlun_number(k))\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "n, a = map(int, input().strip().split())\naaa = list(map(int, input().strip().split()))\naaa = sorted(aaa, reverse=True)\nh = 0\nfor i in range(a, n):\n  h += aaa[i]\nfor i in range(a):\n  if aaa[i] > 0:\n    h += aaa[i] - 1\nprint(h)"
  ],
  [
    "raw = input()\nx1 = int(raw.split(' ')[0])\ny1 = int(raw.split(' ')[1])\nx2 = int(raw.split(' ')[2])\ny2 = int(raw.split(' ')[3])\nd1 = x2 - x1\nd2 = y2 - y1\nx3 = x2 - d2\ny3 = y2 + d1\nx4 = x1 - d2\ny4 = y1 + d1\nprint(x3,y3,x4,y4)"
  ],
  [
    "  print(R+100*(10-K))\nN,R = map(int,input().split())\nif N >= 10:\n  print(R)\nelse:\n  print(R+100*(10-N))"
  ],
  [
    "n = int(input())\nones_digit = n % 10\nif ones_digit in [2, 4, 5, 7, 9]:\n  print(\"hon\")\nelif ones_digit in [0, 1, 6, 8]:\n  print(\"pon\")\nelse:\n  print(\"bon\")"
  ],
  [
    "def solve_tree_problem():\n    n = int(input())\n    a = list(map(int, input().split()))\n    total_nodes = (1 << (n + 1)) - 1\n    if sum(a)!= total_nodes or any(x > (1 << i) for i, x in enumerate(a)):\n        return -1\n    total_nodes = 1\n    for i in range(n - 1, -1, -1):\n        parent_nodes = a[i]\n        while parent_nodes % 2 == 1:\n            parent_nodes += 1\n        parent_nodes //= 2\n        total_nodes += parent_nodes\n        parent_nodes //= 2\n    return total_nodes\nprint(solve_tree_problem())\n"
  ],
  [
    "IN = input().split()\nN = int(IN[0])\nX = int(IN[1])\nBP = 'P'\nfor i in range(N):\n    BP = 'B' + BP + 'P' + BP + 'B'\n    if len(BP) >= X:\n        break\nBP = BP[-X:]\nprint(BP.count(\"P\"))"
  ],
  [
    "import fractions\nmod = 10**9+7\nn = int(input())\na = list(map(int, input().split()))\nif n == 1:\n    print(a[0])\n    exit()\ng = fractions.gcd(a[0], a[1])\nf = a[0]*a[1]//g\nans = a[0]//g+a[1]//g\nfor i in range(2, n):\n    h = fractions.gcd(f, a[i])\n    g = a[i] // h % mod\n    f = f*a[i]// h\n    ans *= g\n    ans += f // a[i]\n    ans %= mod\nprint(ans)"
  ],
  [
    "import numpy as np\nfrom numpy import array, matrix\nN, M = [int(n) for n in input().split()]\npre_x_ = array([int(n) for n in input().split()])\npre_y_ = array([int(n) for n in input().split()])\nx_ = pre_x_[1:N] - pre_x_[0:N-1]\ny_ = pre_y_[1:M] - pre_y_[0:M-1]\nx_length_arr = np.zeros(int(N * (N-1)/2))\ny_length_arr = np.zeros(int(M * (M-1)/2))\nx_past_sets = np.zeros(N)\ny_past_sets = np.zeros(M)\nfor n in range(N-1):\n    x_past_sets += array([x_[n]]*(n+1) + [0] * (N-n-2))\n    x_length_arr[int(n*(n+1)/2):int((n+1)*(n+2)/2)-1] = x_past_sets[0:n+1]\nfor m in range(M-1):\n    y_past_sets += array([y_[m]]*(m+1) + [0] * (M-m-2))\n    y_length_arr[int(m*(m+1)/2):int((m+1)*(m+2)/2)-1] = y_past_sets[0:m+1]\nx_length_mat = matrix(x_length_arr)\ny_length_mat = matrix(y_length_arr)\nprint(int((y_length_mat.T @ x_length_mat).sum() % (10**9+7)))"
  ],
  [
    "import math\nn, k, s = map(int, input().split())\na = [0] * n\npairs_needed = k\na[0] = s\nfor i in range(1, n):\n  max_val = min(s - a[i - 1], 10 ** 9)\n  if pairs_needed > 0:\n    a[i] = max_val\n    pairs_needed -= 1\n  else:\n    a[i] = 1\nprint(*a)\n"
  ],
  [
    "  def count_pairs(A):\n    N = len(A)\n    count = 0\n    for l in range(N):\n        for r in range(l, N):\n            if xor(A[l:r+1]) == sum(A[l:r+1]):\n                count += 1\n    return count\ndef xor(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result"
  ],
  [
    "n, k = map(int, input().split())\nr, s, p = map(int, input().split())\nt = input()\nmax_scores = [0] * (k + 1)\ncurrent_max = 0\nfor i in range(n):\n    if i >= k:\n        current_max = max(max_scores[i - k], current_max)\n    if t[i] == 'r':\n        max_scores[i % (k + 1)] = current_max + p\n    elif t[i] =='s':\n        max_scores[i % (k + 1)] = current_max + r\n    else:\n        max_scores[i % (k + 1)] = current_max + s\nprint(max(max_scores))\n"
  ],
  [
    "s = input()\nt = input()\ni = 0\nj = 0\nwhile j < len(t):\n  if i == len(s):\n    i = 0\n  if s[i] == t[j]:\n    j += 1\n  i += 1\nif j == len(t):\n  print(i)\nelse:\n  print(-1)"
  ],
  [
    "from bisect import bisect_right\nn = int(input())\ns = input()\nans = 0\npos = [\n    [] for _ in range(10)\n]\ndef find_gt(a, x):\n    'Find leftmost value greater than x'\n    i = bisect_right(a, x)\n    if i != len(a):\n        return a[i]\n    return None\nfor j in range(n):\n    pos[int(s[j])].append(j)\nfor i in range(1000):\n    t = '000' + str(i)\n    t = t[-3:]\n    a, b, c = map(int, tuple(t))\n    p = -1\n    p = find_gt(pos[a], p)\n    if p is None:\n        continue\n    q = find_gt(pos[b], p)\n    if q is None:\n        continue\n    r = find_gt(pos[c], q)\n    if r is None:\n        continue\n    ans += 1\nprint(ans)"
  ],
  [
    "a = int(input())\ns = input()\nif a < 3200:\n    print(\"red\")\nelse:\n    print(s)"
  ],
  [
    "H1, M1, H2, M2, K = map(int, input().split())\nstart_time = H1 * 60 + M1\nend_time = H2 * 60 + M2\nstudy_period = end_time - start_time - K\nstudy_period = max(0, study_period)\nprint(study_period)\n"
  ],
  [
    "def solve(xv_sorted):\n    x = [0 for _ in range(n)]\n    y = [0 for _ in range(n)]\n    s = 0\n    buf = -float('inf')\n    for i in range(n):\n        s += xv_sorted[i][1]\n        x[i] = max(buf, s - 2 * xv_sorted[i][0])\n        buf = x[i]\n    s = 0\n    buf = -float('inf')\n    for i in sorted(range(n), reverse=True):\n        s += xv_sorted[i][1]\n        y[i] = max(buf, s - (c - xv_sorted[i][0]))\n        buf = y[i]\n    ans = max(x[n - 1], y[0])\n    for i in range(n - 1):\n        ans = max(ans, x[i] + y[i + 1])\n    return ans\nif __name__ == '__main__':\n    n, c = map(int, input().split())\n    xv = []\n    for i in range(n):\n        xv.append(list(map(int, input().split())))\n    xv_sorted = sorted(xv, key=lambda x:x[0])\n    ans = 0\n    ans = max(ans, solve(xv_sorted))\n    for i in range(n):\n        xv_sorted[i][0] = c - xv_sorted[i][0]\n    xv_sorted = sorted(xv, key=lambda x:x[0])\n    ans = max(ans, solve(xv_sorted))\n    print(ans)"
  ],
  [
    "a, b, c = map(int, input().split())\nif a + b + c >= 22:\n    print(\"bust\")\nelse:\n    print(\"win\")"
  ],
  [
    "import itertools\nint_x = int(input())\nanswer = int_x\nfor i in range(1, int_x + 1):\n    for v in itertools.combinations(range(1, int_x + 1), i):\n        if sum(v) == int_x:\n            answer = min(answer, max(v))\nprint(answer)"
  ],
  [
    "s=input()\ndef check(word):\n    word_set=list(set([i for i in word]))\n    for j in range(len(word_set)):\n        if word.count(word_set[j])%2==1:\n            return False\n    return True\nfor i in range(1,len(s)//2+1):\n    string=s[0:len(s)-i]\n    if check(string):\n        print(len(string))\n        break"
  ],
  [
    "n = int(input())\ntotal_operations = 0\ncurrent_value = 0\nfor _ in range(n):\n    current_value, divisor = map(int, input().split())\n    remainder = current_value % divisor\n    if remainder!= 0:\n        operations = divisor - remainder\n        total_operations += operations\n        current_value -= operations\n    button_presses = current_value // divisor\n    total_operations += button_presses\nprint(total_operations)\n"
  ],
  [
    "r = int(input())\nx = list(map(int, input().split()))\nsetx = list(set(x))\nsetx.sort()\ncx = []\nfor i in setx:\n    cx.append(x.count(i))\nans = 0\nA = 0\nwhile A <= len(setx) - 3:\n    B = A + 1\n    while B <= len(setx) - 2:\n        C = B + 1\n        while C <= len(setx) - 1:\n            if setx[A] + setx[B] > setx[C]:\n                ans += cx[A] * cx[B] * cx[C]\n            C += 1\n        B += 1\n    A += 1\nprint(ans)"
  ],
  [
    "n = int(input())\na = []\nm = 0\nfor i in range(1, n):\n    if m >= n: break\n    a.append(i)\n    m += i\nif m == n:\n    print(*a)\nelse:\n    a.pop(m-n)\n    print(*a)"
  ],
  [
    "import heapq\nN,K = (int(x) for x in input().split())\nH = list((-1)*(int(x)) for x in input().split())\nheapq.heapify(H)\nfor _ in range(K):\n    if len(H) == 1:\n        print(0)\n        break\n    heapq.heappop(H)\nif len(H) != 1:\n    sum = 0\n    while len(H) > 0:\n        sum -= heapq.heappop(H)\n    print(sum)"
  ],
  [
    "A, B, C = map(int, input().split())\nif A + B + C == 17:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
  ],
  [
    "n, a, b = map(int, input().split())\nx = list(map(int, input().split()))\ndistances = [x[i] - x[i - 1] for i in range(1, n)]\ndp = [0] * n\ndp[0] = 0\nfor i in range(1, n):\n    dp[i] = min(dp[i - 1] + a * distances[i - 1], dp[i - 1] + b)\nprint(dp[n - 1])\n"
  ],
  [
    "a = int(input())\nif a == 1:\n\tprint(\"Yes\")\n\tprint(2)\n\tprint(1, 1)\n\tprint(1,1)\nelif a == 3:\n\tprint(\"Yes\")\n\tprint(3)\n\tprint(2,1,2)\n\tprint(2,3,1)\n\tprint(2,2,3)\nelif a % 2 == 0:\n  print(\"Yes\")\n  print(a)\n  for i in range(1, a + 1, 2):\n    print(2, i, i + 1)\n  for i in range(2, a + 1, 2):\n    print(2, i, i - 1)\nelse:\n\tprint(\"No\")"
  ],
  [
    "n = int(input())\nprint(0)\ntarget = input()\ns_from = 0\ns_to = n - 1\nwhile True:\n    print(target)\n    print(s_from + (s_to - s_from) // 2)\n    ans = input()\n    if target != ans:\n        if (s_from-s_to)//2<=1:\n            print(s_to)\n        s_to = s_from + (s_to - s_from) // 2\n    else:\n        if (s_from-s_to)//2<=1:\n            print(s_from)\n        s_from = s_from + (s_to - s_from) // 2\n        target = ans"
  ],
  [
    "L, N = list(map(int, input().split()))\nS = [input() for i in range(N)]\nS.sort()\nans = \"\"\nfor j in range(N):\n    ans += S[j]\nprint(ans)"
  ],
  [
    "x, y = map(int,input().split())\nif y != 1:\n  if x*(y-1)//y != 0:\n    print(x*(y-1))\n  else:\n    print(-1)\nelse:\n  print(x)"
  ],
  [
    "def slove():\n    import sys\n    input = sys.stdin.readline\n    a, b = list(map(int, input().rstrip('\\n').split()))\n    ls = [True] * (int(max(a, b) ** 0.5) + 1)\n    ls[0] = False\n    cnt = 0\n    for i in range(len(ls)):\n        if ls[i]:\n            if a % i == 0 and b % i == 0:\n                cnt += 1\n            if i != 1:\n                for j in range(i * i, len(ls), i):\n                    if ls[j]:\n                        ls[j] = False\n    print(cnt)\nif __name__ == '__main__':\n    slove()"
  ],
  [
    " = input()\nt = input()\ncount = 0\nfor i in range(3):\n    if s[i] == t[i]:\n        count += 1\nprint(count)\ns = input()\nt = input()\ncount = 0\nfor i in range(3):\n    if s[i] == t[i]:\n        count += 1\nprint(count)"
  ],
  [
    "s = input()\nk = int(input())\nans = 0\nchg = 0\nfor i in range(1, len(s)):\n    if chg == 0 and s[i-1] == s[i]:\n        ans += 1\n        chg = 1\n    else:\n        chg = 0\nans2 = 0\nchg2 = 1\nfor i in range(1, len(s)):\n    if chg2 == 0 and s[i-1] == s[i]:\n        ans2 += 1\n        chg2 = 1\n    else:\n        chg2 = 0\nif k % 2 == 0:\n    print(k * min(ans, ans2))\nelse:\n    print(k * ans)"
  ],
  [
    "import sys\nsys.setrecursionlimit(10**7)\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI(): return map(int,sys.stdin.readline().rstrip().split())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))  \ndef LI2(): return list(map(int,sys.stdin.readline().rstrip()))  \ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())  \ndef LS2(): return list(sys.stdin.readline().rstrip())  \nN = I()\nA = LI()\nfor i in range(N):\n    A[i] -= i+1\nA.sort()\nz = A[N//2]\nprint(sum(abs(A[i]-z) for i in range(N)))"
  ],
  [
    "def inputIntList():\n    return [int(s) - 1 for s in input().split()]\ndef inputInt():\n    return int(input())\ndef main():\n    N = inputInt()\n    a = inputIntList()\n    ans = 0\n    look = 0\n    current = 0\n    while current < len(a) - 1:\n        for i, j in enumerate(a[current:]):\n            if j == look:\n                current += i\n                ans += current - i\n                break\n        look += 1\n    return N - look if look == len(a) else ans\nif __name__ == \"__main__\":\n    print(main())"
  ],
  [
    "a, b, m = map(int, input().split())\na_price = list(map(int, input().split()))\nb_price = list(map(int, input().split()))\ncoupon = []\nfor _ in range(m):\n  coupon.append(list(map(int, input().split())))\na_min = a_price.sort()[0]\nb_min = b_price.sort()[0]\nmin = a_min + b_min\ntotals = [min]\nfor list in coupon:\n  tmp = a_list[list[0]-1] + b_list[list[1]-1] - list[2]\n  totals.append(tmp)\ntotals.sort()\nans = totals[0]\nprint(ans)"
  ],
  [
    "def solve(s):\n    n = len(s)\n    ans = 0\n    for i in range(n - 1):\n        if s[i] != s[i + 1]:\n            ans += 1\n    return ans\ns = input()\nprint(solve(s))\n"
  ],
  [
    "n, m, x = map(int, input().split())\na = []\nfor i in range(n):\n    c = list(map(int, input().split()))\n    a.append(c)\nans = float('inf')\nfor i in range(2 ** n):\n    b = [0]*m\n    price = 0\n    for j in range(n):\n        if((i >> j) & 1):\n            for k in range(m):\n                b[k] += a[j][k + 1]\n            price += a[j][0]\n    if all(l >= x for l in b):\n        ans = min(ans, price)\nif  ans == float('inf'):\n    print(\"-1\")\nelse:\n    print(ans)"
  ],
  [
    "a = input().split()\nb = sorted(a)\nif int(b[2]) == int(b[0]) + int(b[1]) or int(b[0]) == int(b[1]) + int(b[2]) or int(b[0]) == int(b[1]) == int(b[2]):\n    print(\"Yes\")\nelse:\n    print(\"No\")"
  ],
  [
    "import math\nx=int(input())\nt=0\ny=100\nwhile y<x:\n  y=math.floor(y*1.01)\n  t+=1\nprint(t)"
  ],
  [
    "k,t=map(int,input().split())\nl=[0]*t\na=list(map(int,input().split()))\nfor i in range(t):\n  l[i]=a[i]\nprint(max(0,max(l)-(k+1)//2))"
  ],
  [
    "def sum_part(N, k):\n  return k*(2*N-k+1)/2-k*(k-1)/2+1\nN, K = map(int, input().split())\nans = 0\nfor k in range(K,N+2):\n  ans += sum_part(N, k)\nprint(int(ans%(10**9+7)))"
  ],
  [
    "def count_arrangements(n, k):\n    dp = [1] * (k + 1)\n    for i in range(1, n):\n        for j in range(k, 0, -1):\n            dp[j] = (dp[j] + dp[j - 1]) % 1000000007\n    return dp[k]\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    print(count_arrangements(n, k))\n"
  ],
  [
    "N = int(input())\nM = int(input())\nH = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\ndef is_good(i):\n    for j in range(M):\n        if A[j] == i or B[j] == i:\n            continue\n        if H[i] <= H[A[j]] and H[i] <= H[B[j]]:\n            return False\n    return True\ncount = 0\nfor i in range(N):\n    if is_good(i):\n        count += 1\nprint(count)\n"
  ],
  [
    "def solve(N, A):\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for i in range(1, N + 1):\n        dp[i] = (dp[i - 1] + dp[max(0, i - A[i - 1] - 1)]) % 1000000007\n    return dp[N]\nN = int(input())\nA = list(map(int, input().split()))\nprint(solve(N, A))\n"
  ],
  [
    "n = int(input())\nodd_count = (n + 1) // 2\ntotal_count = n\nprobability = odd_count / total_count\nprint(probability * 100)\n"
  ],
  [
    "S = int(input())\nT = input()\nif S < 3200:\n  print(\"Red\")\nelse:\n  print(T)"
  ],
  [
    "x, a, b = map(int, input().split())\nxa = abs(x - a)\nxb = abs(x - b)\nif xa < xb:\n    print(\"A\")\nelse:\n    print(\"B\")"
  ],
  [
    "n, C = map(int, input().split())\nstc = [list(map(int, input().split())) for _ in range(n)]\ntime = [0] * (10**5 + 1)\nfor s, t, c in stc:\n    time[s] += 1\n    time[t + 1] -= 1\nans = time[0]\nfor i in range(10**5):\n    time[i + 1] += time[i]\n    if time[i + 1] > ans:\n        ans = time[i + 1]\nprint(ans)"
  ],
  [
    "t = input()\no = \"\"\nfor i in range(len(t)):\n    if t[i] == \"?\":\n        if i != len(t) - 1:\n            if t[i + 1] == \"D\":\n                o += \"P\"\n            else:\n                o += \"D\"\n        else:\n            o += \"D\"\n    else:\n        o += t[i]\nprint(o)"
  ],
  [
    "n = int(input())\na = []\nb = []\nfor i in range(n):\n    ai, bi = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\na.sort(reverse=True)\nb.sort(reverse=True)\ntakahashi_score = 0\naoki_score = 0\nfor i in range(n):\n    if i % 2 == 0:\n        takahashi_score += a[i]\n    else:\n        aoki_score += b[i]\nprint(takahashi_score - aoki_score)\n"
  ],
  [
    "n = int(input())\nnumbers = list(map(int, input().split()))\nfor num in numbers:\n    if num % 2 == 0 and num % 3!= 0 and num % 5!= 0:\n        print(\"DENIED\")\n        break\nelse:\n    print(\"APPROVED\")\n"
  ],
  [
    "x, y = map(int, input().split())\nlarge = x * 4\nsmall = x * 2\nflag = False\nfor i in range(small, large, 2):\n    if i == y:\n        flag = True\n        break\nif flag:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
  ],
  [
    "n, m = map(int, input().split())\nx = (m * 1900) + ((n - m) * 100)\nfor i in range(1, m + 1):\n    x += (i * 1900 * (1 / 2 ** i))\nprint(int(x))\n"
  ],
  [
    "N = int(input())\nN = 100\ndef to_bit(num,digit = 3,N = 2):\n    bit = [0] * digit\n    for i in range(digit):\n        bit[i] = num % N\n        num = int((num - (num % N)) / N)\n    bit[0],bit[2] = bit[2],bit[0] \n    return bit\nDP_map = [[0] * 64 for _ in range(100)]\nDP_map[0] = [1] * 64\nDP_map[0][6] = 0\nDP_map[0][9] = 0\nDP_map[0][33] = 0\nC_NG = [9,33]\nfor i in range(N - 2):\n    for j in range(64):\n        bit = to_bit(j)\n        now = DP_map[i][j]\n        added_A = bit[1] * 16 + bit[2] * 4 + 0\n        added_C = bit[1] * 16 + bit[2] * 4 + 1\n        added_G = bit[1] * 16 + bit[2] * 4 + 2\n        added_T = bit[1] * 16 + bit[2] * 4 + 3\n        DP_map[i + 1][added_A] = (DP_map[i + 1][added_A] + now) % (int(1e9 + 7))\n        DP_map[i + 1][added_T] = (DP_map[i + 1][added_T] + now) % (int(1e9 + 7))\n        if added_G != 6:\n            DP_map[i + 1][added_G] = (DP_map[i + 1][added_G] + now) % (int(1e9 + 7))\n        if not(added_C in C_NG) and (bit[0] != 0 or bit[2] != 2) and (bit[0] != 0 or bit[1] != 2):\n            DP_map[i + 1][added_C] = (DP_map[i + 1][added_C] + now) % (int(1e9 + 7))\nprint(sum(DP_map[N-3]) % (int(1e9 + 7)))"
  ],
  [
    "  def get_choices(n):\n    choices = []\n    for k in range(2, n+1):\n        while n > 1:\n            if n % k == 0:\n                n //= k\n            else:\n                n -= k\n        choices.append(k)\n    return choices\ndef main():\n    n = int(input())\n    choices = get_choices(n)\n    print(len(choices))\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "def main():\n\tn = int(input())\n\tnums_raw = list(map(int, input().split()))\n\tnums = [nums_raw[i] - i for i in range(n)]\n\tans = search(nums)\n\tprint(sum([abs(nums_raw[i] - (ans + i)) for i in range(n)]))\ndef search(nums):\n\tleft = min(nums)\n\tright = max(nums)\n\ttmp = 10 ** 10\n\twhile True:\n\t\tif calc(nums, left) >= calc(nums, right):\n\t\t\tnew = int((left + right)/2)\n\t\t\tleft = new\n\t\telse:\n\t\t\tnew = int((left + right)/2)\n\t\t\tright = new\n\t\tif new == tmp:\n\t\t\tif min(calc(nums, new), calc(nums, new + 1), calc(nums, new - 1)) == calc(nums, new):\n\t\t\t\treturn new\n\t\t\telif min(calc(nums, new), calc(nums, new + 1), calc(nums, new - 1)) == calc(nums, new + 1):\n\t\t\t\treturn new + 1\n\t\t\telse:\n\t\t\t\treturn new - 1\n\t\telse:\n\t\t\ttmp = new\ndef calc(nums, i):\n\treturn sum([abs(x - i) for x in nums])\nif __name__ == '__main__':\n\tmain()"
  ],
  [
    "n = input().split()\na = int(n[0])\nb = int(n[1])\ncnt = 0\nfor i in range(a, b + 1):\n    nm = str(i)\n    if nm[0] == nm[-1]:\n        if nm[1] == nm[-2]:\n            cnt += 1\nprint(cnt)"
  ],
  [
    "from collections import deque\ndef solve():\n    n = int(input())\n    graph = [list(map(int, input().split())) for _ in range(n)]\n    degree = [0] * n\n    for i in range(n):\n        for j in range(n - 1):\n            degree[graph[i][j] - 1] += 1\n    queue = deque([i for i in range(n) if degree[i] == 1])\n    result = [0] * n\n    day = 0\n    while queue:\n        day += 1\n        for _ in range(len(queue)):\n            u = queue.popleft()\n            result[u] = day\n            for v in graph[u]:\n                v -= 1\n                degree[v] -= 1\n                if degree[v] == 1:\n                    queue.append(v)\n    if any(degree):\n        return -1\n    return max(result)\nprint(solve())\n"
  ],
  [
    "  def vanish_monsters(N, A, B, h):\n    count = 0\n    while any(h):\n        i = h.index(max(h))\n        h[i] -= A\n        for j in range(N):\n            if j != i and h[j] > 0:\n                h[j] -= B\n        count += 1\n    return count\ndef main():\n    N, A, B = map(int, input().split())\n    h = list(map(int, input().split()))\n    print(vanish_monsters(N, A, B, h))\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "n, k = map(int,input().split())\nfor i in range(0,n):\n    if k**i > n:\n        print(i-1)\n        break"
  ],
  [
    "n = int(input())\nprint(\"ACL\" * n)"
  ],
  [
    "N, M = map(int, input().split())\nif N >= 2 and M >= 2:\n    print(N * M - (N - 2) * (M - 2))\nelse:\n    print(0)"
  ],
  [
    "n=int(input())\na=sorted([int(i) for i in input().split()])[::-1]\nb=[a[0],a[1]]\nans=a[0]\nfor i in range(n-2):\n    if b[0]<=b[1]:\n        ans+=b[0]\n        b=b[1:]\n        b+=[a[i+2]]\n    else:\n        ans+=b[1]\n        b=b[:1]\n        b+=[a[i+2]]\nprint(ans)"
  ],
  [
    "a, b = map(int, input().split())\nx = int(str(a) * b)\ny = int(str(b) * a)\nif x <= y:\n  print(y)\nelse:\n  print(x)"
  ],
  [
    "x1, x2, x3, x4, x5 = map(int, input().split())\nif x1 == 0:\n  print(1)\nelif x2 == 0:\n  print(2)\nelif x3 == 0:\n  print(3)\nelif x4 == 0:\n  print(4)\nelif x5 == 0:\n  print(5)"
  ],
  [
    "n, c = map(int, input().split())\nsushi = []\nfor _ in range(n):\n    x, v = map(int, input().split())\n    sushi.append((x, v))\nsushi.sort(key=lambda x: x[0])\ndp = [0] * (n + 1)\nfor i in range(n):\n    for j in range(i + 1, n + 1):\n        distance = sushi[j - 1][0] - sushi[i][0]\n        if distance > c:\n            break\n        dp[j] = max(dp[j], dp[i] + sushi[j - 1][1] - distance)\nprint(dp[n])\n"
  ],
  [
    "n = int(input())\nli = [int(x) for x in input().split()]\ndef func(li):\n  for x in li:\n    if x % 2!= 0:\n      return False\n  return True\ncount = 0\nwhile func(li):\n  for i in range(len(li)):\n    li[i] = li[i] // 2\n  count += 1\nprint(count)"
  ],
  [
    "from queue import Queue\ns = input().split(' ')\nN = int(s[0])\nM = int(s[1])\nroom_from = []\nroom_to = []\nfor i in range(M):\n  s = input().split(' ')\n  room_from.append(int(s[0]))\n  room_to.append(int(s[1]))\n  room_from.append(int(s[1]))\n  room_to.append(int(s[0]))\nanswer = {}\ntodo = {}\ntemp = {}\ntodoq = Queue(N)\nfor (i, room) in enumerate(room_to):\n  if room_to[i] == 1:\n    todo[room_from[i]] = 1\nanswer.update(todo)\nwhile True:\n  for a in todo:\n    for (i, room) in enumerate(room_to):\n      if room == a and room_from[i] not in temp and room_from[i] not in answer and room_from[i] != 1:\n        temp[room_from[i]] = a\n  if len(temp) == 0:\n    break\n  else:\n    todo.clear()\n    todo.update(temp)\n    answer.update(temp)\n    temp.clear()\nprint(answer)\nif len(answer) == N - 1:\n  print(\"Yes\")\n  for n in answer:\n    print(answer[n])\nelse:\n  print(\"No\")"
  ],
  [
    "from collections import Counter\nN = int(input())\nA = [int(i) for i in input().split()]\nC = Counter(A)\nret = len(C)\ncnt = []\nfor v in C.values():\n    if v >= 2:\n        cnt.append(v)\ns = sum(cnt)\nfor c in cnt:\n    if c > s // 2:\n        ret -= c - (s + 1) // 2\nprint(ret)"
  ],
  [
    "a, b, c = map(int, input().split())\nif b - a == c - b:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
  ],
  [
    "a, b = map(int, input().split())\nprint((a + b) % 24)\n"
  ],
  [
    "import numpy as np\nx,y = [int(i) for i in input().split()]\nans_array = np.array([],dtype = np.int64)\nif y - x >= 0:\n    ans_array = np.append(ans_array,y-x)\nif y + x >= 0:\n    ans_array = np.append(ans_array,y+x+1)\nif -y - x >= 0:\n    ans_array = np.append(ans_array,-y-x+1)\nif -y + x >= 0:\n    ans_array = np.append(ans_array,-y+x+2)\nprint(ans_array.min())"
  ],
  [
    "  def get_kyu(rating):\n    if rating >= 400 and rating <= 1999:\n        if rating >= 400 and rating <= 599:\n            return 8\n        elif rating >= 600 and rating <= 799:\n            return 7\n        elif rating >= 800 and rating <= 999:\n            return 6\n        elif rating >= 1000 and rating <= 1199:\n            return 5\n        elif rating >= 1200 and rating <= 1399:\n            return 4\n        elif rating >= 1400 and rating <= 1599:\n            return 3\n        elif rating >= 1600 and rating <= 1799:\n            return 2\n        else:\n            return 1\n    else:\n        return \"Invalid rating\"\nrating = int(input())\nprint(get_kyu(rating))"
  ],
  [
    "N = int(input())\ncnt = 0\nfor K in range(2, N + 1):\n    n = N\n    while n >= K:\n        if n % K == 0:\n            n //= K\n        else:\n            n -= K\n    if n == 1:\n        cnt += 1\nprint(cnt)"
  ],
  [
    "def main(sample_file = ''):\n    import sys\n    sys.setrecursionlimit(10**7)\n    from itertools import accumulate, combinations, permutations, product \n    from math import factorial, ceil, floor, sqrt\n    def factorize(n):\n        fct = []  \n        b, e = 2, 0  \n        while b * b <= n:\n            while n % b == 0:\n                n = n // b\n                e = e + 1\n            if e > 0:\n                fct.append((b, e))\n            b, e = b + 1, 0\n        if n > 1:\n            fct.append((n, 1))\n        return fct\n    def combinations_count(n, r):   \n        if n < 0 or r < 0:\n            raise Exception('combinations_count(n, r) not defined when n or r is negative')\n        if n - r < r: r = n - r\n        if r < 0: return 0\n        if r == 0: return 1\n        if r == 1: return n\n        numerator = [n - r + k + 1 for k in range(r)]\n        denominator = [k + 1 for k in range(r)]\n        for p in range(2,r+1):\n            pivot = denominator[p - 1]\n            if pivot > 1:\n                offset = (n - r) % p\n                for k in range(p-1,r,p):\n                    numerator[k - offset] /= pivot\n                    denominator[k] /= pivot\n        result = 1\n        for k in range(r):\n            if numerator[k] > 1:\n                result *= int(numerator[k])\n        return result\n    def combinations_with_replacement_count(n, r):\n        if n < 0 or r < 0:\n            raise Exception('combinations_with_replacement_count(n, r) not defined when n or r is negative')\n        elif n == 0:\n            return 1\n        else:\n            return combinations_count(n + r - 1, r)\n    from bisect import bisect_left, bisect_right\n    from collections import deque, Counter, defaultdict \n    from heapq import heapify, heappop, heappush, heappushpop, heapreplace,nlargest,nsmallest \n    from copy import deepcopy, copy \n    import operator\n    from operator import itemgetter \n    from functools import reduce, lru_cache\n    def chmin(x, y):\n        if x > y:\n            x = y\n            return (x, True)\n        else:\n            return (x, False)\n    def chmax(x, y):\n        if x < y:\n            x = y\n            return (x, True)\n        else:\n            return (x, False)\n    from fractions import gcd \n    def gcds(numbers):\n        return reduce(gcd, numbers)\n    def lcm(x, y):\n        return (x * y) // gcd(x, y)\n    def lcms(numbers):\n        return reduce(lcm, numbers, 1)\n    def make_divisors(n, reversed=False):\n        divisors = set()\n        for i in range(1, int(n**0.5)+1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n//i)\n        return sorted(list(divisors),reverse=reversed)\n    INF = 10 ** 18\n    MOD = 10 ** 9 + 7\n    AtoZ = list('abcdefghijklmnopqrsruvwxyz') \n    modpow = lambda a, n, p = MOD: pow(a, n, p) \n    def modinv(a, p = MOD):\n        return modpow(a, p-2, p)\n    def modinv_list(n, p = MOD):\n        if n <= 1:\n            return [0,1][:n+1]\n        else:\n            inv_t = [0,1]\n            for i in range(2, n+1):\n                inv_t += [inv_t[p % i] * (p - int(p / i)) % p]\n            return inv_t\n    def modfactorial_list(n, p = MOD):\n        if n == 0:\n            return [1]\n        else:\n            l = [0] * (n+1)\n            tmp = 1\n            for i in range(1, n+1):\n                tmp = tmp * i % p\n                l[i] = tmp\n            return l\n    def modcomb(n, k, fac_list = [], p = MOD):\n        from math import factorial\n        if n < 0 or k < 0 or n < k: return 0\n        if n == 0 or k == 0: return 1\n        if len(fac_list) <= n:\n            a = factorial(n) % p\n            b = factorial(k) % p\n            c = factorial(n-k) % p\n        else:\n            a = fac_list[n]\n            b = fac_list[k]\n            c = fac_list[n-k]\n        return (a * modpow(b, p-2, p) * modpow(c, p-2, p)) % p\n    def modadd(a, b, p = MOD):\n        return (a + b) % MOD\n    def modsub(a, b, p = MOD):\n        return (a - b) % p\n    def modmul(a, b, p = MOD):\n        return ((a % p) * (b % p)) % p\n    def moddiv(a, b, p = MOD):\n        return modmul(a, modpow(b, p-2, p))\n    class UnionFindTree:\n        def __init__(self, N):\n            self.root = [-1] * (N+1)\n            self.rank   = [0]  * (N+1)\n            self.connected_num = [1] * (N+1)\n        def find_root(self,x):\n            root = self.root\n            while root[x] != -1:\n                x = root[x]\n            return x\n        def unite(self,x,y):\n            root = self.root\n            rank = self.rank\n            connected_num = self.connected_num\n            find_root = self.find_root\n            rx = find_root(x)\n            ry = find_root(y)\n            if rx != ry:\n                if rank[rx] < rank[ry]:\n                    root[rx] = ry\n                    rx,ry = ry,rx\n                else:\n                    if rank[rx] == rank[ry]:\n                        rank[rx] += 1\n                    root[ry] = rx       \n                connected_num[rx] += connected_num[ry]\n    class SegTree:\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    def BellmanFord(N, M, ABC, vertex_start, vertex_end, value_if_inf = -1, find_shortest = False):\n        def make_reachable_list(N, M, ABC, vertex_start, vertex_end):\n            reachable_to_direct = defaultdict(list)\n            reachable_from_direct = defaultdict(list)\n            reachable_from_start = [False] * N\n            reachable_to_end = [False] * N\n            reachable_from_start[vertex_start] = True\n            reachable_to_end[vertex_end] = True\n            reachable_from_both_sides = [False] * N\n            dfs_from_start = []\n            dfs_to_end = []\n            for a, b, c in ABC:\n                reachable_to_direct[a].append(b)\n                reachable_from_direct[b].append(a)\n                if a == vertex_start:\n                    dfs_from_start.append(b)\n                    reachable_from_start[b] = True\n                if b == vertex_end:\n                    dfs_to_end.append(a)\n                    reachable_to_end[a] = True\n            while dfs_from_start:\n                v = dfs_from_start.pop()\n                for i in reachable_to_direct[v]:\n                    if not reachable_from_start[i]:\n                        reachable_from_start[i] = True\n                        dfs_from_start.append(i)\n            while dfs_to_end:\n                v = dfs_to_end.pop()\n                for i in reachable_from_direct[v]:\n                    if not reachable_to_end[i]:\n                        reachable_to_end[i] = True\n                        dfs_to_end.append(i)\n            for i in range(N):\n                reachable_from_both_sides[i] = reachable_from_start[i] and reachable_to_end[i]\n            return reachable_from_both_sides\n        reachable_from_both_sides = make_reachable_list(N, M, ABC, vertex_start, vertex_end)\n        if find_shortest:\n            dist = [INF for i in range(N)]\n        else:\n            dist = [-INF for i in range(N)]\n        dist[vertex_start] = 0\n        for i in range(N):\n            updated = False\n            for a, b, c in ABC:\n                if not reachable_from_both_sides[a]:\n                    continue\n                elif find_shortest:\n                    update_condition = dist[a] + c < dist[b]\n                else:\n                    update_condition = dist[a] + c > dist[b]\n                if dist[a] != INF and update_condition:\n                    dist[b] = dist[a] + c\n                    updated = True\n                    if i == N-1:\n                        return value_if_inf\n            if not updated:\n                break\n        return dist[vertex_end]\n    def warshall_floyd(number_vertex, XYD, shift_one_for_vertex=False):\n        d = [[float(\"inf\")]*number_vertex for i in range(number_vertex)]\n        for x, y, dist in XYD:\n            if shift_one_for_vertex:\n                x = x - 1\n                y = y - 1\n            d[x][y] = dist\n            d[y][x] = dist\n        for i in range(number_vertex):\n            d[i][i] = 0 \n        for k in range(number_vertex):\n            for i in range(number_vertex):\n                for j in range(number_vertex):\n                    d[i][j] = min(d[i][j],d[i][k] + d[k][j])\n        return d\n    r = lambda: sys.stdin.readline().strip()\n    r_int = lambda: int(r())\n    r_float = lambda: float(r())\n    R = lambda: list(map(int, r().split()))\n    R_str = lambda: r().split()\n    R_map = lambda: map(int, r().split())\n    R_float = lambda: list(map(float, r().split()))\n    R_tuple = lambda: tuple(map(int, r().split()))\n    if sample_file:\n        sys.stdin = open(sample_file)\n    N = r_int()\n    AB = [R() for _ in range(N-1)]\n    tree = [[] for _ in range(N)]\n    for a, b in AB:\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    task = [(i, [0]) for i in tree[0]]\n    arrived = [0] * N\n    arrived[0] = 1\n    while task:\n        node, parent = task.pop()\n        for child in tree[node]:\n            if child == N-1:\n                way = parent + [node, N-1]\n                break\n            if arrived[child] == 0:\n                arrived[child] = 1\n                task.append((child, parent+[node]))\n    kireme = way[(len(way)-1)//2]\n    kireme_ikenai = way[(len(way)-1)//2+1]\n    cnt = 0\n    task = [0]\n    arrived = [0] * N\n    while task:\n        node = task.pop()\n        cnt += 1\n        arrived[node] = 1\n        for child in tree[node]:\n            if child == kireme_ikenai:\n                continue\n            else:\n                if not arrived[child]:\n                    task.append(child)\n    if cnt > N - cnt:\n        print('Fennec')\n    else:\n        print('Snuke')\nif __name__ == '__main__':\n    main()"
  ],
  [
    "count = 0\nend = False\nnum = list(map(int, input().split()))\nwhile True:\n    div = []\n    for i in num:\n        if i % 2 == 0:\n            div.append(i // 2)\n        else:\n            print(count)\n            end = True\n            break\n    if end:\n        break\n    num = div\n    count += 1"
  ],
  [
    "import sys\ninput = sys.stdin.readline\nimport numpy as np\nfrom collections import defaultdict\nN,K = map(int,input().split())\nA = [0] + [int(i) for i in input().split()]\nAcum = np.cumsum(A)\nAcum = [i%K for i in Acum]\nanswer = 0\ncounter = defaultdict(int)\nfor j,x in enumerate(Acum):\n    if j == 0:\n        continue\n    answer += counter[x]\n    counter[x] += 1\n    if j-K >= 0:\n        counter[Acum[j-K]] -= 1\nprint(answer)"
  ],
  [
    "n = 2\na, b = map(int, input().split())\nif (a + b) % 2 == 0:\n    print((a + b) // 2)\nelse:\n    print(\"IMPOSSIBLE\")"
  ],
  [
    "N = int(input())\nV = list(map(int, input().split()))\nC = list(map(int, input().split()))\nans_max = 0\nfor j in range(N):\n    for i in range(j, N):\n        X = sum(V[j:i+1])\n        Y = sum(C[j:i+1])\n        ans = X - Y\n        if ans_max < ans:\n            ans_max = ans\nprint(ans_max)"
  ],
  [
    "from math import ceil, floor\ndef p_d():\n    S = input()\n    st = 0\n    ans = []\n    while st < len(S):\n        rc = 0\n        while st < len(S) and S[st] == \"R\":\n            rc += 1\n            st += 1\n        lc = 0\n        while st < len(S) and S[st] == \"L\":\n            lc += 1\n            st += 1\n        l = ceil(rc / 2) + lc // 2\n        r = rc // 2 + ceil(lc / 2)\n        ans.extend([0] * (rc - 1))\n        ans.append(l)\n        ans.append(r)\n        ans.extend([0] * (lc - 1))\n    print(*ans)\nfrom heapq import heappush, heappop\ndef get_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            heappush(divisors, -i)\n            if i != n // i:\n                heappush(divisors, -(n // i))\n    return divisors\ndef p_e():\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    sum_A = sum(A)\n    divisors = get_divisors(sum_A)\n    n = len(divisors)\n    for _ in range(n):\n        h = -heappop(divisors)\n        sub_list = []\n        for a in A:\n            sub_list.append(a % h)\n        x = sum(sub_list)\n        if x <= K * 2 and x % h == 0:\n            print(h)\n            return\n    print(0)\nif __name__ == '__main__':\n    p_e()"
  ],
  [
    "def main():\n    from itertools import accumulate\n    N, K = (int(i) for i in input().split())\n    A = [int(i) for i in input().split()]\n    sumA = sum(A)\n    def enum_divisors(n):\n        divs = []\n        for i in range(1, n+1):\n            if i*i > n:\n                break\n            if n % i == 0:\n                divs.append(i)\n                if n//i != i:\n                    divs.append(n//i)\n        return divs\n    divs = enum_divisors(sumA)\n    divs.sort(reverse=True)\n    for d in divs:\n        diff = []\n        for a in A:\n            diff.append(a % d)\n        diff.sort()\n        S = list(accumulate([0] + diff))\n        if min(S[i] for i in range(1, N)\n               if S[i] == (d * (N-i) - (S[N] - S[i]))) <= K:\n            print(d)\n            return\nif __name__ == '__main__':\n    main()"
  ],
  [
    "n, k = map(int, input().split())\nr, s, p = map(int, input().split())\nt = list(input())\nwin = []\nans = 0\nfor i in range(n):\n    if t[i] == \"r\":\n        win.append(\"p\")\n    elif t[i] == \"s\":\n        win.append(\"r\")\n    else:\n        win.append(\"s\")\nfor i in range(n):\n    if i >= k:\n        if win[i] == win[i - k]:\n            if i + k < n:\n                if win[i + k] != t[i]:\n                    win[i] = t[i]\n                else:\n                    if win[i] != \"r\" and win[i + k] != \"r\":\n                        win[i] = \"r\"\n                    elif win[i] != \"s\" and win[i + k] != \"s\":\n                        win[i] = \"s\"\n                    elif win[i] != \"p\" and win[i + k] != \"p\":\n                        win[i] = \"p\"\n        else:\n            if win[i] == \"r\":\n                ans += r\n            elif win[i] == \"s\":\n                ans += s\n            else:\n                ans += p\n    else:\n        if win[i] == \"r\":\n            ans += r\n        elif win[i] == \"s\":\n            ans += s\n        else:\n            ans += p\nprint(ans)"
  ],
  [
    "N = int(input())\nlist = list(map(str, input().split()))\nanswer = []\nfor i in range(1, N-2):\n    answer.append(list.count(str(i)))\na_s = '\\n'.join(answer)\nprint(a_s)"
  ],
  [
    "(n,m),*ab = [list(map(int, s.split())) for s in open(0)]\nab = [(a-1,b-1) for a,b in ab]\naa = [0]*n\nbb = [0]*n\nfor a,b in ab:\n    aa[a] = 1\n    bb[b] = 1\nended = False\nans = 0\nfor i,j in zip(aa,bb):\n    if j:\n        ended = True\n    if i and not ended:\n        ans += 1\n    if i and ended:\n        ended = False\nprint(ans)"
  ],
  [
    "a, b = map(int, input().split())\nif a*b % 2 == 0:\n    print('Even')\nelse:\n    print('Odd')"
  ],
  [
    "n, a, b = map(int, input().split())\nmod = 10**9 + 7\nJ = pow(2, n) % mod\ndef find_power(n, mod):\n    powlist = [0] * (n + 1)\n    powlist[0] = 1\n    powlist[1] = 1\n    for i in range(2, n + 1):\n        powlist[i] = powlist[i - 1] * i % (mod)\n    return powlist\ndef find_inv_power(n):\n    powlist = find_power(n, 10**9 + 7)\n    check = powlist[-1]\n    first = 1\n    uselist = [0] * (n + 1)\n    secondlist = [0] * 30\n    secondlist[0] = check\n    secondlist[1] = check**2\n    for i in range(28):\n        secondlist[i + 2] = (secondlist[i + 1]**2) % (10**9 + 7)\n    a = format(10**9 + 5, \"b\")\n    for j in range(30):\n        if a[29 - j] == \"1\":\n            first = (first * secondlist[j]) % (10**9 + 7)\n    uselist[n] = first\n    for i in range(n, 0, -1):\n        uselist[i - 1] = (uselist[i] * i) % (10**9 + 7)\n    return uselist\nC = find_inv_power(2 * 10**5 + 100)\nif True:\n    c = 1\n    for i in range(a):\n        c *= (n - i)\n        c = c % mod\n    c = c * C[a]\n    c = c % mod\n    d = 1\n    for i in range(b):\n        d *= (n - i)\n        d = d % mod\n    d = d % mod\n    d = d * C[b]\n    print((J - c - d) % mod)"
  ],
  [
    "N=int(input())\nb = list(map(int, input().split()))\nans=[]\nfor i in range(N):\n    j = 1\n    if j < len(b):\n        while b[j] == j + 1:\n            j += 1\n            if j == len(b):break\n    if b[j - 1] == j:\n        del b[j-1]\n        ans.append(j)\n    else:\n        print(-1)\n        import sys\n        sys.exit()\nfor i in range(len(ans)-1,-1,-1):\n    print(ans[i])"
  ],
  [
    "T1, T2 = map(int, input().split())\nA1, A2 = map(int, input().split())\nB1, B2 = map(int, input().split())\na, b, c, d = T1 * A1, T1 * B1, T2 * A2, T2 * B2\nif a + c == b + d:\n    print('infinity')\nelse:\n    if (a - b) * (c - d) > 0:\n        print(0)\n    else:\n        x, y = abs(a - b), abs(c - d)\n        if (x + y) % (x - y) == 0:\n            print((x + y) // (x - y))\n        else:\n            print((x + y) // (x - y) + 1)"
  ],
  [
    "  def get_satisfaction_points(dishes, satisfaction, bonuses):\n    points = 0\n    for i in range(len(dishes)):\n        points += satisfaction[dishes[i] - 1]\n        if i < len(dishes) - 1:\n            points += bonuses[dishes[i] - 1]\n    return points\ndef main():\n    n = int(input())\n    dishes = list(map(int, input().split()))\n    satisfaction = list(map(int, input().split()))\n    bonuses = list(map(int, input().split()))\n    points = get_satisfaction_points(dishes, satisfaction, bonuses)\n    print(points)\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "def main():\n  n, r = map(int,input().split())\n  if n < 10:\n    return r + 100 * (10 - n)\n  else:\n    return r"
  ],
  [
    "import math\nN = int(input())\nA = math.floor(N / 1.08)\nif N == math.floor(A * 1.08):\n    print(A)\nelse:\n    print(\":(\")"
  ],
  [
    "X = int(input())\nfor a in range(-100, 100, 1):\n    for b in range(-100, 100, 1):\n        if a**5 - b**5 == X:\n            print(a, b)\n            break"
  ],
  [
    "S = input()\nw = int(input())\ns = ''\nif w == 1:\n  print(S)\nelse:\n  for i in range(len(S) // w):\n    s += S[i * w]\n  if len(S) % w!= 0:\n    s += S[-1]\nprint(s)"
  ],
  [
    "n = int(input())\ns = input()\npin_codes = set()\nfor i in range(n - 2):\n    pin = s[:i] + s[i+3:]\n    pin_codes.add(pin)\nprint(len(pin_codes))\n"
  ],
  [
    "  from itertools import accumulate\ndef solve(N, A, B):\n    A = list(accumulate(A))\n    B = list(accumulate(B))\n    return max(A[-1] - B[-1], B[-1] - A[-1])\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    result = solve(N, A, B)\n    print(result)\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "D, T, S = map(int, input().split())\nif D / S <= T:\n  print(\"Yes\")\nelse:\n  print(\"No\")\n"
  ],
  [
    "n = int(input())\ncount = 0\nfor i in range(n):\n    if i**2 <= n:\n        count = i**2\n    else:\n        break\nprint(count)"
  ],
  [
    "N = int(input())\nA = [int(input()) for i in range(N)]\nfrom collections import deque\nsq = deque(sorted(A))\nq = deque([sq.popleft()])\nwhile sq:\n    q.appendleft(sq.pop())\n    if len(sq)==0: break\n    q.append(sq.pop())\n    if len(sq)==0: break\n    q.appendleft(sq.popleft())\n    if len(sq)==0: break\n    q.append(sq.popleft())\n    if len(sq)==0: break\na = q.pop()\nans = 0\nwhile q:\n    ans += abs(a - q[-1])\n    a = q.pop()\nprint(ans)"
  ],
  [
    "N,T = map(int,input().split(' '))\nList = []\nfor _ in range(N):\n  c, t = map(int,input().split(' '))\n  List.append([c, t])\ncosts = [c for c, t in List if t <= T]\nif costs:\n  print(min(costs))\nelse:\n  print(\"TLE\")"
  ],
  [
    "import sys\nfrom collections import deque\nn, m = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nin_degree = [0] * n\nfor _ in range(m):\n    u, v = map(int, sys.stdin.readline().split())\n    graph[u - 1].append(v - 1)\n    in_degree[v - 1] += 1\nqueue = deque([i for i in range(n) if in_degree[i] == 0])\ndist = [0] * n\nwhile queue:\n    u = queue.popleft()\n    for v in graph[u]:\n        in_degree[v] -= 1\n        dist[v] = max(dist[v], dist[u] + 1)\n        if in_degree[v] == 0:\n            queue.append(v)\nprint(max(dist))\n"
  ],
  [
    "a, b, c = map(int, input().split())\nif (a == 5 and b == 7 and c == 5) or (a == 5 and b == 5 and c == 7) or (a == 7 and b == 5 and c == 5):\n  print(\"YES\")\nelse:\n  print(\"NO\")\n"
  ],
  [
    "import copy\ndef gcd(a,b):\n    if b == 0:\n        return a\n    return gcd(b, a%b)\ndef gcd_lis(l):\n    res = 0\n    for i in range(len(l)-1):\n        if i == 0:\n            res = gcd(l[i],l[i+1])\n        else:\n            res = gcd(res,l[i+1])\n    return res\ndef gcd_lis2(l):\n    tmpd = copy.deepcopy(l)\n    if len(l) == 1:\n        return l[0]\n    else:\n        tmpd.append(gcd(tmpd.pop(),tmpd.pop()))\n        return gcd_lis2(tmpd)\nn = int(input())\nlis = list(map(int,input().split()))\nlis = list(set(lis))\nreslis = []\nreslis.append(gcd_lis2(lis))\nif len(lis) != 2:\n    for i in range(len(lis)):\n        tmp = copy.deepcopy(lis)\n        del tmp[i]\n        reslis.append(gcd_lis2(tmp))\n    print(max(reslis))\nelif len(lis) == 1:\n    print(lis[0])\nelse:\n    print(max(reslis))"
  ],
  [
    "import math\ndef solve(N, A, B, values):\n    max_mean = 0\n    num_ways = 0\n    total_sum = sum(values)\n    values.sort(reverse=True)\n    for i in range(A, B+1):\n        current_sum = sum(values[:i])\n        current_mean = current_sum / i\n        if current_mean > max_mean:\n            max_mean = current_mean\n            num_ways = 1\n        elif current_mean == max_mean:\n            num_ways += 1\n    return max_mean, num_ways\nprint(solve(15, 2, 2, [1, 2, 3, 4, 5]))  \nprint(solve(24, 2, 3, [10, 20, 10, 10]))  \nprint(solve(35, 1, 5, [1000000000000000, 999999999999999, 999999999999998, 999999999999997, 999999999999996]))  \n"
  ],
  [
    "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nn = int(input())\na = list( map(int, input().split()))\nans=[0]*(n+1)\nans[0]=1\nif a[0] != 0:\n    if n != 0:\n        print(-1)\n        exit()\n    else:\n        print(1)\n        exit()\nif a[n] == 0:\n    print(-1)\n    exit()\nans[n]=a[n]\nfrom functools import lru_cache\n@lru_cache(None)\ndef dfs(fukasa,ansuka1):\n    if fukasa == 0:\n        if ans[0] == 1:\n            return True\n        else:\n            return False\n    mi = a[fukasa] -(-ansuka1//2)\n    ans[fukasa] = mi\n    if not dfs(fukasa-1,ansuka1):\n        return False\n    tmp = a[fukasa]+ansuka1\n    tmp = min(tmp,2**fukasa)\n    while tmp >= a[fukasa] -(-ansuka1//2):\n        if dfs(fukasa-1, ansuka1):\n            ans[fukasa]=tmp\n            break\n        tmp -= 1\n    else:\n        return False\n    return True\ntmp = dfs(n-1,ans[n])\nif tmp:\n    print(sum(ans))\nelse:\n    print(-1)"
  ],
  [
    "  def count_hat_combinations(n, a):\n    MOD = 1000000007\n    dp = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            if a[i - 1] >= j:\n                dp[i] += dp[i - j]\n                dp[i] %= MOD\n    return dp[n]\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(count_hat_combinations(n, a))\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "N=int(input())\nb=list(map(int, input().split()))\na=[]\nfor i in range(N):\n  if i+1 < b[i]:\n    print(-1)\n    break\n  a.insert(b[i]-1,i+1)\nfor j in range(N):\n  print(a[j])"
  ],
  [
    "from collections import Counter\nN = int(input())\nA = [int(i) for i in input().split()]\nC = Counter(A)\nret = len(C)\ncnt = []\nfor v in C.values():\n    if v >= 2:\n        cnt.append(v)\ns = sum(cnt)\nfor c in cnt:\n    if c > s // 2:\n        ret -= c - (s + 1) // 2\nprint(ret)"
  ],
  [
    "import collections\nn, m = map(int, input().split())\ng = collections.defaultdict(list)\nfor _ in range(m):\n  x, y = map(int, input().split())\n  g[x].append(y)\ndp = [0] * (n + 1)\nfor i in range(1, n + 1):\n  for j in g[i]:\n    dp[j] = max(dp[j], dp[i] + 1)\nprint(max(dp))\n"
  ],
  [
    "import heapq, copy\nn, k = map(int, input().split())\nv = list(map(int, input().split()))\nans = -10 ** 10\nfor a in range(min(n, k)):\n    for b in range(min(n, k) - a):\n        have = []\n        for i in range(a):\n            have.append(v[i])\n        for i in range(b):\n            have.append(v[-i-1])\n        tmp = sum(have)\n        heapq.heapify(have)\n        ans = max(ans, tmp)\n        for c in range(min(n, k) - a - b):\n            if len(have) <= 0:\n                break\n            item = heapq.heappop(have)\n            if item >= 0:\n                break\n            tmp -= item\n            ans = max(ans, tmp)\nprint(ans)"
  ],
  [
    "from collections import defaultdict\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprefix_sum = [0] * (n + 1)\ncount = defaultdict(int)\ncount[0] = 1\nresult = 0\nfor i in range(1, n + 1):\n    prefix_sum[i] = prefix_sum[i - 1] + a[i - 1]\n    remainder = prefix_sum[i] % k\n    result += count[(remainder - i) % k]\n    count[remainder] += 1\nprint(result)\n"
  ],
  [
    "n = int(input())\na = []\nfor _ in range(n):\n    a.append(int(input()))\nans = 0\nfor i in range(n - 1, 0, -1):\n    if a[i] < a[i - 1]:\n        print(-1)\n        exit()\n    ans += a[i] - a[i - 1]\nprint(ans)\n"
  ],
  [
    "def main():\n    N = int(input())\n    ls = [[int(x) for x in input().split()] for _ in range(N)]\n    ans = 0\n    for i in range(N):\n        ls[i].append(ls[i][0]+ls[i][1])\n    ls = sorted(ls,key=lambda x:-x[2])\n    if N==1:\n        print(ls[0][0]-ls[0][1])\n    for i in range(N):\n        ans -= ls[i][1]\n    for i in range(N//2):\n        ans += ls[2*i][0]\n    if N%2==1:\n        ans += ls[2*i+1][0]\n    print(ans)\nif __name__ == '__main__':\n    main()"
  ],
  [
    "import math\nstdin = [input() for i in range(2)]\nline = stdin[0].split(' ')\nN = int(line[0])\nK = int(line[1])\nline = stdin[1].split(' ')\nAi = [0]*N\nfor i in range(len(line)):\n    Ai[i] = int(line[i])\nif(Ai == [0]*N):\n    print (Ai)\n    exit()\nif(K> math.log(N)):\n    print ([N]*N)\n    exit()\nfor i in range(K):\n    Bi = [1]*N\n    for i, d in enumerate(Ai):\n        for j in range(1,d+1):\n            if i-j >=0:\n                Bi[i-j] +=1\n            if i+j <N:\n                Bi[i+j] +=1\n    Ai = Bi\n    print(Ai)\n    if Ai[0] == N & Ai[-1] == N:\n        break"
  ],
  [
    "s = input()\nans = 0\nfor i in range(4):\n  if s[i] == \"+\":\n    ans += 1\n  else:\n    ans -= 1\nprint(ans)\n"
  ],
  [
    "import sys\ninput = sys.stdin.readline\nx = int(input())\na = int(input())\nb = int(input())\nx -= a\nprint(x - (x // b) * b)"
  ],
  [
    "N = int(input())\nA = list(map(int, input().split()))\ncounts = [0] * N\nfor i in A:\n    counts[i-1] += 1\nfor count in counts:\n    print(count)"
  ],
  [
    "import sys\nn = int(input())\ntakasa = list(map(int, input().split()))\nif len(takasa) < 1:\n    print(\"Yes\")\n    sys.exit()\nis_No = False\nmax_takasa = takasa[0]\nmin_takasa = 0\nfor i in range(len(takasa)-1):\n    if takasa[i] > takasa[i+1]:\n        takasa[i] -= 1\n        if takasa[i] > max_takasa:\n            max_takasa = takasa[i]\n        if takasa[i] < max_takasa:\n            print(\"No\")\n            sys.exit()\nif takasa[-1] < takasa[-2]:\n    print(\"No\")\n    sys.exit()\nif not is_No:\n    print(\"Yes\")"
  ],
  [
    "r = int(input())\nprint(int(r**2))"
  ],
  [
    "N, A, B = map(int, input().split())\nX = list(map(int, input().split()))\ndist = [0] * (N - 1)\nfor i in range(N - 1):\n    dist[i] = X[i + 1] - X[i]\nfatigue = 0\nfor i in dist:\n    if i * A < B:\n        fatigue += i * A\n    else:\n        fatigue += B\nprint(fatigue)"
  ],
  [
    "import sys\nsys.setrecursionlimit(10**9)\nf_memo = {0:1, 1:1}\ndef f(x):\n  global f_memo\n  if x in f_memo:\n    return f_memo[x]\n  else:\n    res = x * f(x-1)\n    f_memo[x] = res\n    return res\ncomb_memo = {}\ndef comb(n, r):\n  global comb_memo\n  if (n, r) in comb_memo:\n    return comb_memo[(n, r)]\n  else:\n    a = f(n)\n    b = f(n-r)\n    c = f(r)\n    res = a // b // c\n    comb_memo[(n, r)] = res\n    return res\nN, A, B = map(int, input().split())\nv = list(map(int, input().split()))\nv.sort(reverse=True)\nmu = sum(v[:A]) / A\nR = A-1\nfor i in range(A, N):\n  if v[i] == mu:\n    R = i\n  else:\n    break\nR += 1\nans = 0\nif R > A:\n  for i in range(A, B+1):\n    ans += comb(R, i)\nelse:\n  min_v = v[A-1]\n  n = v.count(min_v)\n  need = v[:A].count(min_v)\n  ans += comb(n, need)\nprint(mu)\nprint(ans)"
  ],
  [
    "import itertools\nint_x = int(input())\nanswer = int_x\nfor i in range(1, int_x + 1):\n    for v in itertools.combinations(range(1, int_x + 1), i):\n        if sum(v) == int_x:\n            answer = min(answer, max(v))\nprint(answer)"
  ],
  [
    "n = int(input())\nls = [int(input()) for _ in range(n)]\nls = list(set(ls))\nls.sort()\nnum = ls[-1] - ls[-2]\nif num % 2 == 0:\n    print(\"second\")\nelse:\n    print(\"first\")"
  ],
  [
    "N, M = map(int, input().split())\nif N % 2 == 0:\n    for i in range(M):\n        print(i + 1, N - i)\nelse:\n    for i in range(M):\n        print(i + 1, N - i - 1)"
  ],
  [
    "def solve(S):\n  n = len(S)\n  ans = 0\n  for i in range(1 << (n - 1)):\n    num = 0\n    op = '+'\n    for j in range(n):\n      if (i >> j) & 1:\n        num += int(S[j])\n        op = '+'\n      else:\n        if op == '+':\n          num += int(S[j])\n        else:\n          num = num * 10 + int(S[j])\n        op = ''\n    ans += num\n  return ans\nS = input()\nprint(solve(S))\n"
  ],
  [
    "  from typing import List\ndef min_colors(arr: List[int]) -> int:\n    arr.sort()\n    colors = 1\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            colors += 1\n    return colors\ndef main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(min_colors(arr))\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "import sys\ninput=sys.stdin.readline\nimport string\ndef main():\n    s = input().strip()\n    t = input().strip()\n    if not all(s.find(c) >= 0 for c in t):\n        print(-1)\n        exit()\n    sa = [[] for _ in string.ascii_lowercase]\n    for i,c in enumerate(s):\n        sa[ord(c)-ord('a')].append(i)\n    ls = len(s)\n    ans = 0\n    i = 0\n    for c in t:\n        a = sa[ord(c)-ord('a')]\n        if len(a) == 0 or i > a[-1]:\n            ans += ls - i%ls\n            i = 0\n        for j in a:\n            if j >= i:\n                ans += j-i\n                i = j\n                break\n    print(ans+1)\nif __name__ == '__main__':\n    main()"
  ],
  [
    "x, y = map(int, input().split())\ncount = 0\nfor i in range(x, y + 1):\n    if(str(i) == str(i)[::-1]):\n        count += 1\nprint(count)"
  ],
  [
    "X = int(input())\ntmp = 100\ncnt = 0\nwhile tmp < X:\n    tmp = tmp + int(tmp*0.01)\n    cnt += 1\nprint(cnt)"
  ],
  [
    "dp=[[0 for j in range(10)] for i in range(10)]\nh,w=map(int,input().split())\nfor i in range(10):\n    s=list(map(int,input().split()))\n    for j in range(10):\n        dp[i][j]=s[j]\nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j])\nc=0\nfor i in range(h):\n    s=list(map(int,input().split()))\n    for j in range(w):\n        if s[j]==-1 or s[j]==1:\n            continue\n        else:\n            c+=dp[s[j]][1]\nprint(c)"
  ],
  [
    "  def is_straight_way(a, b, c):\n    if a < b < c:\n        return \"Yes\"\n    else:\n        return \"No\""
  ],
  [
    "H1, M1, H2, M2, K = map(int, input().split())\nstart_minutes = H1 * 60 + M1\nend_minutes = H2 * 60 + M2\nstudy_period = end_minutes - start_minutes - K\nprint(study_period)\n"
  ],
  [
    "def inputlist(): return [int(j) for j in input().split()]\nN, Q = inputlist()\ntree = [[] for _ in range(N+1)]\nfor i in range(N-1):\n    a, b = inputlist()\n    tree[a].append(b)\n    tree[b].append(a)\nans = [0 for _ in range(N+1)]\nfor i in range(Q):\n    p, x = inputlist()\n    ans[p] += x\nfor i in range(1, N+1):\n    for x in tree[i]:\n        if i > x:\n            continue\n        ans[x] += ans[i]\nprint(*ans[1:])"
  ],
  [
    "n = int(input())\ns = input()\na = s.count(\"R\")\nb = s.count(\"G\")\nc = s.count(\"B\")\nz = a*b*c\nif z == 0:\n    print(0)\nelse:\n    R = []\n    G = []\n    B = []\n    for i in range(n):\n        if s[i] == \"R\":\n            R.append(i)\n        elif s[i] == \"G\":\n            G.append(i)\n        else:\n            B.append(i)\n    x = 0\n    for i in R:\n        for j in G:\n            if 0 <= 2*j-i < n and s[2*j-i] == \"B\":\n                x += 1\n            if 0 <= 2*i-j < n and s[2*i-j] == \"B\":\n                x += 1\n            if (i+j) % 2 == 0 and s[(i+j)//2] == \"B\":\n                x += 1\n    print(z-x)"
  ],
  [
    "N = int(input())\nA = list(map(int, input().split()))\nn_money = 1000\nn_stock = 0\nfor i in range(N-1):\n    if A[i+1] > A[i]:\n        n_stock = n_money // A[i]\n        n_money = n_money - n_stock * A[i]\n    else:\n        n_money += n_stock * A[i]\n        n_stock = 0\nn_money += n_stock * A[N-1]\nprint(n_money)"
  ],
  [
    "X,A,B=(int(i) for i in input().split())\nc=B-A\nif c<=0:\n  print('delicious')\nelif c<=X:\n  print('safe')\nelse:\n  print('dangerous')"
  ],
  [
    "n = int(input())\np = list(map(int, input().split()))\ncount = 0\nfor i in range(1, n - 1):\n  if (p[i - 1] < p[i] < p[i + 1]) or (p[i + 1] < p[i] < p[i - 1]):\n    count += 1\nprint(count)\n"
  ],
  [
    "def snk_check(lst):\n    flag = 0\n    if len(lst) == 1:\n        return lst\n    for i in range(len(lst) - 1):\n        if lst[i] + 1 != lst[i+1]:\n            del lst[i+1]\n            flag = 1\n            break\n    if flag == 1:\n        ans = lst[i:]  \n    else:\n        ans = lst[-1]  \n    return ans\ndef my_index(l, x, default=None):\n    if x in l:\n        return l.index(x)\n    else:\n        return default\ndef cut_before_first_one(lst):\n    place = my_index(lst, 1)\n    if place is not None:\n        return lst[place:]\n    else:\n        return None\ndef main():\n    N = int(input())\n    An = list(map(int, input().split()))\n    cut_list = cut_before_first_one(An)\n    if cut_list is not None:\n        snk_safe_list = []\n        while len(snk_safe_list) != 1:\n            snk_safe_list = snk_check(cut_list)\n        print(len(An) - len(snk_safe_list))\n    else:\n        print(-1)\nmain()"
  ],
  [
    "import sys\nimport math\ndef validate(r):\n    return int(r)\ndef main(args):\n    r = validate(args[1])\n    print(r**2)\nif __name__ == '__main__':\n    main(sys.argv)"
  ],
  [
    "  def max_remaining_cards(cards):\n    cards.sort(reverse=True)\n    remaining_cards = len(cards)\n    while remaining_cards > 1:\n        card1 = cards.pop()\n        card2 = cards.pop()\n        card3 = cards.pop()\n        if card1 > card2:\n            cards.remove(card1)\n        else:\n            cards.remove(card2)\n        cards.append(card3)\n        remaining_cards -= 1\n    return remaining_cards\nprint(max_remaining_cards([1, 2, 1, 3, 7])) \nprint(max_remaining_cards([1, 3, 5, 2, 1, 3, 2, 8, 8, 6, 2, 6, 11, 1, 1])) "
  ],
  [
    "n = int(input())\nlis = []\nfor i in range(n):\n    lis.append(int(input()))\nlis.sort()\nmid = lis[n//2]\nfront, back = [], []\nflag = 1\nfor i in range((n-1)//2):\n    if flag:\n        front.append(lis[i])\n        back.append(lis[i + 1])\n        flag = 0\n    else:\n        front.append(lis[n - i - 1])\n        back.append(lis[n - i - 2])\n        flag = 1\nif (n-1) % 2 == 1:\n    front.append(lis[n//2-1])\nans_M = mid - front[0] + mid - back[0]\nfor i in range(1, len(front)):\n    ans_M += abs(front[i] - front[i-1])\nfor i in range(1, len(back)):\n    ans_M += abs(back[i] - back[i-1])\nmid = lis[n//2 - 1]\nfront, back = [], []\nflag = 1\nfor i in range((n-1)//2):\n    if flag:\n        front.append(lis[n - i - 1])\n        back.append(lis[n - i - 2])\n        flag = 0\n    else:\n        front.append(lis[i])\n        back.append(lis[i + 1])\n        flag = 1\nif (n-1) % 2 == 1:\n    front.append(lis[n//2])\nans_m = front[0] - mid + back[0] - mid\nfor i in range(1, len(front)):\n    ans_m += abs(front[i] - front[i-1])\nfor i in range(1, len(back)):\n    ans_m += abs(back[i] - back[i-1])\nprint(max(ans_M, ans_m))"
  ],
  [
    "s = input()\nt = input()\nn = len(s)\nm = len(t)\ndp = [[float('inf')] * (m + 1) for _ in range(n + 1)]\nfor i in range(n + 1):\n    dp[i][0] = 0\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        if s[i - 1] == t[j - 1]:\n            dp[i][j] = dp[i - 1][j - 1]\n        else:\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\nprint(dp[n][m])\n"
  ],
  [
    "S = list(input())\nn = S.count('N')\ns = S.count('S')\ne = S.count('E')\nw = S.count('W')\nprint(\"Yes\" if n == s and e == w else \"No\")"
  ],
  [
    "def count_pairs(L):\n    count = 0\n    for a in range(L+1):\n        for b in range(L+1):\n            if a + b <= L and a + b == a ^ b:\n                count += 1\n    return count % (10**9 + 7)\n"
  ],
  [
    "A1, A2, A3 = map(int, input().split())\nif A1 + A2 + A3 >= 22:\n    print('bust')\nelse:\n    print('win')"
  ],
  [
    "n, m = map(int, input().split())\nbroken_steps = set()\nfor _ in range(m):\n    broken_steps.add(int(input()))\ndp = [0] * (n + 1)\ndp[0] = 1\ndp[1] = 1\nfor i in range(2, n + 1):\n    if i in broken_steps:\n        continue\n    dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007\nprint(dp[n])"
  ],
  [
    "N = int(input())\na = []\nfor i in range(N):\n  a.append(input())\nb = set(a)\nprint(len(b))"
  ],
  [
    "h1, m1, h2, m2, k = map(int, t_update.split())\nif h1 == h2:\n    print(0)\nelse:\n    print((h2 - h1 - 1) * 60 + 60 - m1 + m2)\nHere is the fixed code:\nimport sys\ninput = sys.stdin.readline\nt = input()\nt_update = t[0]\nfor i in t[1:]:\n    if i == \"?\":\n        i = \" \"\n    t_update += i\nh1, m1, h2, m2, k = map(int, t_update.split())\nif h1 == h2:\n    if m1 + k > m2:\n        print(0)\n    else:\n        print(m2 - m1 - k)\nelse:\n    print((h2 - h1 - 1) * 60 + 60 - m1 + m2 - k)"
  ],
  [
    "def main(sample_file = ''):\n    import sys\n    sys.setrecursionlimit(10**7)\n    from itertools import accumulate, combinations, permutations, product \n    from math import factorial, ceil, floor, sqrt\n    def factorize(n):\n        fct = []  \n        b, e = 2, 0  \n        while b * b <= n:\n            while n % b == 0:\n                n = n // b\n                e = e + 1\n            if e > 0:\n                fct.append((b, e))\n            b, e = b + 1, 0\n        if n > 1:\n            fct.append((n, 1))\n        return fct\n    def combinations_count(n, r):   \n        if n < 0 or r < 0:\n            raise Exception('combinations_count(n, r) not defined when n or r is negative')\n        if n - r < r: r = n - r\n        if r < 0: return 0\n        if r == 0: return 1\n        if r == 1: return n\n        numerator = [n - r + k + 1 for k in range(r)]\n        denominator = [k + 1 for k in range(r)]\n        for p in range(2,r+1):\n            pivot = denominator[p - 1]\n            if pivot > 1:\n                offset = (n - r) % p\n                for k in range(p-1,r,p):\n                    numerator[k - offset] /= pivot\n                    denominator[k] /= pivot\n        result = 1\n        for k in range(r):\n            if numerator[k] > 1:\n                result *= int(numerator[k])\n        return result\n    def combinations_with_replacement_count(n, r):\n        if n < 0 or r < 0:\n            raise Exception('combinations_with_replacement_count(n, r) not defined when n or r is negative')\n        elif n == 0:\n            return 1\n        else:\n            return combinations_count(n + r - 1, r)\n    from bisect import bisect_left, bisect_right\n    from collections import deque, Counter, defaultdict \n    from heapq import heapify, heappop, heappush, heappushpop, heapreplace,nlargest,nsmallest \n    from copy import deepcopy, copy \n    import operator\n    from operator import itemgetter \n    from functools import reduce, lru_cache\n    def chmin(x, y):\n        if x > y:\n            x = y\n            return (x, True)\n        else:\n            return (x, False)\n    def chmax(x, y):\n        if x < y:\n            x = y\n            return (x, True)\n        else:\n            return (x, False)\n    from fractions import gcd \n    def gcds(numbers):\n        return reduce(gcd, numbers)\n    def lcm(x, y):\n        return (x * y) // gcd(x, y)\n    def lcms(numbers):\n        return reduce(lcm, numbers, 1)\n    def make_divisors(n, reversed=False):\n        divisors = set()\n        for i in range(1, int(n**0.5)+1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n//i)\n        return sorted(list(divisors),reverse=reversed)\n    INF = 10 ** 18\n    MOD = 10 ** 9 + 7\n    AtoZ = list('abcdefghijklmnopqrsruvwxyz') \n    modpow = lambda a, n, p = MOD: pow(a, n, p) \n    def modinv(a, p = MOD):\n        return modpow(a, p-2, p)\n    def modinv_list(n, p = MOD):\n        if n <= 1:\n            return [0,1][:n+1]\n        else:\n            inv_t = [0,1]\n            for i in range(2, n+1):\n                inv_t += [inv_t[p % i] * (p - int(p / i)) % p]\n            return inv_t\n    def modfactorial_list(n, p = MOD):\n        if n == 0:\n            return [1]\n        else:\n            l = [0] * (n+1)\n            tmp = 1\n            for i in range(1, n+1):\n                tmp = tmp * i % p\n                l[i] = tmp\n            return l\n    def modcomb(n, k, fac_list = [], p = MOD):\n        from math import factorial\n        if n < 0 or k < 0 or n < k: return 0\n        if n == 0 or k == 0: return 1\n        if len(fac_list) <= n:\n            a = factorial(n) % p\n            b = factorial(k) % p\n            c = factorial(n-k) % p\n        else:\n            a = fac_list[n]\n            b = fac_list[k]\n            c = fac_list[n-k]\n        return (a * modpow(b, p-2, p) * modpow(c, p-2, p)) % p\n    def modadd(a, b, p = MOD):\n        return (a + b) % MOD\n    def modsub(a, b, p = MOD):\n        return (a - b) % p\n    def modmul(a, b, p = MOD):\n        return ((a % p) * (b % p)) % p\n    def moddiv(a, b, p = MOD):\n        return modmul(a, modpow(b, p-2, p))\n    class UnionFindTree:\n        def __init__(self, N):\n            self.root = [-1] * (N+1)\n            self.rank   = [0]  * (N+1)\n            self.connected_num = [1] * (N+1)\n        def find_root(self,x):\n            root = self.root\n            while root[x] != -1:\n                x = root[x]\n            return x\n        def unite(self,x,y):\n            root = self.root\n            rank = self.rank\n            connected_num = self.connected_num\n            find_root = self.find_root\n            rx = find_root(x)\n            ry = find_root(y)\n            if rx != ry:\n                if rank[rx] < rank[ry]:\n                    root[rx] = ry\n                    rx,ry = ry,rx\n                else:\n                    if rank[rx] == rank[ry]:\n                        rank[rx] += 1\n                    root[ry] = rx       \n                connected_num[rx] += connected_num[ry]\n    class SegTree:\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    def BellmanFord(N, M, ABC, vertex_start, vertex_end, value_if_inf = -1, find_shortest = False):\n        def make_reachable_list(N, M, ABC, vertex_start, vertex_end):\n            reachable_to_direct = defaultdict(list)\n            reachable_from_direct = defaultdict(list)\n            reachable_from_start = [False] * N\n            reachable_to_end = [False] * N\n            reachable_from_start[vertex_start] = True\n            reachable_to_end[vertex_end] = True\n            reachable_from_both_sides = [False] * N\n            dfs_from_start = []\n            dfs_to_end = []\n            for a, b, c in ABC:\n                reachable_to_direct[a].append(b)\n                reachable_from_direct[b].append(a)\n                if a == vertex_start:\n                    dfs_from_start.append(b)\n                    reachable_from_start[b] = True\n                if b == vertex_end:\n                    dfs_to_end.append(a)\n                    reachable_to_end[a] = True\n            while dfs_from_start:\n                v = dfs_from_start.pop()\n                for i in reachable_to_direct[v]:\n                    if not reachable_from_start[i]:\n                        reachable_from_start[i] = True\n                        dfs_from_start.append(i)\n            while dfs_to_end:\n                v = dfs_to_end.pop()\n                for i in reachable_from_direct[v]:\n                    if not reachable_to_end[i]:\n                        reachable_to_end[i] = True\n                        dfs_to_end.append(i)\n            for i in range(N):\n                reachable_from_both_sides[i] = reachable_from_start[i] and reachable_to_end[i]\n            return reachable_from_both_sides\n        reachable_from_both_sides = make_reachable_list(N, M, ABC, vertex_start, vertex_end)\n        if find_shortest:\n            dist = [INF for i in range(N)]\n        else:\n            dist = [-INF for i in range(N)]\n        dist[vertex_start] = 0\n        for i in range(N):\n            updated = False\n            for a, b, c in ABC:\n                if not reachable_from_both_sides[a]:\n                    continue\n                elif find_shortest:\n                    update_condition = dist[a] + c < dist[b]\n                else:\n                    update_condition = dist[a] + c > dist[b]\n                if dist[a] != INF and update_condition:\n                    dist[b] = dist[a] + c\n                    updated = True\n                    if i == N-1:\n                        return value_if_inf\n            if not updated:\n                break\n        return dist[vertex_end]\n    def warshall_floyd(number_vertex, XYD, shift_one_for_vertex=False):\n        d = [[float(\"inf\")]*number_vertex for i in range(number_vertex)]\n        for x, y, dist in XYD:\n            if shift_one_for_vertex:\n                x = x - 1\n                y = y - 1\n            d[x][y] = dist\n            d[y][x] = dist\n        for i in range(number_vertex):\n            d[i][i] = 0 \n        for k in range(number_vertex):\n            for i in range(number_vertex):\n                for j in range(number_vertex):\n                    d[i][j] = min(d[i][j],d[i][k] + d[k][j])\n        return d\n    r = lambda: sys.stdin.readline().strip()\n    r_int = lambda: int(r())\n    r_float = lambda: float(r())\n    R = lambda: list(map(int, r().split()))\n    R_str = lambda: r().split()\n    R_map = lambda: map(int, r().split())\n    R_float = lambda: list(map(float, r().split()))\n    R_tuple = lambda: tuple(map(int, r().split()))\n    if sample_file:\n        sys.stdin = open(sample_file)\n    N = r_int()\n    AB = [R() for _ in range(N-1)]\n    tree = [[] for _ in range(N)]\n    for a, b in AB:\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    task = [(i, [0]) for i in tree[0]]\n    arrived = [0] * N\n    arrived[0] = 1\n    while task:\n        node, parent = task.pop()\n        for child in tree[node]:\n            if child == N-1:\n                way = parent + [node, N-1]\n                break\n            if arrived[child] == 0:\n                arrived[child] = 1\n                task.append((child, parent+[node]))\n    kireme = way[(len(way)-1)//2]\n    kireme_ikenai = way[(len(way)-1)//2+1]\n    cnt = 0\n    task = [0]\n    arrived = [0] * N\n    while task:\n        node = task.pop()\n        cnt += 1\n        arrived[node] = 1\n        for child in tree[node]:\n            if child == kireme_ikenai:\n                continue\n            else:\n                if not arrived[child]:\n                    task.append(child)\n    if cnt > N - cnt:\n        print('Fennec')\n    else:\n        print('Snuke')\nif __name__ == '__main__':\n    main()"
  ],
  [
    "def solve():\n    H, W = IL()\n    A = ILL(H)\n    x = 0\n    y = -1\n    temoti = None\n    if H % 2 == 1:\n        xg = W - 1\n    else:\n        xg = 0\n    yg = H - 1\n    ans = []\n    while x != xg or y != yg:\n        if x == 0:\n            if y % 2 == 1:\n                y += 1\n            else:\n                x += 1\n        elif x == W - 1:\n            if y % 2 == 1:\n                x -= 1\n            else:\n                y += 1\n        else:\n            if y % 2 == 1:\n                x -= 1\n            else:\n                x += 1\n        if temoti == None:\n            if A[y][x] % 2 == 1:\n                temoti = (y, x)\n        else:\n            if A[y][x] % 2 == 1:\n                ans.append([temoti[0] + 1, temoti[1] + 1, y + 1, x + 1])\n                temoti = None\n            else:\n                ans.append([temoti[0] + 1, temoti[1] + 1, y + 1, x + 1])\n                temoti = (y, x)\n    print(len(ans))\n    for a in ans:\n        print(*a)"
  ],
  [
    "import math\nN = int(input())\nX = math.floor(N / 1.08)\nif N == X * 1.08:\n    print(X)\nelse:\n    print(\":(\")"
  ],
  [
    "N, K = map(int, input().split())\nnum_digits = 0\nwhile N > 0:\n    N //= K\n    num_digits += 1\nprint(num_digits)\n"
  ],
  [
    "N = int(input())\nnumber1 = [2,4,5,7,9]\nnumber2 = [3]\nnumber3 = [0,1,6,8]\nif N % 10 in number1:\n    print(str(N) + 'hon')\nelif N % 10 in number2:\n    print(str(N) + 'bon')\nelse:\n    print(str(N) + 'pon')"
  ],
  [
    "import copy\nS_list = list(input())\nK = int(input())\nif len(S_list) == 1:\n    print(K // 2)\nelif len(S_list) == 2:\n    if S_list[0] == S_list[1]:\n        print(K)\n    else:\n        print(0)\nelse:\n    S2_list = copy.copy(S_list)\n    for i in range(1, len(S_list)):\n        if S_list[i - 1] == S_list[i]:\n            S_list[i] = \"change\"\n    if S_list[0] == S_list[-1]:\n        S2_list[0] = \"change\"\n        for i in range(1, len(S2_list)):\n            if S2_list[i - 1] == S2_list[i]:\n                S2_list[i] = \"change\"\n        print((K // 2 + 1) * S_list.count('change') + (K // 2) * S2_list.count('change'))\n    else:\n        print(K * S_list.count('change'))"
  ],
  [
    "s = input()\nif not ((\"N\" in s) ^ (\"S\" in s)) and not ((\"E\" in s) ^ (\"W\" in s)):\n    print(\"Yes\")\nelse:\n    print(\"No\")"
  ],
  [
    "import sys \nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readline\nmod = 10 ** 9 +7\nK = int(readline())\nS = readline().decode()\ns = len(S)\nn = s+K\nfact = [1] * (n+1)\nfact_inv = [1] * (n+1)\nfor i in range(1,n+1):\n    fact[i] = fact[i-1] * i % mod \nfact_inv[n] = pow(fact[n],mod-2,mod)\nfor i in range(n,0,-1):\n    fact_inv[i-1] = (i * fact_inv[i]) % mod \ndef comb(n,r):\n  return fact[n] * fact_inv[r] * fact_inv[n-r] % mod\nans = 0\nfor i in range(K+1):\n    ans += (comb(i+s-1,s-1) * pow(25,i,mod) % mod * pow(26,K-i,mod)) % mod\nprint(ans%mod)"
  ],
  [
    "n, y = map(int, input().split())\na, b, c = -1, -1, -1\ntry:\n  for i in range(n + 1):\n    for j in range(n - i + 1):\n      k = n - (i + j)\n      if ((i * 10000) + (j * 5000) + (k * 1000) == y) and (i + j + k == n):\n        a, b, c = i, j, k\n        raise StopIteration\nfinally:\n  print(a, b, c)"
  ],
  [
    "d, t, s = map(float, input().split())\nif d / s <= t:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
  ],
  [
    "  def get_subscribers(n, a, b):\n    max_subscribers = min(a, b)\n    min_subscribers = max(0, a + b - n)\n    return max_subscribers, min_subscribers\ndef main():\n    n, a, b = map(int, input().split())\n    max_subscribers, min_subscribers = get_subscribers(n, a, b)\n    print(max_subscribers, min_subscribers)\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "n = int(input())\na = [int(input()) for _ in range(n)]\nodd_piles = [x for x in a if x % 2 == 1]\nif len(odd_piles) % 2 == 1:\n    print('first')\nelse:\n    print('second')\n"
  ],
  [
    "n=int(input())\na=list(map(int,input().split()))\ncount4=0\ncount2=0\nfor i in a:\n  if i%4==0:\n    count4+=1\n  elif i%2==0:\n    count2+=1\nif count2==1:\n  count1=len(a)-count4\nelse:\n  count1=len(a)-count4-count2\nif len(a)==1 and a[0]%4!=0:\n  print(\"No\")\nelif count1-count4<=1:\n  print(\"Yes\")\nelse:\n  print(\"No\")"
  ],
  [
    "import numpy as np\nN, M = [int(a) for a in input().split()]\nP = []\nY = []\nfor _ in range(M):\n    p, y =  [int(a) for a in input().split()]\n    P.append(p)\n    Y.append(y)\nindex = {}\nid = [\"\" for _ in range(len(P))]\nfor i in np.argsort(Y):\n    index[P[i]] = index.get(P[i], 0)\n    id[i] = \"{0:06d}\".format(P[i])+\"{0:06d}\".format(index[P[i]])\n    index[P[i]] += 1\nfor i in id:\n    print(i)"
  ],
  [
    "n, k = map(int, input().split())\nr, s, p = map(int, input().split())\nt = input()\nmax_scores = [0] * (k + 1)\ncurrent_max = 0\nfor i in range(n):\n    if i >= k:\n        current_max = max(max_scores[i - k], current_max)\n    if t[i] == 'r':\n        max_scores[i % (k + 1)] = current_max + p\n    elif t[i] =='s':\n        max_scores[i % (k + 1)] = current_max + r\n    else:\n        max_scores[i % (k + 1)] = current_max + s\nprint(max(max_scores))\n"
  ],
  [
    "n, k = map(int, input().split())\nmod = pow(10, 9) + 7\ndef cmb(n, r):\n    res = 1\n    fac = 1\n    for i in range(r):\n        res *= (n-i)\n        res %= mod\n        fac *= (i+1)\n        fac %= mod\n    return res*pow(fac, mod-2, mod) % mod\nif n <= k-1:\n    print(cmb(2*n-1, m))\nelse:\n    answer = 0\n    for m in range(k+1):\n        answer += cmb(n, m)*cmb(n-1, a) % mod\nprint(answer % mod)"
  ],
  [
    "x, y, z = map(int, input().split())\nA = (z + 0.5) // x\nprint(A * y)"
  ],
  [
    "n=int(raw_input())\nl=[[*map(raw_int,input().split())] for i in range(n)]\nans=0\nprev=\"\"\nfor i in range(n):\n    a,b,c=l[i]\n    if(a>b and a>c):\n        if(prev!='a'):\n            ans+=a\n            prev='a'\n        else:\n            x=[a,b,c]\n            x.sort()\n            y=l[i-1].copy()\n            y.sort()\n            if(l[i-1][0]+x[1]>=y[1]+x[-1]):\n                ans+=x[1]\n                if(x[1]==a):\n                    prev='a'\n                elif(x[1]==b):\n                    prev='b'\n                else:\n                    prev='c'\n            else:\n                ans-=y[-1]\n                ans+=(y[1]+a)\n                prev='a'\n    elif(b>a and b>c):\n        if(prev!='b'):\n            prev='b'\n            ans+=b\n        else:\n            x=[a,b,c]\n            x.sort()\n            y=l[i-1].copy()\n            y.sort()\n            if(l[i-1][1]+x[1]>=y[1]+x[-1]):\n                ans+=x[1]\n                if(x[1]==a):\n                    prev='a'\n                elif(x[1]==b):\n                    prev='b'\n                else:\n                    prev='c'\n            else:\n                ans-=y[-1]\n                ans+=(y[1]+b)\n                prev='b'\n    elif(c>a and c>b):\n        if(prev!='c'):\n            ans+=c\n            prev='c'\n        else:\n            x=[a,b,c]\n            x.sort()\n            y=l[i-1].copy()\n            y.sort()\n            if(l[i-1][2]+x[1]>=y[1]+x[-1]):\n                ans+=x[1]\n                if(x[1]==a):\n                    prev='a'\n                elif(x[1]==b):\n                    prev='b'\n                else:\n                    prev='c'\n            else:\n                ans-=y[-1]\n                ans+=(y[1]+c)\n                prev='c'\n    else:\n        ans+=max(l[i])\n        z=max(l[i])\n        if(z==a and prev!='a'):\n            prev='a'\n        elif(z==b and prev!='b'):\n            prev='b'\n        else:\n            prev='c'\nprint ans"
  ],
  [
    "n, m = map(int, input().split())\nif m % 2 == 0 and 2 * n <= m <= 4 * n:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
  ],
  [
    "n, p = map(int, input().split())\na = [int(i) for i in input().split()]\nb = [i % 2 for i in a]\nodd_count = b.count(1)\nif p == 0:\n    ans = 2 ** (n - odd_count)\nelse:\n    if odd_count == 0:\n        ans = 0\n    else:\n        ans = 2 ** (n - 1) - 2 ** (n - odd_count)\nprint(ans)"
  ],
  [
    "a=x\nans=a\nflg=[0]*m\nl=[a]\nlp=0\nfor i in range(1,m+1):\n    if n <= i:\n        break\n    tmp=(a*a)%m\n    a=tmp\n    if flg[a]==1:\n        lp = l.index(a)\n        break\n    else:\n        ans+=tmp\n        l.append(a)\n        flg[a]=1\nif lp!= 0:\n    l2 = l[lp:]\n    tmp = sum(l2)\n    b=(n-len(l))//len(l2)\n    c=n-len(l)-b*len(l2)\n    ans=ans+(b*tmp)+sum(l2[:c])\nprint(ans)"
  ],
  [
    "import sys,heapq,resource\nfrom collections import deque,defaultdict\nprintn = lambda x: sys.stdout.write(x)\ninn = lambda : int(input())\ninl   = lambda: list(map(int, input().split()))\ninm   = lambda:      map(int, input().split())\nDBG = True \nR = 10**9 + 7\ndef ddprint(x):\n  if DBG:\n    print(x)\ndef perm(k,d):\n    x = k\n    for i in range(1,d):\n        x = (x * (k-i)) % R\n    return x\ndef dfs(prev, cur):\n    d = len(dst[cur])-1\n    if d==0:\n        return k-1\n    x = perm(k-2,d)\n    for nd in dst[cur]:\n        if nd==prev:\n            continue\n        x = (x * dfs(cur,nd)) % R\n    return x\nsys.setrecursionlimit(250000)\nsoft,hard = resource.getrlimit(resource.RLIMIT_STACK)\nresource.setrlimit(resource.RLIMIT_STACK,(200000,hard))\nn,k = inm()\ndst = [ [] for i in range(n) ]\nfor i in range(n-1):\n    a,b = inm()\n    a -= 1\n    b -= 1\n    dst[a].append(b)\n    dst[b].append(a)\nx = 1\nfor i in range(n):\n    d = len(dst[i])\n    x = (x * perm(k-1,d)) % R\nprint(x)"
  ],
  [
    "x, a, b = tuple(map(int, input().split()))\nif a + b <= x:\n  print(\"delicious\")\nelif a + b <= x + 1:\n  print(\"safe\")\nelse:\n  print(\"dangerous\")"
  ],
  [
    "import bisect\nn = int(input())\na = [i*2 for i in list(map(int, input().split()))]\na.sort()\nif n == 2:\n    print(a[1]//2, a[0]//2)\n    exit()\nx = a[-1]\nindex = bisect.bisect_left(a[:-1], x/2)\ndiff0 = abs(x-a[index-1])\ndiff1 = abs(x-a[index])\ndiff2 = abs(x-a[index+1])\nif diff1 > diff2:\n    print(x//2, a[index]//2)\nelse:\n    print(x//2, a[index+1]//2)"
  ],
  [
    "import numpy as np\nimport math\nK = int(input())\nS = input()\nans = (26)**K * math.factorial(K + len(S)) / math.factorial(K) / math.factorial(len(S))\nprint(int(ans) % (10**9 + 7))"
  ],
  [
    "a, b = map(int, input().split())\nif (a + b) % 2 == 0:\n  print((a + b) // 2)\nelse:\n  print(\"IMPOSSIBLE\")\n"
  ],
  [
    "  s = input()\nif \"CF\" in s:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
  ],
  [
    "A, V = input().split()\nA = int(A)\nV = int(V)\nB, W = input().split()\nB = int(B)\nW = int(W)\nT = int(input())\nrel_v = V - W\nd = abs(A - B)\nif rel_v < 0:\n  print(\"NO\")\nelse:\n  if d < (rel_v * T):\n    print(\"NO\")\n  else:\n    print(\"YES\")"
  ],
  [
    "import sys\ninput = sys.stdin.readline\na, b, c = map(int, input().split())\nif b - a == c - b:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
  ],
  [
    "def can_permute(a):\n    n = len(a)\n    for i in range(n-1):\n        if a[i] % 2 != 0 and a[i+1] % 2 != 0:\n            return False\n    return True\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    if can_permute(a):\n        print(\"Yes\")\n    else:\n        print(\"No\")\nif __name__ == \"__main__\":\n    main()\n"
  ],
  [
    "import sys\ndef floyd_warshall(cost_matrix):\n    for k in range(10):\n        for i in range(10):\n            for j in range(10):\n                cost_matrix[i][j] = min(cost_matrix[i][j], cost_matrix[i][k] + cost_matrix[k][j])\n    return cost_matrix\ndef min_cost(cost_matrix, wall):\n    h, w = len(wall), len(wall[0])\n    dp = [[float('inf')] * 10 for _ in range(h)]\n    dp[0][1] = 0\n    for i in range(h):\n        for j in range(w):\n            if wall[i][j]!= -1:\n                for k in range(10):\n                    dp[i][k] = min(dp[i][k], dp[i-1][wall[i][j]] + cost_matrix[wall[i][j]][k])\n            else:\n                for k in range(10):\n                    dp[i][k] = min(dp[i][k], dp[i-1][k])\n    return min(dp[-1])\ndef main():\n    h, w = map(int, sys.stdin.readline().split())\n    cost_matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(10)]\n    wall = [list(map(int, sys.stdin.readline().split())) for _ in range(h)]\n    cost_matrix = floyd_warshall(cost_matrix)\n    print(min_cost(cost_matrix, wall))\nif __name__ == '__main__':\n    main()\n"
  ],
  [
    "  def get_area_ratio(r):\n    return (math.pi * r ** 2) // math.pi"
  ],
  [
    "n,k,s=map(int,input().split())\na=[s]*k+[s+1]*(n-k)\nprint(*a)"
  ],
  [
    "from collections import deque\nN, M = map(int, input().split())\nG = [[] for i in range(3*N)]\nfor i in range(M):\n    u, v = map(int, input().split())\n    G[3*(u-1)].append((3*(v-1)+1))\n    G[3*(u-1)+1].append((3*(v-1)+2))\n    G[3*(u-1)+2].append((3*(v-1)))\nS, T = map(int, input().split())\nused = [-1] * (3*N)\nused[3*(S-1)] = 0  \nq = deque([3*(S-1)])\nwhile len(q) > 0:\n    a = q.popleft()\n    d = used[a]\n    Vs = G[a]\n    for u in Vs:  \n        if used[u] == -1:\n            q.append(u)\n            used[u] = d+1\nprint(used[3*(T-1)]//3)"
  ],
  [
    "inp_str = input()\nN, K = list(map(int, inp_str.split(\" \")))\nMOD = 10**9 + 7\ndef choise(n, m):\n    if n == 0:\n        return 0\n    min_sum = (0 + m - 1) * m // 2 % MOD\n    max_sum = (2*n - m + 1) * m // 2 % MOD\n    return (max_sum - min_sum + 1) % MOD\nans_list = [choise(N, m) for m in range(K, N+2)]\nsum_ans = 0\nfor ans in ans_list:\n    sum_ans += ans\n    sum_ans = sum_ans % MOD\nprint(int(sum_ans))"
  ],
  [
    "a, b, c, k = map(int, input().split())\nif a >= k:\n    print(k)\nelse:\n    num = a\n    k -= a\n    if k >= b:\n        k -= b\n    else:\n        num -= k\nprint(num)"
  ],
  [
    "import sys\nsys.setrecursionlimit(10 ** 7)\nn,q = map(int,input().split())\nab = [list(map(int,input().split()))for _ in range(n-1)]\npx = [list(map(int,input().split()))for _ in range(q)]\ngraph = [[] for _ in range(n+3)]\nfor a,b in ab:\n    graph[a].append(b)\n    graph[b].append(a)\nvalue = [0]*(n+1)\nfor p,x in px:\n    value[p] += x\ndef dfs(v,add):\n    value[v] += add\n    for x in graph[v]:\n        dfs(x,add)\ndfs(1,0)\nprint(*value[1:],end=\"\\t\")"
  ],
  [
    "import itertools\nimport math\nn = int(input())\npoints = [list(map(int, input().split())) for _ in range(n)]\ntotal_distance = 0\nfor path in itertools.permutations(range(n)):\n    distance = 0\n    for i in range(n - 1):\n        x1, y1 = points[path[i]]\n        x2, y2 = points[path[i + 1]]\n        distance += math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    total_distance += distance\naverage_distance = total_distance / math.factorial(n)\nprint(average_distance)"
  ],
  [
    "k=int(input())\nprint(\"ACL\"*k)"
  ],
  [
    "K = int(input())\nprint(\"ACL\"*K)\n"
  ],
  [
    "H,N=map(int,input().split())\nL=[]\nfor i in range(N):\n    a,b=map(int,input().split())\n    L.append([a,b])\nL.sort()\nimport math\ndp=[10**20 for i in range(H+1)]\ndp[0]=0\nfor i in range(N):\n    for j in range(H+1):\n        if j-L[i][0]>=0:\n            dp[j]=min(dp[j],dp[j-L[i][0]]+L[i][1])\nprint(dp[H])"
  ],
  [
    "s = [a for a in input()]\nt = input()\nd = {v:0 for v in set(t)}\nfor v in t:\n    try: d[v] = s.index(v)\n    except:\n        print(-1)\n        exit()\ncnt = 0\nfor i in range(1,len(t)):\n    if d[t[i-1]]>d[t[i]]: cnt+=1\nif d[t[-1]]>d[t[-2]]:\n    print(len(s)*cnt+s.index(t[-1])+1)\nelse:\n    print(len(s)*(cnt-1)+s.index(t[-1])+1)"
  ],
  [
    "import sys\ndef gcd(a, b):\n    a, b = max(a, b), min(a, b)\n    while a % b > 0:\n        a, b = b, a % b\n    return b \ndef solve():\n    input = sys.stdin.readline\n    N = int(input())\n    A = [int(a) for a in input().split()]\n    mod = 10**9 + 7\n    gcdA = A[0]\n    lcmA = A[0]\n    for i in range(1, N):\n        gcdA = gcd(lcmA, A[i])\n        lcmA *=  (A[i] * pow(gcdA, mod - 2, mod)) % mod\n        lcmA %= mod\n    Ans = 0\n    for a in A:\n        Ans += (lcmA * pow(a, mod - 2, mod)) % mod\n        Ans %= mod\n    print(Ans)\n    return 0\nif __name__ == \"__main__\":\n    solve()"
  ],
  [
    "K, T = map(int, input().split())\na = list(map(int, input().split()))\nans = 0\nfor i in range(T):\n    ans += max(0, a[i] - 1)\nprint(ans)\n"
  ],
  [
    "N = int(input())\nN_str = str(N)\nif N_str == N_str[::-1]:\n    print('Yes')\nelse:\n    print('No')\n"
  ],
  [
    "A, B, M = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nd = min(a) + min(b)\ne = list(map(int, input().split()))\nc = e\nfor i in range(M - 1):\n    e = c\n    c = list(map(int, input().split()))\n    if c[2] > e[2]:\n        e = c\nf = a[e[0] - 1] + b[e[1] - 1] - e[2]\nif d > f:\n    d = f\nprint(d)"
  ],
  [
    "a, b = list(map(int, input().split()))\nprint((b * 1900 + (a - b) * 100) * 2 ** b)"
  ],
  [
    "S = input()\ncount = 0\nfor symbol in S:\n    if symbol == '+':\n        count += 1\n    else:\n        count -= 1\nprint(count)\n"
  ],
  [
    "N = int(input())\nS = input()\ndp = [[[False] * 1001] * 4] * 30001\ndp[0][0][0] = True\nfor ix in range(N):\n    for jx in range(4):\n        for kx in range(1000):\n            if dp[ix][jx][kx] == False:\n                continue\n            dp[ix+1][jx][kx] = True\n            if jx <= 2:\n                dp[ix+1][jx+1][kx*10+(ord(S[ix])-ord('0'))] = True\nans = 0\nfor p in range(1000):\n    if dp[N][3][p] == True:\n        ans += 1\nprint(ans)"
  ],
  [
    "N, R = input().split()\nif N < 10:\n    R -= 100 * (10 - N)\nprint(R)"
  ],
  [
    "import bisect\ndef solve_knapsack_problem():\n    num_items, total_time = map(int, input().split())\n    item_list = []\n    for _ in range(num_items):\n        weight, value = map(int, input().split())\n        item_list.append((weight, value))\n    item_list.sort()\n    dp = [0] * (total_time + 1)\n    prefix_sum = [0] * (num_items + 1)\n    for i in range(num_items):\n        prefix_sum[i + 1] = prefix_sum[i] + item_list[i][1]\n    for i in range(num_items):\n        weight, value = item_list[i]\n        for j in range(total_time, -1, -1):\n            if j + weight <= total_time:\n                k = bisect.bisect_right(item_list, (total_time - j - weight, 10**9))\n                dp[j + weight] = max(dp[j + weight], dp[j] + prefix_sum[k] + value)\n    print(max(dp))\nsolve_knapsack_problem()\n"
  ],
  [
    "H,W = map(int,input().split())\ndic = {}\nfor h in range(H):\n  s = list(input())\n  for x in s:\n    dic[x] = dic.get(x,0) + 1\nc1 = 0\nc2 = 0\nfor x in dic.values():\n  if x%2 == 1:\n    c1 += 1\n  if x%4 == 2:\n    c2 += 1\nif c1>(H%2)*(W%2):\n  print(\"No\")\nelse:\n  if c2>((W*(H%2))//2)+((H*(W%2))//2):\n    print(\"No\")\n  else:\n    print(\"Yes\")"
  ],
  [
    "r = int(input())\nprint(int(r*2))"
  ],
  [
    "N=int(input())\nA=list(map(int,input().split()))\nans=1\nfor i in range(N):\n    if A[i] == 0:\n        ans = 0\n        break\n    elif ans > 10**18 // A[i]:\n        ans = -1\n        break\n    else:\n        ans = ans * A[i]\nprint(ans)"
  ],
  [
    "import math\nx, y = map(int, input().split())\na = x * y // math.gcd(x, y)\na -= x\nif a > 0 and a <= 10**18:\n    print(int(a))\nelse:\n    print(-1)"
  ],
  [
    "import math\ndef combination(n, k):\n    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\nN, K = map(int, input().split())\nmod = 10**9 + 7\nfor i in range(1, K + 1):\n    print((combination(N - K + 1, i) * combination(K - 1, i - 1)) % mod)"
  ],
  [
    "def solve():\n    inputs = open(0).readlines()\n    h, w = map(int, inputs[0].split())\n    A = [list(map(lambda x: x.strip(), inputs[1:]))]\n    B = []\n    for S in A:\n        C = [0] * 26\n        for c in S:\n            C[ord(c)-ord('a')] += 1\n        B.append(C)\n    if w % 2 == 0:\n        if all(all(x % 2 == 0 for x in b) for b in B):\n            C = []\n        else:\n            return 'No'\n    else:\n        C = [[i for i, x in enumerate(b) if x % 2 != 0] for b in B]\n        if all(len(c) == 1 for c in C):\n            B = [[x if x % 2 == 0 else x-1 for x in b] for b in B]\n            C = Counter([c[0] for c in C]).values()\n        else:\n            return 'No'\n    C\n    D = Counter(map(tuple, B)).values()\n    if h % 2 == 0:\n        if all(c % 2 == 0 for c in C) and all(d % 2 == 0 for d in D):\n            return 'Yes'\n    else:\n        if sum(c % 2 for c in C) <= 1 and sum(d % 2 for d in D) <= 1:\n            return 'Yes'\n    return 'No'\nprint(solve())"
  ],
  [
    "n, k = map(int, input().split())\na = []\nfor _ in range(n):\n    ai, bi = map(int, input().split())\n    a.extend([ai] * bi)\na.sort()\nprint(a[k - 1])\n"
  ],
  [
    "n = int(input())\nflg = [0]*100000\nfor _ in range(n):\n    l,r = map(int,input().split())\n    flg[l-1:r] = [1]*(r-l+1)\nprint(sum(flg))"
  ],
  [
    "  def solve(N, M, C, B, A):\n    count = 0\n    for i in range(N):\n        sum = 0\n        for j in range(M):\n            sum += A[i][j] * B[j]\n        if sum + C > 0:\n            count += 1\n    return count"
  ],
  [
    "def solve(xv_sorted):\n    x = [0 for _ in range(n)]\n    y = [0 for _ in range(n)]\n    s = 0\n    buf = -float('inf')\n    for i in range(n):\n        s += xv_sorted[i][1]\n        x[i] = max(buf, s - 2 * xv_sorted[i][0])\n        buf = x[i]\n    s = 0\n    buf = -float('inf')\n    for i in sorted(range(n), reverse=True):\n        s += xv_sorted[i][1]\n        y[i] = max(buf, s - (c - xv_sorted[i][0]))\n        buf = y[i]\n    ans = max(x[n - 1], y[0])\n    for i in range(n - 1):\n        ans = max(ans, x[i] + y[i + 1])\n    return ans\nif __name__ == '__main__':\n    n, c = map(int, input().split())\n    xv = []\n    for i in range(n):\n        xv.append(list(map(int, input().split())))\n    xv_sorted = sorted(xv, key=lambda x:x[0])\n    ans = 0\n    ans = max(ans, solve(xv_sorted))\n    for i in range(n):\n        xv_sorted[i][0] = c - xv_sorted[i][0]\n    xv_sorted = sorted(xv, key=lambda x:x[0])\n    ans = max(ans, solve(xv_sorted))\n    print(ans)"
  ],
  [
    "from collections import Counter\nN = int(input())\nA = list(map(int, input().split()))\nC = Counter(A)\nC = sorted(C.items())\ncc = []\nfor a, b in C:\n    cc.append([a, b])\nC = cc\nM = len(C)\nleft = 0\nright = M - 1\nwhile True:\n    if C[left][1] < 2:\n        for left in range(M):\n            if C[left][1] > 1:\n                break\n    if C[right][1] < 2:\n        for right in range(M):\n            if C[M - right - 1][1] > 1:\n                break\n        right = M - right - 1\n    if C[left][1] <= 1 and C[right][1] <= 1:\n        break\n    if left == right:\n        if C[left][1] >= 3:\n            C[left][1] -= 2\n        else:\n            C[left][1] -= 1\n            for i in range(left + 1, M):\n                if C[i][1] > 0:\n                    C[i][1] -= 1\n                    break\n    else:\n        C[left][1] -= 1\n        C[right][1] -= 1\nans = 0\nfor a, b in C:\n    ans += b\nprint(ans)"
  ],
  [
    "from collections import*\nd=defaultdict(list)\nn,t=map(int,input().split())\nx=[list(map(int,input().split()))+[i]for i in range(n)]\nd[0]=[0,[]]\nfor time,value,idx in x:\n    for k,v in d.items():\n        if k+time<=t:\n            if len(d[k+time])==2:\n                if v[0]+value>d[k+time][0]:\n                    d[k+time]=[v[0]+value,v[1]+[idx]]\n            else:\n                d[k+time]=[v[0]+value,v[1]+[idx]]\ny,z=d[max(d.keys())]\nfor i in z[::-1]:\n    del x[i]\nprint(y+max(i[1] for i in x))"
  ],
  [
    "n = int(input())\ns = [input() for _ in range(n)]\na_count = [0] * n\nb_count = [0] * n\nfor i in range(n):\n    if s[i][-1] == 'A':\n        a_count[i] = 1\n    if s[i][0] == 'B':\n        b_count[i] = 1\nmax_ab = sum(a * b for a, b in zip(a_count, b_count))\nfor i in range(n):\n    if a_count[i] == 1 and b_count[i] == 1:\n        max_ab -= 1\n        break\nprint(max_ab)\n"
  ],
  [
    "import sys\nimport numpy as np\nn = (int(i) for i in input().split())\na = [int(i) for i in input().split()]\nb =  [int(i) for i in input().split()]\ndiff = sum(b) -sum(a)\nif(sum(b) == sum(a)):\n        flag = 0\n        for i in range(0,len(a)):\n                if(a[i] != b[i]):\n                        flag = 1\n        if(flag ==0):\n                print(\"Yes\")\n                sys.exit()\nif(sum(b) < sum(a)):\n        print(\"No\")\n        sys.exit()\nelse:\n        tmp = 0\n        tmp2 = 0\n        for i in range(0,len(a)):\n                if(b[i] > a[i]):\n                        tmp+=b[i] - a[i]\n                if(a[i] > b[i]):\n                        tmp2+=a[i] -b[i]\n        if(tmp/2.0 > diff or tmp2/2.0 > diff):\n                print(\"No\")\n                sys.exit()\n        print(\"Yes\")"
  ],
  [
    "def main():\n    s = input()\n    d = {}\n    poyo = ''\n    cnt = 0\n    c = ''\n    for i in s:\n        d[i] = 0\n    for i in s:\n        d[i] += 1\n    for i in s:\n        cnt = max(cnt, d[i])\n    for i in s:\n        if d[i] == cnt:\n            poyo += i\n    if cnt == 1:\n        c = s[int(len(s) / 2)]\n    for i in s[int((len(s) + cnt - 1) / cnt):]:\n        if i in poyo:\n            c = i\n            break\n    a = {}\n    r = 0\n    while True:\n        if len({i for i in s}) == 1:\n            break\n        else:\n            for i, e in enumerate(s):\n                if e == c:\n                    t = list(s)\n                    if i > 0:\n                        t[i-1] = c\n                    s = \"\".join(t)\n            s = s[:len(s)-1]\n            r += 1\n        if r == 10:\n            break\n    print(r)\nif __name__ == '__main__':\n    main()"
  ],
  [
    "import math\nn = int(input())\nmin_digits = math.ceil(math.log10(n))\nprint(min_digits)\n"
  ],
  [
    "n=input().split(\" \")\nfor i in range(3):\n  n[i]=int(n[i])\nans=n[2]-(n[0]-n[1])\nif ans <0:\n\tprint(0)\nelse:\n     print(ans)"
  ],
  [
    "N = int(input())\nM = N * (N - 1) // 2\nfor S in range(N, M+1):\n    A = [[0] * N for _ in range(N)]\n    E = 0\n    for i in range(N):\n        s = S - sum(A[i])\n        if s < 0:\n            break\n        for j in reversed(range(i+1,N)):\n            if s - i - 1 > j + 1 or s == j + 1:\n                E += 1\n                A[i][j] = j + 1\n                A[j][i] = i + 1\n                s -= j + 1\n            if s == 0:\n                break\n        else:\n            continue\n    else:\n        print(E)\n        for i in range(N):\n            for j in range(i+1,N):\n                if A[i][j] > 0:\n                    print(i+1, j+1)\n        break"
  ],
  [
    "r, c, k = map(int, input().split())\nl = [list(map(int, input().split())) for _ in range(k)]\ns = [[0 for _ in range(c+1)] for _ in range(r+1)]\nfor r1, c1, v1 in l:\n    s[r1][c1] = v1\ndp = [[[0 for _ in range(4)] for _ in range(c+1)] for _ in range(r+1)]\nfor i in range(1, r+1):\n    for j in range(1, c+1):\n        for q in range(4):\n            if q < 3:\n                dp[i][j][q+1] = max(dp[i-1][j][q+1], dp[i][j-1][q+1], dp[i-1][j][q] + s[i][j], dp[i][j-1][q] + s[i][j])\n            else:\n                dp[i][j][q] = max(dp[i-1][j][q], dp[i][j-1][q], dp[i-1][j][q-1] + s[i][j], dp[i][j-1][q-1] + s[i][j])\nprint(max(dp[r][c]))"
  ],
  [
    "s = input()\ns = s.replace(s[-1], '')\nwhile True:\n    s = s.replace(s[-1], '')\n    if len(s) % 2 == 0 and s[:len(s) // 2] == s[len(s) // 2:]:\n        print(len(s))\n        break"
  ],
  [
    "import sys\ninput = sys.stdin.readline\nn = int(input())\nA = list(map(int,input().split()))\na = max(A)\nb = min(A)\nA.pop(a)\nA.pop(b)\nans = a-b\nfor i in range(n-2):\n    ans += abs(A[i])\nprint(ans)\nfor i in range(n-2):\n    if A[i] > 0:\n        print(b, A[i])\n        b -= A[i]\n    else:\n        print(a, A[i])\n        a -= A[i]\nprint(a, b)"
  ],
  [
    "print([\"No\",\"Yes\"][sorted(input()) == sorted(\"abc\")])"
  ],
  [
    "list1 = list(map(int, input().split()))\nlist2 = []\nlist2.append(list1[1])\nlist2.append(list1[2])\nlist2.append(list1[0])\nprint(list2)"
  ],
  [
    "N, M = map(int, input())\nans = (1900 * M + 100 * (N - M)) * 2 ** M\nprint(ans)"
  ],
  [
    "n = list(map(int, input().split()))\nn.sort()\nif n[0] + n[1] == n[2]:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
  ],
  [
    "import sys\ndef main():\n    n, k = map(int, input().split())\n    ans = 1\n    m = k\n    while n >= m:\n        m *= k\n        ans += 1\n    print(ans)\nif __name__ == '__main__':\n    main()"
  ],
  [
    "n, a, b = map(int, input().split())\nx = list(map(int, input().split()))\nans = 0\nfor i in range(n - 1):\n    dist = x[i + 1] - x[i]\n    walk = dist * a\n    teleport = b\n    ans += min(walk, teleport)\nprint(ans)"
  ],
  [
    "n = int(input())\ns = []\nfor i in range(n):\n  s.append(input())\ncnt = 0\nfor i in range(n):\n  for j in range(len(s[i])):\n    if s[i][j] == '(':\n      cnt += 1\n    else:\n      cnt -= 1\n    if cnt < 0:\n      print(\"No\")\n      exit()\nif cnt == 0:\n  print(\"Yes\")\nelse:\n  print(\"No\")\n"
  ],
  [
    "def count_subsequences(s, t):\n    n = len(s)\n    m = len(t)\n    MOD = 10**9 + 7\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 1\n    for j in range(m + 1):\n        dp[0][j] = 1\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + MOD) % MOD\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n    return dp[n][m]\nn, m = map(int, input().split())\ns = list(map(int, input().split()))\nt = list(map(int, input().split()))\nprint(count_subsequences(s, t))\n"
  ],
  [
    "def pow(n, k):\n    a = 1\n    for i in range(k):\n        a *= n\n    return a\nn, k = map(int, input().split())\ni = 0\nwhile True:\n    if n < pow(k, i):\n        print(i)\n        break\n    i += 1"
  ],
  [
    "import numpy as np\nsize = input()\npro = input()\np = np.array(pro.split(\" \"), dtype=np.int32)\np = np.sort(p)\nme = int(len(p) / 2) + 1\nprint(p[me] - p[me - 1])"
  ],
  [
    "  def get_max_value(R, C, K, r, c, v):\n    dp = [[[0] * (K + 1) for _ in range(C)] for _ in range(R)]\n    for i in range(R):\n        for j in range(C):\n            if i == 0 and j == 0:\n                dp[i][j][0] = v[i][j]\n            elif i == 0:\n                dp[i][j][0] = max(dp[i][j - 1][0], dp[i][j - 1][1] + v[i][j])\n            elif j == 0:\n                dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + v[i][j])\n            else:\n                dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + v[i][j], dp[i][j - 1][0], dp[i][j - 1][1] + v[i][j])\n    for i in range(R):\n        for j in range(C):\n            if i == R - 1 and j == C - 1:\n                dp[i][j][K] = v[i][j]\n            elif i == R - 1:\n                dp[i][j][K] = max(dp[i][j + 1][K - 1], dp[i][j + 1][K] + v[i][j])\n            elif j == C - 1:\n                dp[i][j][K] = max(dp[i + 1][j][K - 1], dp[i + 1][j][K] + v[i][j])\n            else:\n                dp[i][j][K] = max(dp[i + 1][j][K - 1], dp[i + 1][j][K] + v[i][j], dp[i][j + 1][K - 1], dp[i][j + 1][K] + v[i][j])\n    for i in range(R):\n        for j in range(C):\n            for k in range(1, K):\n                dp[i][j][k] = max(dp[i][j][k - 1], dp[i][j][k] + v[i][j])\n    return dp[R - 1][C - 1][K]"
  ],
  [
    "def gcd(a, b):\n  while b:\n    a, b = b, a % b\n  return a\ndef solve(n, k, a):\n  if k >= n - 1:\n    return max(a)\n  else:\n    g = a[0]\n    for i in range(1, n):\n      g = gcd(g, a[i])\n    if k > 0:\n      return g + (k // (n - 1))\n    else:\n      return g\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(solve(n, k, a))\n"
  ],
  [
    "a, b, c = map(int, input().split())\nif (a < c < b) or (a > c > b):\n  print(\"Yes\")\nelse:\n  print(\"No\")\n"
  ],
  [
    "import sys\nfrom bisect import bisect_left, bisect_right\ns = sys.stdin.readline().strip()\nt = sys.stdin.readline().strip()\nlen_s = len(s)\nC = {}\nfor i, a in enumerate(s * 2):\n    if a not in C:\n        C[a] = [i]\n    else:\n        C[a].append(i)\ncounter = 0\nmul = 0\nfor x in t:\n    if x not in C:\n        print(-1)\n        quit()\n    idx = bisect_left(C[x], counter)\n    counter = C[x][idx]\n    if len_s <= counter:\n        mul += 1\n        counter -= len_s\nprint(mul * len_s + counter + 1)"
  ],
  [
    "def find_shortest_path(n, a):\n    shortest_paths = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            shortest_paths[i][j] = a[i][j]\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if shortest_paths[i][k] + shortest_paths[k][j] < shortest_paths[i][j]:\n                    shortest_paths[i][j] = shortest_paths[i][k] + shortest_paths[k][j]\n    return shortest_paths[0][n-1]\ndef main():\n    n = int(input())\n    a = []\n    for _ in range(n):\n        a.append(list(map(int, input().split())))\n    print(find_shortest_path(n, a))\nif __name__ == \"__main__\":\n    main()\n"
  ],
  [
    "n, k = map(int, input().split())\nr, s, p = map(int, input().split())\nt = list(input())\nwin = []\nans = 0\nfor i in range(n):\n    if t[i] == \"r\":\n        win.append(\"p\")\n    elif t[i] == \"s\":\n        win.append(\"r\")\n    else:\n        win.append(\"s\")\nfor i in range(n):\n    if i >= k:\n        if win[i] == win[i - k]:\n            if i + k > n:\n                pass\n            elif win[i + k] != t[i]:\n                win[i] = t[i]\n            else:\n                if win[i] != r and [i + k] != r:\n                    win[i] = r\n                elif win[i] != s and [i + k] != s:\n                    win[i] = s\n                elif win[i] != p and [i + k] != p:\n                    win[i] = p\n        else:\n            if win[i] == \"r\":\n                ans += r\n            elif win[i] == \"s\":\n                ans += s\n            else:\n                ans += p\n    else:\n        if win[i] == \"r\":\n            ans += r\n        elif win[i] == \"s\":\n            ans += s\n        else:\n            ans += p\nprint(ans)"
  ],
  [
    "  def get_bill_combination(n, y):\n    if n == 1:\n        if y % 1000 == 0:\n            return [y // 1000, 0, 0]\n        else:\n            return [-1, -1, -1]\n    else:\n        for i in range(n):\n            if y - i * 10000 >= 0:\n                result = get_bill_combination(n - i, y - i * 10000)\n                if result != [-1, -1, -1]:\n                    return [i] + result\n        return [-1, -1, -1]\ndef main():\n    n, y = map(int, input().split())\n    result = get_bill_combination(n, y)\n    print(*result)\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "a, b, c = map(int, input().split())\nprint(min(a + b, a + c, b + c))"
  ],
  [
    "DPD_in = list(input())\nnumber_of_q = 0\nDPDsisu_list = []\nmax_DPDsisu_index = 0\nlen_DPD_in = len(DPD_in)\nfor i in range(len_DPD_in):\n    if DPD_in[i] == '?':\n        number_of_q += 1\nnum_of_DPDs = 2**number_of_q\nDPDs_list = [[''] * len_DPD_in for i in range(num_of_DPDs)]\nfor i in range(len_DPD_in):\n    if DPD_in[i] != '?':\n        for k in range(num_of_DPDs):\n            DPDs_list[k][i] = DPD_in[i]\n    else:\n        for k in range(num_of_DPDs):\n            if k % 2 == 0:\n                DPDs_list[k][i] = 'P'\n            else:\n                DPDs_list[k][i] = 'D'\nfor j in range(num_of_DPDs):\n    DPDsisu = 0\n    for i in range(len_DPD_in-1):\n        if (DPDs_list[j][i] == 'P') and (DPDs_list[j][i+1] == 'D'):\n            DPDsisu += 1\n        elif DPDs_list[j][i+1] == 'D':\n            DPDsisu += 1\n    DPDsisu_list.append(DPDsisu)\nfor i in range(num_of_DPDs):\n    if DPDsisu_list[i] > DPDsisu_list[max_DPDsisu_index]:\n        max_DPDsisu_index = i\nprint(''.join(DPDs_list[max_DPDsisu_index]))"
  ],
  [
    "s = list(input())\ndef cal(n):\n  if len(s) == 1:\n    return 0\n  else:\n    new = s[0]\n    ans = 0\n    cnt = 0\n    for i in range(1, n):\n      if s[i]!= new:\n        new = s[i]\n        cnt = 0\n        ans += (i + 1)\n      else:\n        cnt += 1\n        ans += cnt\n    return ans\nprint(cal(len(s)) + 1)"
  ],
  [
    "N = int(input())\nH = list(map(int, input()))\nans = 0\nfor i in range(1,N):\n  if H[i] == H[i-1]:\n    ans += 1\nprint(ans)"
  ],
  [
    "from math import gcd\na,b,c,d=map(int,input().split( ))\nr1=b-b%c\nif a%c!=0:\n\tl1=a-a%c+c\nelse:\n\tl1=a\nr2=b-b%d\nif a%d!=0:\n\tl2=a-a%d+d\nelse:\n\tl2=a\nlcm=(c*d)//gcd(c,d)\nr3=b-b%lcm\nif a%lcm!=0:\n\tl3=a-a%lcm+lcm\nelse:\n\tl3=a\nnc=(r1-l1)//c + 1\nnd=(r2-l2)//d + 1\nnlcm=(r3-l3)//lcm + 1\ndivi=nc+nd-nlcm\nout=b-a+1\nprint(out-divi)"
  ],
  [
    "import math\nN = int(input())\nprint(int(math.floor(math.sqrt(N))**2))\n"
  ],
  [
    "lis = list(map(int, input().split()))\nx = 0\nfor i in lis:\n    if i % 2 == 0 and (i % 3 == 0 or i % 5 == 0):\n        x = 1\nif x == 0:\n    print(\"APPROVED\")\nelse:\n    print(\"DENIED\")"
  ],
  [
    "N, A, B = map(int, input().split())\nprint(min(A, B), max(0, A + B - N))\n"
  ],
  [
    "def paint_blocks(n, m, k):\n    dp = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i > 1 and dp[i - 1] != j:\n                dp[i] += dp[i - 1]\n            if i < n and dp[i + 1] != j:\n                dp[i] += dp[i + 1]\n    return dp[n] % 998244353\n"
  ],
  [
    "n = int(input())\ns = input()\ncount = 0\nfor i in range(n - 2):\n    for j in range(i + 1, n - 1):\n        for k in range(j + 1, n):\n            if s[i] != s[j] and s[i] != s[k] and s[j] != s[k] and j - i != k - j:\n                count += 1\nprint(count)\n"
  ],
  [
    "import math\nN = int(input())\nsum = 0\nfor m in range(1, int(math.sqrt(N)) + 1):\n    if N // m == N % m:\n        sum += m\n        if m * m != N:\n            sum += N // m\nprint(sum)\n"
  ],
  [
    "import heapq\nif __name__ == \"__main__\":\n    K, T = map(int, input().split())\n    data = list(map(int, input().split()))\n    cake = []\n    for i, x in enumerate(data):\n        cake.append([x, i])\n    heapq._heapify_max(cake)\n    while (len(cake) > 1):\n        p = heapq._heappop_max(cake)\n        q = heapq._heappop_max(cake)\n        p[0] -= 1\n        q[0] -= 1\n        if p[0] > 0:\n            heapq.heappush(cake, p)\n        if q[0] > 0:\n            heapq.heappush(cake, q)\n    result = 0\n    if len(cake) > 0:\n        result = cake[0][0]\n    print(max(0, result - 1))"
  ],
  [
    "n, m = map(int, input().split())\npairs = []\nfor i in range(1, m + 1):\n    pairs.append((i, i + m))\nfor i in range(m + 1, n + 1):\n    for j in range(m):\n        if i not in pairs[j]:\n            pairs[j] = (pairs[j][0], i) if pairs[j][0]!= 0 else (i, pairs[j][1])\n            break\nfor pair in pairs:\n    print(*pair)\n"
  ],
  [
    "from math import gcd\ndef count_coprime_divisors(a, b):\n    g = gcd(a, b)\n    count = 0\n    for i in range(1, int(g**0.5) + 1):\n        if g % i == 0:\n            if gcd(i, g // i) == 1:\n                count += 2\n            elif i == g // i:\n                count += 1\n    return count\nA, B = map(int, input().split())\nprint(count_coprime_divisors(A, B))\n"
  ],
  [
    "X = int(input())\nroot = int(X**(1/5))\nif root**5 < X:\n    rest = X - root**5\n    another = -int(rest**(1/5))\nelse:\n    rest = root**5 - X\n    another = int(rest**(1/5))\nprint(root, another)"
  ],
  [
    "def solve(H, spells):\n    dp = [float('inf')] * (H + 1)\n    dp[0] = 0\n    for i in range(1, H + 1):\n        for a, b in spells:\n            if i - a >= 0:\n                dp[i] = min(dp[i], dp[i - a] + b)\n    return dp[H]\nH, N = map(int, input().split())\nspells = []\nfor _ in range(N):\n    a, b = map(int, input().split())\n    spells.append((a, b))\nprint(solve(H, spells))\n"
  ],
  [
    "s = input()\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\ns_list = set(s)\ns_list = sorted(s_list)\nif all(c in s_list for c in alphabet):\n    print('None')\nelse:\n    for i in range(len(s)):\n        if s_list[i] != alphabet[i]:\n            print(alphabet[i])\n            break"
  ],
  [
    "K, T = map(int, input().split())\na = list(map(int, input().split()))\na.sort(reverse=True)\nresult = 0\nprev = -1\nfor _ in range(K):\n    next = -1\n    for i in range(T):\n        if a[i] > 0 and i!= prev:\n            next = i\n            break\n    if next == -1:\n        next = prev\n        result += 1\n    a[next] -= 1\n    prev = next\nprint(result)\n"
  ],
  [
    "import numpy as np\nN = int(input())\nA = np.array([int(i) for i in input().split()])\nmax_gcd = 0\nfor i in range(1, 10**9 + 1):\n    Am = A.copy()\n    Am[0] = i\n    gcd = np.gcd.reduce(Am)\n    if gcd > max_gcd:\n        max_gcd = gcd\nprint(max_gcd)"
  ],
  [
    "  def tak_to_cell_n(n, k, segments):\n    mod = 998244353\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for j in range(k):\n            if segments[j][0] <= i <= segments[j][1]:\n                dp[i] += dp[i - segments[j][0]]\n                dp[i] %= mod\n    return dp[n]\ndef main():\n    n, k = map(int, input().split())\n    segments = []\n    for _ in range(k):\n        segments.append(list(map(int, input().split())))\n    print(tak_to_cell_n(n, k, segments))\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "def min_operations(s, k):\n    t = s * k\n    count = 0\n    for i in range(len(t) - 1):\n        if t[i] == t[i + 1]:\n            count += 1\n    return count\n"
  ],
  [
    "a, op, b = map(int, input().split())\nif op == \"+\":\n    print(a+b)\nelse:\n    print(a-b)"
  ],
  [
    "a, b, c = map(int, input().split())\nif a + b >= c:\n  result = c + b\nelif a + b < c:\n  result = a + b + b\nprint(result)"
  ],
  [
    "import numpy as np\nN,M=list(map(int,input().split()))\nn=10**5\nprime=[i for i in range(n)]\nprime[1]=0\nfor i in range(2,n):\n    tmp =i*i\n    if prime[tmp]==0 or tmp > n:\n        break\n    while tmp<n:\n        prime[tmp]=0\n        tmp+=i\nprime=np.array(prime)\nprime=prime[prime!=0]\ndic={}\nfor x in prime:\n    while M%x==0:\n        if dic.get(x,0)==0:\n            dic[x]=1\n        else:\n            dic[x]+=1\n        M/=x\n    if M==1:\n        break\nans = 1\nfor x in dic.values():\n    arr1=[]\n    arr2=[]\n    for i in range(x,0,-1):\n        arr1.append(i+N-1)\n        arr2.append(i)\n    for i,y in enumerate(arr1):\n        for j,z in enumerate(arr2):\n            if arr1[i]%arr2[j]==0:\n                arr1[i]/=arr2[j]\n                arr2[j]=1.0\n    for y in arr1:\n        ans*=y\n        ans%=10**9+7\nprint(int(ans))"
  ],
  [
    "s = input()\nchars = set(s)\nif len(chars) == 2 and s.count(s[0]) == 2 and s.count(s[1]) == 2:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
  ],
  [
    "A, B, C, D = map(int, input().split())\nwhile A > 0 and C > 0:\n    C -= B\n    if C <= 0:\n        break\n    A -= D\nprint('Yes' if A > 0 else 'No')\n"
  ],
  [
    "def solve(n, k):\n    if k == 0:\n        return -1\n    if k > n * (n - 1) // 2:\n        return -1\n    if n == 2 and k == 1:\n        return -1\n    if n == 3 and k == 3:\n        return -1\n    if n == 4 and k == 6:\n        return -1\n    if n == 5 and k == 10:\n        return -1\n    if n == 6 and k == 15:\n        return -1\n    if n == 7 and k == 21:\n        return -1\n    if n == 8 and k == 28:\n        return -1\n    if n == 9 and k == 36:\n        return -1\n    if n == 10 and k == 45:\n        return -1\n    if n == 11 and k == 55:\n        return -1\n    if n == 12 and k == 66:\n        return -1\n    if n == 13 and k == 78:\n        return -1\n    if n == 14 and k == 91:\n        return -1\n    if n == 15 and k == 105:\n        return -1\n    if n == 16 and k == 120:\n        return -1\n    if n == 17 and k == 136:\n        return -1\n    if n == 18 and k == 153:\n        return -1\n    if n == 19 and k == 171:\n        return -1\n    if n == 20 and k == 190:\n        return -1\n    if n == 21 and k == 210:\n        return -1\n    if n == 22 and k == 231:\n        return -1\n    if n == 23 and k == 253:\n        return -1\n    if n == 24 and k == 276:\n        return -1\n    if n == 25 and k == 300:\n        return -1\n    if n == 26 and k == 325:\n        return -1\n    if n == 27 and k == 351:\n        return -1\n    if n == 28 and k == 378:\n        return -1\n    if n == 29 and k == 406:\n        return -1\n    if n == 30 and k == 435:\n        return -1\n    if n == 31 and k == 465:\n        return -1\n    if n == 32 and k == 496:\n        return -1\n    if n == 33 and k == 528:\n        return -1\n    if n == 34 and k == 561:\n        return -1\n    if n == 35 and k == 595:\n        return -1\n    if n == 36 and k == 630:\n        return -1\n    if n == 37 and k == 666:\n        return -1\n    if n == 38 and k == 703:\n        return -1\n    if n == 39 and k == 741:\n        return -1\n    if n == 40 and k == 780:\n        return -1\n    if n == 41 and k == 820:\n        return -1\n    if n == 42 and k == 861:\n        return -1\n    if n == 43 and k == 903:\n        return -1\n    if n == 44 and k == 946:\n        return -1\n    if n == 45 and k == 990:\n        return -1\n    if n == 46 and k == 1035:\n        return -1\n    if n == 47 and k == 1081:\n        return -1\n    if n == 48 and k == 1128:\n        return -1\n    if n == 49 and k == 1176:\n        return -1\n    if n == 50 and k == 1225:\n        return -1\n    if n == 51 and k == 1275:\n        return -1\n    if n == 52 and k == 1326:\n        return -1\n    if n == 53 and k == 1378:\n        return -1\n    if n == 54 and k == 1431:\n        return -1\n    if n == 55 and k == 1485:\n        return -1\n    if n == 56 and k == 1540:\n        return -1\n    if n == 57 and k == 1596:\n        return -1\n    if n == 58 and k == 1653:\n        return -1\n    if n == 59 and k == 1711:\n        return -1\n    if n == 60 and k == 1770:\n        return -1\n    if n == 61 and k == 1830:\n        return -1\n    if n == 62 and k == 1891:\n        return -1\n    if n == 63 and k == 1953:\n        return -1\n    if n == 64 and k == 2016:\n        return -1\n    if n == 65 and k == 2080:\n        return -1\n    if n == 66 and k == 2145:\n        return -1\n    if n == 67 and k == 2211:\n        return -1\n    if n == 68 and k == 2278:\n        return -1\n    if n == 69 and k == 2346:\n        return -1\n    if n == 70 and k == 2415:\n        return -1\n    if n == 71 and k == 2485:\n        return -1\n    if n == 72 and k == 2556:\n        return -1\n    if n == 73 and k == 2628:\n        return -1\n    if n == 74 and k == 2701:\n        return -1\n    if n == 75 and k == 2775:\n        return -1\n    if n == 76 and k == 2850:\n        return -1\n    if n == 77 and k == 2926:\n        return -1\n    if n == 78 and k == 3003:\n        return -1\n    if n == 79 and k == 3081:\n        return -1\n    if n == 80 and k == 3160:\n        return -1\n    if n == 81 and k == 3240:\n        return -1\n    if n == 82 and k == 3321:\n        return -1\n    if n == 83 and k == 3403:\n        return -1\n    if n == 84 and k == 3486:\n        return -1\n    if n == 85 and k == 3570:\n        return -1\n    if n == 86 and k == 3655:\n        return -1\n    if n == 87 and k == 3741:\n        return -1\n    if n == 88 and k == 3828:\n        return -1\n    if n == 89 and k == 3916:\n        return -1\n    if n == 90 and k == 4005:\n        return -1\n    if n == 91 and k == 4095:\n        return -1\n    if n == 92 and k == 4186:\n        return -1\n    if n == 93 and k == 4278:\n        return -1\n    if n == 94 and k == 4371:\n        return -1\n    if n == 95 and k == 4465:\n        return -1\n    if n == 96 and k == 4560:\n        return -1\n    if n == 97 and k == 4656:\n        return -1\n    if n == 98 and k == 4753:\n        return -1\n    if n == 99 and k == 4851:\n        return -1\n    if n == 100 and k == 4950:\n        return -1\n    m = n - 1\n    edges = []\n    for i in range(1, n):\n        edges.append([i, i + 1])\n    k -= n - 1\n    if k > 0:\n        edges.append([1, n])\n        k -= 1\n    while k > 0:\n        for i in range(1, n - 1):\n            if k == 0:\n                break\n            edges.append([i, i + 2])\n            k -= 1\n    m = len(edges)\n    print(m)\n    for u, v in edges:\n        print(u, v)\n"
  ],
  [
    "IN = input().split()\nN = int(IN[0])\nX = int(IN[1])\nBP = 'P'\nfor i in range(N):\n    BP = 'B' + BP + 'P' + BP + 'B'\n    if len(BP) >= X:\n        break\nBP = BP[-X:]\nprint(BP.count(\"P\"))"
  ],
  [
    "import math\ns = input().rstrip()\nalpha = set()\nfor i in range(len(s)):\n  alpha.add(s[i])\nif len(alpha) == len(s):\n  print(math.ceil(len(s)//2))\nelif len(alpha) == 1:\n  print(0)\nelse:\n  freq = 1\n  for j in range(1,len(s)-1):\n    if freq < s.count(s[j]):\n      freq = s.count(s[j])\n  targets = set()\n  for z in range(1,len(s)-1):\n    if s.count(s[z]) == freq:\n      targets.add(s[z])\n  mincount = 10**12\n  for X in targets:\n    tmp = list(s)\n    count = 0\n    while len(set(tmp)) > 1:\n      count += 1\n      work = []\n      for k in range(len(tmp)-1):\n        if tmp[k] == X or tmp[k+1] == X:\n          work.append(X)\n        else:\n          work.append(tmp[k])\n      tmp = work\n    mincount = min(count,mincount)    \n  print(mincount)"
  ],
  [
    "S = input()\ncount = 0\nmaxCount = 0\nflag = False\nfor i in list(S):\n  if i == \"A\" and flag == False:\n    flag = True\n    count+=1\n  elif i == \"Z\" and flag:\n    count +=1 \n    flag = False\n    maxCount = max(maxCount, count)\n    count = 0\n  elif flag :\n    count +=1\n  else :\n    None\nprint(maxCount)"
  ],
  [
    "def add(j):\n    for i in range(g):\n        now[i] += c[i][j]\n    for i in range(g):\n        if now[i] > k:\n            return False\n    return True\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\nsys.setrecursionlimit(100000)\nf_inf = float('inf')\nc = [[0] * 10 for _ in range(1005)]\nh, w, k = map(int, input().split())\nS = [[int(i) for i in input()] for _ in range(h)]\nans = f_inf\nfor div in range(1<<(h-1)):\n    g = 0 \n    id = [0] * h\n    for i in range(h):\n        id[i] = g\n        if (div>>i) & 1:\n            g += 1\n    g += 1\n    for i in range(g):\n        for j in range(w):\n            c[i][j] = 0\n    for i in range(h):\n        for j in range(w):\n            c[id[i]][j] += S[i][j]\n    ok = True\n    for i in range(g):\n        for j in range(w):\n            if c[i][j] > k:\n                ok = False\n                break\n        if not ok:\n            break\n    if not ok:\n        continue\n    num = g - 1\n    now = [0] * g\n    for j in range(w):\n        if not add(j):\n            num += 1\n            now = [0] * g\n            add(j)\n    ans = min(ans, num)\nprint(ans)"
  ],
  [
    "def main():\n    s = input()\n    d = {}\n    poyo = ''\n    cnt = 0\n    c = ''\n    for i in s:\n        d[i] = 0\n    for i in s:\n        d[i] += 1\n    for i in s:\n        cnt = max(cnt, d[i])\n    for i in s:\n        if d[i] == cnt:\n            poyo += i\n    if cnt == 1:\n        c = s[int(len(s) / 2)]\n    else:\n        for i in s[int((len(s) + cnt - 1) / cnt):]:\n            if i in poyo:\n                c = i\n                break\n    r = 0\n    while True:\n        if len({i for i in s}) == 1:\n            break\n        else:\n            for i, e in enumerate(s):\n                if e == c and i > 0:\n                    t = list(s)\n                    t[i-1] = c\n                    s = \"\".join(t)\n            s = s[:len(s)-1]\n            r += 1\n        if r == 100:\n            break\n    print(r)\nif __name__ == '__main__':\n    main()"
  ],
  [
    "n = input()\nprint(\"Yes\" if n == n[::-1] else \"No\")"
  ],
  [
    "n = int(input())\na = list(map(int, input().split()))\nans = 0\nfor i in range(n):\n  ans += abs(a[i] - (i + 1))\nprint(ans)\n"
  ],
  [
    "import math\nx1,y1,x2,y2=map(int,input().split())\nbase = math.sqrt((x1-x2)**2+(y1-y2)**2)\nresult1=[]\nresult2=[]\nflag=0\nfor x3 in range(-200,201):\n    if flag==1:break\n    for y3 in range(-200,201):\n        base_2=math.sqrt((x3-x2)**2+(y3-y2)**2)\n        base_1=math.sqrt((x3-x1)**2+(y3-y1)**2)\n        if base_2==base and base_1==math.sqrt(2)*base:\n            result1.append(x3)\n            result1.append(y3)\n            flag=1\n            break\nx3,y3=map(int,[k for k in result1])\np,q=(x1+x3)/2,(y1+y3)/2\nx4=2*p-x2\ny4=2*q-y2\nprint(x3,y3,x4,y4)"
  ],
  [
    "def solve(M, K):\n    if (K >> M) == 1:\n        return [-1]\n    a = []\n    for i in range(2 ** M):\n        a.append(i)\n        a.append(i ^ K)\n    return a\nM = int(input())\nK = int(input())\na = solve(M, K)\nif a == [-1]:\n    print(\"No solution\")\nelse:\n    for i in range(len(a)):\n        print(a[i], end=\" \")\n"
  ],
  [
    "S = input()\nT = input()\ncorrect_forecasts = 0\nfor i in range(3):\n    if S[i] == T[i]:\n        correct_forecasts += 1\nprint(correct_forecasts)\n"
  ],
  [
    "if A == B:\n  print(C)\nelif A == C:\n  print(B)\nelse:\n  print(A)\n"
  ],
  [
    "N, X, M = map(int, input().split())\nsum = 0\nA = X\nfor i in range(N):\n  sum += A\n  A = (A**2) % M\nprint(sum)\n"
  ],
  [
    "x1, y1, x2, y2 = map(int, input().split())\ndx = x2 - x1\ndy = y1 - y2\nx3 = x2 - dy\ny3 = y2 - dx\nx4 = x1 - dy\ny4 = y1 - dx\nprint(x3, y3, x4, y4)\n"
  ],
  [
    "N = int(input())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nattack = 0\nfor i in range(N):\n  if i!= (N-1):\n    if A[i] > B[i]:\n      A[i] -= B[i]\n      attack += B[i]\n    else:\n      attack += A[i]\n      B[i] -= A[i]\n      A[i] = 0\n      if B[i] > A[i+1]:\n        attack += A[i+1]\n        A[i+1] = 0\n      else:\n        attack += B[i]\n        A[i+1] -= B[i]\n  else:\n    if A[i] > B[i]:\n      A[i] -= B[i]\n      attack += B[i]\n    else:\n      attack += A[i]\n      B[i] -= A[i]\n      A[i] = 0\n      if B[i] > A[i+1]:\n        attack += A[i+1]\n        A[i+1] = 0\n      else:\n        attack += B[i]\n        A[i+1] -= B[i]\nprint(attack)"
  ],
  [
    "N = int(input())\nA_arr=input().split()\nfor i in range(N):\n    A_arr[i] = int(A_arr[i])\nA_arr.sort(reverse=True)\n_A_arr = [A_arr[i] for i in range(N)]\ndef gcd(a,b):\n    if b==0:return a\n    return gcd(b,a%b)\ndef gcd_l(x):\n    max_element = 1\n    if len(x)==1:\n        return x[0]\n    elif len(x) == 2:\n        return max(x[0], x[1])\n    else:\n        element_1 = gcd(x[0], x[1])\n        element_2 = gcd(x[len(x) - 3], x[len(x)-1])\n        element = max(element_1, element_2)\n        for i in range(2,len(x)):\n            element=gcd(element,x[i])\n            if gcd(element, x[i]) > max_element:\n                max_element = element\n        return max_element\nans = 0\ntimes = 0\nprint(max(_A_arr[0], gcd_l(_A_arr[1:])))"
  ],
  [
    "def get_max_f(numbers):\n    max_f = 0\n    for i in range(1, 10000):\n        f = 0\n        for num in numbers:\n            f += i % num\n        if f > max_f:\n            max_f = f\n    return max_f\n"
  ],
  [
    "def num_digits(n, k):\n    count = 0\n    while n > 0:\n        n //= k\n        count += 1\n    return count\nn, k = map(int, input().split())\nprint(num_digits(n, k))"
  ],
  [
    "n = list(map(int,input().split()))\nx = False\ny = False\nif max(n[0],n[1]) < 0:\n    x = True\nif max(n[2],n[3]) < 0:\n    y = True\nif x and y:\n    ans = n[0] * n[2]\nelif x:\n    ans = n[0] * n[3]\nelif y:\n    ans = n[1] * n[2]\nelse:\n    ans = n[1] * n[3]\nprint(ans)"
  ],
  [
    "def get_max_score(graph):\n    score = 0\n    current_vertex = 1\n    while current_vertex != len(graph):\n        neighbors = graph[current_vertex]\n        max_weight = -1\n        max_neighbor = None\n        for neighbor in neighbors:\n            if neighbor[1] > max_weight:\n                max_weight = neighbor[1]\n                max_neighbor = neighbor[0]\n        current_vertex = max_neighbor\n        score += max_weight\n    return score\n"
  ],
  [
    "  r=q/a\n  print(r)\n  s=r*b\n  print(s)\n  u=t%a\n  print(u)\n  v=u*b\n  print(v)\n  print(s+v)\nA,B,T=input().split()\na=int(A)\nb=int(B)\nt=int(T)\nif t%a==0:\n  p=(t//a)*b\n  print(p)\nelse:\n  q=(t-(t%a))\n  r=q//a\n  s=r*b\n  u=t%a\n  v=b\n  print(s+v)"
  ],
  [
    "MOD = 10**9 + 7\ndef main():\n    N = int(input())\n    dp = [[0] * 4 for _ in range(N + 1)]\n    dp[0][0] = 1\n    for i in range(N):\n        for j in range(4):\n            for k in range(4):\n                if j == 1 and k == 2:\n                    continue\n                dp[i + 1][k] = (dp[i + 1][k] + dp[i][j]) % MOD\n    print(sum(dp[N]) % MOD)\nmain()\n"
  ],
  [
    "from itertools import combinations\ndef min_cuts(H, W, K, grid):\n    def count_ones(subgrid):\n        return sum(row.count('1') for row in subgrid)\n    min_cuts = float('inf')\n    for h_cuts in range(H):\n        for h_cut_positions in combinations(range(1, H), h_cuts):\n            subgrids = []\n            start = 0\n            for pos in h_cut_positions:\n                subgrids.append(grid[start:pos])\n                start = pos\n            subgrids.append(grid[start:])\n            w_cuts = 0\n            for subgrid in subgrids:\n                if count_ones(subgrid) > K:\n                    w_cuts += 1\n                    for w in range(1, len(subgrid[0])):\n                        left = [row[:w] for row in subgrid]\n                        right = [row[w:] for row in subgrid]\n                        if count_ones(left) <= K and count_ones(right) <= K:\n                            subgrid[:] = left + right\n                            break\n            min_cuts = min(min_cuts, h_cuts + w_cuts)\n    return min_cuts\nH, W, K = map(int, input().split())\ngrid = [input() for _ in range(H)]\nprint(min_cuts(H, W, K, grid))\n"
  ],
  [
    "n = int(input())\nxy = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    xy.append((x, y))\nmin_cost = n\nfor i in range(n):\n    for j in range(i + 1, n):\n        p = xy[j][0] - xy[i][0]\n        q = xy[j][1] - xy[i][1]\n        if p == 0 and q == 0:\n            continue\n        cost = 1\n        visited = set([i, j])\n        for k in range(n):\n            if k in visited:\n                continue\n            if (xy[k][0] - p, xy[k][1] - q) in xy:\n                cost += 0\n                visited.add(k)\n            else:\n                cost += 1\n                visited.add(k)\n        min_cost = min(min_cost, cost)\nprint(min_cost)\n"
  ],
  [
    "from sys import stdin\ndi = {}\na = stdin.readline().strip()\nl = len(a)\ndi = {}\nfor i in a:\n    di[i] = di.get(i,0) + 1\ntotal = (l * (l+1)) // 2\nvalid = 0\nfor i in range(l // 2):\n    if a[i]!= a[l-1-i]:\n        valid = 1\n        break\ntotal += valid\nrem = 0\nfor kk in di:\n    key = di[kk]\n    rem += (key * (key+1)) // 2\nprint(total - rem)"
  ],
  [
    "def solve(n, k, r, s, p, t):\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = max(dp[i], dp[i - 1])\n        if i >= k:\n            if t[i - 1] == 'r' and t[i - k - 1] != 'p':\n                dp[i] = max(dp[i], dp[i - k] + p)\n            if t[i - 1] == 'p' and t[i - k - 1] != 's':\n                dp[i] = max(dp[i], dp[i - k] + s)\n            if t[i - 1] == 's' and t[i - k - 1] != 'r':\n                dp[i] = max(dp[i], dp[i - k] + r)\n    return dp[n]\nn, k = map(int, input().split())\nr, s, p = map(int, input().split())\nt = input()\nprint(solve(n, k, r, s, p, t))\n"
  ],
  [
    "n, m = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\nMOD = 10**9 + 7\ntotal_area = 0\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        for k in range(m - 1):\n            for l in range(k + 1, m):\n                total_area += (x[j] - x[i]) * (y[l] - y[k])\n                total_area %= MOD\nprint(total_area)\n"
  ],
  [
    "import sys\ndef solve():\n    H, W, N = map(int, sys.stdin.readline().split())\n    nb = [0] * 10\n    dx = (1, 0, -1, 0, 1, 1, -1, -1)\n    dy = (0, 1, 0, -1, 1, -1, 1, -1)\n    bb = {}\n    for lp in range(N):\n        a, b = map(int, sys.stdin.readline().split())\n        a, b = a-1, b-1\n        if in_field(H, W, a, b):\n            bb[(a, b)] = bb.get((a, b), 0) + 1\n        for i in range(len(dx)):\n            if in_field(H, W, a+dx[i], b+dy[i]):\n                bb[(a+dx[i], b+dy[i])] = bb.get((a+dx[i], b+dy[i]), 0) + 1\n    for cnt in bb.values():\n        nb[cnt] += 1\n    nb[0] = (W-2)*(H-2) - sum(nb)\n    print(*nb, sep='\\n')\ndef in_field(H, W, a, b):\n    return (1 <= a <= H-2) and (1 <= b <= W-2)\nif __name__ == '__main__':\n    solve()"
  ],
  [
    "n = int(input())\ns = input()\ndef z_algo(S):\n    N = len(S)\n    A = [0]*N\n    i = 1; j = 0\n    A[0] = l = len(S)\n    while i < l:\n        while i+j < l and S[j] == S[i+j]:\n            j += 1\n        if not j:\n            i += 1\n            continue\n        A[i] = j\n        k = 1\n        while l-i > k < j - A[k]:\n            A[i+k] = A[k]\n            k += 1\n        i += k; j -= k\n    return A\nma = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if s[i:i + j - i + 1] == s[j:j + j - i + 1]:\n            ma = max(ma, j - i + 1)\nprint(ma)"
  ],
  [
    "import numpy as np\nN = int(input())\ndp = [0] * (N + 1)\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n    if temp!=1:\n        arr.append([temp, 1])\n    if arr==[]:\n        arr.append([n, 1])\n    return arr\nfor i in range(1,N+1):\n    p = factorization(i)\n    for x,y in p:\n        dp[x] += y\nnplist = np.array(dp)\na = nplist[nplist>=2]\nb = nplist[nplist>=4]\nc = nplist[nplist>=14]\nd = nplist[nplist>=24]\ne = nplist[nplist>=74]\nf = len(e)\ng = len(d) * (len(a) - len(d)) + len(d) * (len(d) - 1) // 2\nh = len(c) * (len(b) - len(c)) + len(c) * (len(c) - 1) // 2\nk = len(b) * (len(b) - 1) * (len(a) - len(b)) // 2 + len(b) * (len(b) - 1) * (len(b) - 2) // 6\nprint(f + g + h + k)"
  ],
  [
    "import sys\nimport math\nfrom collections import Counter\nmod = 1000000007\nN = int(sys.stdin.readline().strip())\nfishes = []\nzero = 0\nzero_l = 0\nzero_r = 0\nrest = N\nfor _ in range(N):\n    a, b = map(int, sys.stdin.readline().strip().split())\n    if a == 0 and b == 0:\n        zero += 1\n        rest -= 1\n    elif a == 0:\n        zero_l += 1\n    elif b == 0:\n        zero_r += 1\n    else:\n        gcd = math.gcd(a, b)\n        fishes.append((a // gcd, b // gcd))\ncounter = Counter(fishes)\ncalculated = set()\nans = 1\nfor ((a, b), count) in counter.items():\n    if (a, b) in calculated:\n        continue\n    bad_count = 0\n    for (a_k, b_k) in ((-1, 1), (1, -1)):\n        bad_pair = (b * a_k, a * b_k)\n        if bad_pair in counter:\n            bad_count += counter[bad_pair]\n            calculated.add(bad_pair)\n    if bad_count == 0:\n        ans *= 2**count\n        ans %= mod\n    else:\n        good = 2**count\n        bad = 2**bad_count\n        ans *= good + bad - 1\n        ans %= mod\n    rest -= count + bad_count\nif (1,0) not in counter:\n    counter[(1,0)] = 0\nif (0,1) not in counter:\n    counter[(0,1)] = 0\nif (0,0) not in counter:\n    counter[(0,0)] = 0\nans *= 2**counter[(1, 0)] + 2**counter[(0, 1)] - 1\nans %= mod\nrest -= zero_r + zero_l\nans *= pow(2, rest, mod)\nans = (ans + zero - 1) % mod\nprint(ans)"
  ],
  [
    "n = int(input())\nL = list(map(int,input().split()))\nsum1 = 0\nsum2 = sum(L)\nans = 10**10\nfor i in range(1,n):\n    sum1 += L[i-1]\n    sum2 -= L[i-1]\n    ans = min(ans,abs(sum1 - sum2))\nprint(ans)"
  ],
  [
    "import sys\nS = input()\nT = input()\nchanges = {}\nchanges_reverse = {}\nfor i in range(len(T)):\n    if S[i] != T[i]:\n        if S[i] in changes:\n            if changes[S[i]] != T[i]:\n                print('No')\n                sys.exit(0)\n        if T[i] in changes_reverse:\n            if changes_reverse[T[i]] != S[i]:\n                print('No')\n                sys.exit(0)\n        if (S[i] in changes) or (T[i] in changes_reverse):\n            print('No')\n            sys.exit(0)\n        changes[S[i]] = T[i]\n        changes_reverse[T[i]] = S[i]\nprint('Yes')\n"
  ],
  [
    "import sys\ninput = sys.stdin.readline\nn,m = map(int,input().split())\na = [int(i) for i in input().split()]\nb = []\nc = []\nfor i in range(m):\n  b_i,c_i = map(int,input().split())\n  b.append(b_i)\n  c.append(c_i)\nans = sum(a)\nfor i in range(m):\n  for j in range(b[i]):\n    if len(a) == 0:\n      break\n    a.sort()\n    if c[i] > a[0]:\n      ans += c[i] - a[0]\n      a.pop(0)\n    else:\n      break\nprint(ans)"
  ],
  [
    "a,b = map(int,input().split())\nm = b\nprint(100*(a-b)+pow(2,m)*1900)"
  ],
  [
    "  def count_ways(N, P, A):\n    MOD = 10**9 + 7\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for i in range(N):\n        for j in range(A[i], N + 1):\n            dp[j] += dp[j - A[i]]\n            dp[j] %= MOD\n    return dp[N] if P == 0 else MOD - dp[N] - 1\nN, P = map(int, input().split())\nA = list(map(int, input().split()))\nprint(count_ways(N, P, A))"
  ],
  [
    "  def gcd_sum(n, k):\n    MOD = 10**9 + 7\n    result = 0\n    for i in range(1, k+1):\n        result += (n-1) * (k-1) // (i-1)\n    return result % MOD\ndef main():\n    n, k = map(int, input().split())\n    print(gcd_sum(n, k))\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "import math\ndef combination(n, k):\n    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\nN, K = map(int, input().split())\nmod = 10**9 + 7\nfor i in range(1, K + 1):\n    print((combination(N - K + 1, i) * combination(K - 1, i - 1)) % mod)"
  ],
  [
    "s = input()\nif len(s) <= 2:\n  print(s)\nelse :\n  print(s[::-1])"
  ],
  [
    "import sys\nfrom collections import defaultdict\ndef main():\n  N, M = map(int, sys.stdin.readline().split())\n  keys = []\n  for _ in range(M):\n    a, b = map(int, sys.stdin.readline().split())\n    c = list(map(int, sys.stdin.readline().split()))\n    keys.append((a, b, c))\n  box_keys = defaultdict(list)\n  for a, b, c in keys:\n    for box in c:\n      box_keys[box].append((a, b, c))\n  min_cost = float('inf')\n  def backtrack(current_box, used_keys, current_cost):\n    nonlocal min_cost\n    if current_box == N + 1:\n      min_cost = min(min_cost, current_cost)\n      return\n    if current_cost >= min_cost:\n      return\n    for key in box_keys[current_box]:\n      a, b, c = key\n      if key not in used_keys:\n        used_keys.append(key)\n        for next_box in range(current_box + 1, current_box + b + 1):\n          backtrack(next_box, used_keys, current_cost + a)\n        used_keys.pop()\n  backtrack(1, [], 0)\n  if min_cost != float('inf'):\n    print(min_cost)\n  else:\n    print(-1)\nif __name__ == \"__main__\":\n  main()\n"
  ],
  [
    "N, M = map(int, input().split())\nKA = [list(map(int, input().split())) for _ in range(N)]\ntmp = [0] * (M + 1)\nfor i in range(N):\n    for j in range(1, KA[i][0] + 1):\n        tmp[KA[i][j]] += 1\nans = 0\nfor i in range(M + 1):\n    if tmp[i] == N:\n        ans += 1\nprint(ans)"
  ],
  [
    "import collections\nn = int(input())\na = list(map(int, input().split()))\ncounter = collections.Counter(a)\nmax_freq = max(counter.values())\nans = n - 2 * (max_freq - 1)\nprint(ans)\n"
  ],
  [
    "A, op, B = input().split()\nA = int(A)\nB = int(B)\nif op == \"+\":\n  print(A + B)\nelse:\n  print(A - B)"
  ],
  [
    "s = input()\nflag = True\nif 'C' not in s or 'F' not in s:\n  flag = False\nprint('Yes' if 'C' in s and 'F' in s and s.index('C') < s.rindex('F') else 'No')"
  ],
  [
    "s = input().split()\nprint(s[0].upper()+s[1].upper()+s[2].upper())"
  ],
  [
    "h, w, k = map(int, input().split())\ns = [list(map(int, list(input()))) for _ in range(h)]\nresult = []\nfor i in range(2**(h-1)):\n    checker, num = 0, i\n    while num > 0:\n        checker += num%2\n        num >>= 1\n    checker = format(i, \"0\"+str(h)+\"b\").count(\"1\")\n    x = 0\n    c = [0 for _ in range(checker+1)]\n    for j in range(w):\n        num = i\n        p = 0\n        nex = [0 for _ in range(checker+1)]\n        for m in range(h):\n            nex[p] += s[m][j]\n            p += num%2\n            num = num >> 1\n        if all(nex[m]+c[m] <= k for m in range(checker+1)):\n            c = [c[I]+nex[I] for I in range(checker+1)]\n        else:\n            x += 1\n            c = nex\n    result.append(checker+x)\nprint(min(result))"
  ],
  [
    "  n = int(input())\nprint(str(n).translate(str.maketrans(\"19\", \"91\")))"
  ],
  [
    "def find_cycle_length(n, k, a):\n    visited = [False] * n\n    cycle_length = 0\n    current_town = 0\n    while k > 0:\n        if visited[current_town]:\n            break\n        visited[current_town] = True\n        current_town = a[current_town] - 1\n        cycle_length += 1\n        k -= 1\n    if k == 0:\n        return current_town + 1\n    cycle_start = current_town\n    cycle_length = 0\n    while True:\n        current_town = a[current_town] - 1\n        cycle_length += 1\n        if current_town == cycle_start:\n            break\n    k %= cycle_length\n    while k > 0:\n        current_town = a[current_town] - 1\n        k -= 1\n    return current_town + 1\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nresult = find_cycle_length(n, k, a)\nprint(result)\n"
  ],
  [
    "from queue import Queue\ns = input().split(' ')\nN = int(s[0])\nM = int(s[1])\nroom_from = []\nroom_to = []\nfor i in range(M):\n  s = input().split(' ')\n  room_from.append(int(s[0]))\n  room_to.append(int(s[1]))\n  room_from.append(int(s[1]))\n  room_to.append(int(s[0]))\nanswer = {}\ntodo = {}\ntemp = {}\ntodoq = Queue(N)\nfor (i, room) in enumerate(room_to):\n  if room_to[i] == 1:\n    todo[room_from[i]] = 1\nanswer.update(todo)\nwhile True:\n  for a in todo:\n    for (i, room) in enumerate(room_to):\n      if room == a and room_from[i] not in temp and room_from[i] not in answer and room_from[i] != 1:\n        temp[room_from[i]] = a\n  if len(temp) == 0:\n    break\n  else:\n    todo.clear()\n    todo.update(temp)\n    answer.update(temp)\n    temp.clear()\nprint(answer)\nif len(answer) == N - 1:\n  print(\"Yes\")\n  for n in answer:\n    print(answer[n])\nelse:\n  print(\"No\")"
  ],
  [
    "a1,a2,a3=map(int, input().split())\nif a1+a2+a3 >= 22:\n  print(\"bust\")\nelse:\n  print(\"win\")"
  ],
  [
    "n = int(input())\ngroups_of_three = n // 3\nremaining_students = n % 3\nif remaining_students == 1:\n    groups_of_three -= 1\nelif remaining_students == 2:\n    groups_of_three += 1\nprint(groups_of_three)\n"
  ],
  [
    "s=input()\na=s.index(\"A\")\nb=s.rfind(\"Z\")\nprint(b-a+1)"
  ],
  [
    "import sys\ndef input():\n    return sys.stdin.readline()\nn,m=map(int,input().split())\na=[0]*m\nb=[0]*m\nc=[0]*(n+1)\nfor i in range(m):\n    a[i],b[i]=map(int,input().split())\n    if a[i]==1:\n        c[b[i]]=1\nans='IMPOSSIBLE'\nfor i in range(m):\n    if b[i]==n:\n        if c[a[i]]==1:\n            ans='POSSIBLE'\nprint(ans)"
  ],
  [
    "import bisect\nn = int(input())\nA = sorted(map(int, input().split()))\nB = sorted(map(int, input().split()))\nC = sorted(map(int, input().split()))\nans = 0\nfor i in range(n):\n    b = bisect.bisect_right(B, C[i])\n    a = bisect.bisect_right(A, B[b-1])\n    ans += a * (len(B) - b)\nprint(ans)"
  ],
  [
    "n, m, x = map(int, input().split())\na = []\nfor i in range(n):\n    c = list(map(int, input().split()))\n    a.append(c)\nans = float('inf')\nfor i in range(2 ** n):\n    b = [0]*m\n    price = 0\n    for j in range(n):\n        if((i >> j) & 1):\n            for k in range(m):\n                b[k] += a[j][k + 1]\n            price += a[j][0]\n    if all(l >= x for l in b):\n        ans = min(ans, price)\nif  ans == float('inf'):\n    print(\"-1\")\nelse:\n    print(ans)"
  ],
  [
    "N, K = map(int, input().split())\nA = input().split()\nA = [int(a) for a in A]\nS = []\na = 1\nnumber = 0\nfor _ in range(N + 1):\n    b = A[a - 1]\n    if b in S:\n        c = S.index(b)\n        break\n    number += 1\n    S.append(b)\n    a = b\nT = S[c:number]\nif K <= N:\n    print(S[K - 1])\nelse:\n    z = K - c - 1\n    y = z % (number - c)\n    print(T[y])"
  ],
  [
    "n,m = map(int,input().split())\nVLIST = list([] for i in range(n*3))\nfor i in range(m):\n  v1,v2 = map(int,input().split())\n  v1_0 = (v1-1)*3\n  v1_1 = (v1-1)*3 + 1\n  v1_2 = (v1-1)*3 + 2\n  v2_0 = (v2-1)*3\n  v2_1 = (v2-1)*3 + 1\n  v2_2 = (v2-1)*3 + 2\n  VLIST[v1_0].append(v2_1)\n  VLIST[v1_1].append(v2_2)\n  VLIST[v1_2].append(v2_0)\ns,t = map(int,input().split())\ns0 = (s-1)*3\nt0 = (t-1)*3\nq = []\nq.extend(VLIST[s0])\nd = 0\nchk = [0]*len(VLIST)\ndp = [0]*len(VLIST)\ndp[s0] = 0\nwhile len(q)>0:\n  i = q.pop(0)\n  d = dp[i]\n  if chk[i]==1:\n    continue\n  if i==t0:\n    print(int(d//3 + 1))\n    exit()\n  q.extend(VLIST[i])\n  for j in VLIST[i]:\n    dp[j] = d+1\n  chk[i] = 1\nprint(-1)"
  ],
  [
    "def get_min_cost(balls):\n    min_cost = 0\n    balls.sort(key=lambda x: x[0])\n    for i in range(len(balls)):\n        ball = balls[i]\n        x, y = ball\n        if i == 0:\n            prev_ball = None\n        else:\n            prev_ball = balls[i - 1]\n            prev_x, prev_y = prev_ball\n            dist = abs(x - prev_x) + abs(y - prev_y)\n            min_cost = max(min_cost, dist)\n    return min_cost\n"
  ],
  [
    "s = raw_input()\nc = s.find('C')\nif c <= len(s):\n    f = s[c:].find('F')\n    if f > 1:\n        print 'Yes'\n    else:\n        print 'No'\nelse:\n    print 'No'"
  ],
  [
    "N, T = map(int, input().split())\nroutes = [list(map(int, input().split())) for _ in range(N)]\nmin_cost = float('inf')\nfor cost, time in routes:\n    if time <= T:\n        min_cost = min(min_cost, cost)\nif min_cost == float('inf'):\n    print('TLE')\nelse:\n    print(min_cost)\n"
  ],
  [
    "a,b,c = map(int,input().split())\nif b-a == c-b:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
  ],
  [
    "DPD_in = list(input())\nnumber_of_q = 0\nDPDsisu_list = []\nmax_DPDsisu_index = 0\nlen_DPD_in = len(DPD_in)\nfor i in range(len_DPD_in):\n    if DPD_in[i] == '?':\n        number_of_q += 1\nnum_of_DPDs = 2**number_of_q\nDPDs_list = [[''] * len_DPD_in for i in range(num_of_DPDs)]\nfor i in range(len_DPD_in):\n    if DPD_in[i] != '?':\n        for k in range(num_of_DPDs):\n            DPDs_list[k][i] = DPD_in[i]\n    else:\n        for k in range(num_of_DPDs):\n            if k % 2 == 0:\n                DPDs_list[k][i] = 'P'\n            else:\n                DPDs_list[k][i] = 'D'\nfor j in range(num_of_DPDs):\n    DPDsisu = 0\n    for i in range(len_DPD_in-1):\n        if (DPDs_list[j][i] == 'P') and (DPDs_list[j][i+1] == 'D'):\n            DPDsisu += 1\n        elif DPDs_list[j][i+1] == 'D':\n            DPDsisu += 1\n    DPDsisu_list.append(DPDsisu)\nfor i in range(num_of_DPDs):\n    if DPDsisu_list[i] > DPDsisu_list[max_DPDsisu_index]:\n        max_DPDsisu_index = i\nprint(''.join(DPDs_list[max_DPDsisu_index]))"
  ],
  [
    "A, B, C = map(int, input().split())\nif (A == 5 and B == 7 and C == 5) or (A == 7 and B == 5 and C == 5) or (A == 5 and B == 5 and C == 7):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n"
  ],
  [
    "def main():\n    l = {}\n    lR = {}\n    l = input()\n    lR = l[::-1]\n    givenLen = len(l)\n    if l == lR:\n        return 0\n    temp = {}\n    temp[0] = 0\n    for i, e in enumerate(l):\n        temp[i+1] = e\n    l = dict(temp)\n    temp = {}\n    temp[0] = 0\n    for i, e in enumerate(lR):\n        temp[i+1] = e\n    lR = dict(temp)\n    LCStable = [[0 for _ in range(givenLen+1)]]*(givenLen+1)\n    for i in l:\n        for j in lR:\n            if i == 0 or j == 0:\n                LCStable[i][j] = 0\n            elif l[i] == lR[j]:\n                LCStable[i][j] = LCStable[i-1][j-1]+1\n            else:\n                LCStable[i][j] = max(LCStable[i][j-1], LCStable[i-1][j])\n    return givenLen-LCStable[-1][-1]\nprint(main())"
  ],
  [
    "s = input()\nif len(s) == 2:\n    print(s)\nelse:\n    print(s[::-1])"
  ],
  [
    "a = input()\nb = [i for i in a]\nif b[0] == \"?\":\n    b[0] = \"D\"\nfor i in range(1, len(t) - 1):\n    if b[i] == \"?\":\n        if b[i-1] == \"D\" and b[i+1] == \"D\":\n            b[i] = \"P\"\n        elif b[i-1] == \"D\" and b[i+1] == \"?\":\n            b[i] = \"P\"\n        else:\n            b[i] = \"D\"\nif b[-1] == \"?\":\n    b[-1] = \"D\"\nprint(\"\".join(b))"
  ],
  [
    "from collections import defaultdict, deque\nINF = float('inf')\nN, M = map(int, input().split())\nd_from = defaultdict(list)\nd_to = defaultdict(list)\nfor _ in range(M):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    d_from[x].append(y)\n    d_to[y].append(x)\ndp = [-INF] * N\nfor i in range(N):\n    if d_from[i] == []:\n        dp[i] = 0\n        que = deque([])\n        while d_to[i]:\n            j = d_to[i].pop()\n            dp[j] = max(dp[i] + 1, dp[j])\n            que.append(j)\n        while que:\n            j = que.pop()\n            while d_to[j]:\n                k = d_to[j].pop()\n                dp[k] = max(dp[j] + 1, dp[k])\n                que.append(k)\nprint(max(dp))"
  ],
  [
    "H, W = map(int, input().split())\nimg = [input() for _ in range(H)]\nextended_img = []\nfor i in range(2*H):\n    if i % 2 == 0:\n        extended_img.append(img[i//2])\n    else:\n        extended_img.append(\"\".join(c for c in img[i//2] if c == \".\"))\nprint(\"\\n\".join(extended_img))\n"
  ],
  [
    "from collections import deque\nimport sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\ndef solve():\n  h,w,d  = (int(i) for i in input().split())\n  a = []\n  for i in range(h):\n    tmp = list(int(i) for i in input().split())\n    a.append(tmp)\n  query = [False]*(h*w)\n  distance = [0]*(h*w+1)\n  for i in range(h):\n    for j in range(w):\n      number = a[i][j] - 1\n      query[number] = (i,j)\n  q = int(input())\n  for i in range(d,h*w):\n    leftx,lefty = query[i-d]\n    rightx,righty = query[i]\n    distance[i] = distance[i-d]+abs(rightx-leftx)+abs(righty-lefty)\n  for i in range(q):\n    l,r = (int(m) for m in input().split())\n    print(distance[r-1]-distance[l-1])\nsolve()"
  ],
  [
    "S = input()\nK = int(input())\ndef transform(S):\n    T = \"\"\n    for c in S:\n        T += c * int(c)\n    return T\nfor _ in range(5 * 10**15):\n    S = transform(S)\nprint(S[K - 1])\nS = input()\nK = int(input())\nlargest_digit = max(map(int, S))\ndays = 0\nwhile True:\n    length = sum(int(c) * (largest_digit ** days) for c in S)\n    if length >= K:\n        break\n    days += 1\nfor _ in range(days):\n    S = transform(S)\nprint(S[K - 1])\n"
  ],
  [
    "N = int(input())\nif N < 1000:\n    print(\"ABC\")\nelse:\n    print(\"ABD\")\n"
  ],
  [
    "import numpy as np\nN = int(input())\ndp = [0] * (N + 1)\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n    if temp!=1:\n        arr.append([temp, 1])\n    if arr==[]:\n        arr.append([n, 1])\n    return arr\nfor i in range(1,N+1):\n    p = factorization(i)\n    for x,y in p:\n        dp[x] += y\nnplist = np.array(dp)\na = nplist[nplist>=2]\nb = nplist[nplist>=4]\nc = nplist[nplist>=14]\nd = nplist[nplist>=24]\ne = nplist[nplist>=74]\nf = len(e)\ng = len(d) * (len(a) - len(d)) + len(d) * (len(d) - 1) // 2\nh = len(c) * (len(b) - len(c)) + len(c) * (len(c) - 1) // 2\nk = len(b) * (len(b) - 1) * (len(a) - len(b)) // 2 + len(b) * (len(b) - 1) * (len(b) - 2) // 6\nprint(f + g + h + k)"
  ],
  [
    "import sys\nimport numpy as np\nN,S, *A = map(int, sys.stdin.buffer.read().split())\nmod = 998244353\nA = sorted(A)\nanswer = np.zeros(S+1).astype(np.int64) \npower2 = 1\ntotal = 0\nfor a in A:\n  if a>S:\n    break\n  total = min(S,a+total)\n  answer[a+1:total+1] = (2*answer[a+1:total+1]+answer[1:total-a+1])%mod\n  answer[a] = (2*answer[a]+power2)%mod\n  answer[1:a] = (2*answer[1:a])%mod\n  power2 = (2*power2)%mod\nprint(answer[S])"
  ],
  [
    "  def kangaroo_time(X):\n    time = 0\n    position = 0\n    while position != X:\n        time += 1\n        position += time\n    return time"
  ],
  [
    "n, k = map(int, input().split())\nmod = pow(10, 9) + 7\ndef cmb(n, r):\n    res = 1\n    fac = 1\n    for i in range(r):\n        res *= (n-i)\n        res %= mod\n        fac *= (i+1)\n        fac %= mod\n    return res*pow(fac, mod-2, mod) % mod\nif n <= k-1:\n    print(cmb(2*n-1, n))\nelse:\n    answer = 0\n    for m in range(k+1):\n        a = k - m\n        answer += cmb(n, m)*cmb(n-1, a) % mod\nprint(answer % mod)"
  ],
  [
    "  from typing import List\ndef max_ab_occurrences(strings: List[str]) -> int:\n    max_occurrences = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            concatenated_string = strings[i] + strings[j]\n            max_occurrences = max(max_occurrences, concatenated_string.count(\"AB\"))\n    return max_occurrences\ndef main():\n    n = int(input())\n    strings = []\n    for _ in range(n):\n        strings.append(input())\n    print(max_ab_occurrences(strings))\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "Code:\nfrom collections import Counter\ndef min_operations(s, k):\n    n = len(s)\n    counter = Counter(s)\n    max_freq = max(counter.values())\n    if max_freq * 2 <= n * k:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return (k + 1) // 2\n    return k - (k // 2) * (max_freq - (n + 1) // 2)\ns = input()\nk = int(input())\nprint(min_operations(s, k))"
  ],
  [
    "from itertools import combinations\nn, k, c = map(int, input().split())\ns = input()\nwork = range(1, n + 1)\nnot_working = []\nfor i, v in enumerate(s, start=1):\n    if v == \"o\":\n        continue\n    not_working.append(i)\nworking = set(work) - set(not_working)\ndef is_consistent(t):\n    u = t[1:]\n    for i, v in zip(t, u):\n        if v - i <= c:\n            return False\n    return True\nl = list(filter(is_consistent, combinations(working, k)))\nif l:\n    result = set.intersection(*map(set, l))\n    for i in sorted(result):\n        print(i)\nelse:\n    print()"
  ],
  [
    "def is_lunlun(n):\n    s = str(n)\n    for i in range(len(s) - 1):\n        if abs(int(s[i]) - int(s[i + 1])) > 1:\n            return False\n    return True\ndef kth_lunlun(k):\n    count = 0\n    n = 1\n    while count < k:\n        if is_lunlun(n):\n            count += 1\n        n += 1\n    return n - 1\nk = int(input())\nprint(kth_lunlun(k))\n"
  ],
  [
    "h, w, m = map(int, input().split())\nl = [[0 for x in range(w)] for y in range(h)]\nlx = [0 for x in range(h)]\nly = [0 for y in range(w)]\nfor i in range(m):\n    x, y = map(int, input().split())\n    lx[x - 1] += 1\n    ly[y - 1] += 1\n    l[x - 1][y - 1] = 1\nt_x = max(lx)\nt_y = max(ly)\nflg = 0\nfor j in range(h):\n    if lx[j] == t_x:\n        for k in range(w):\n            if ly[k] == t_y:\n                if l[j][k] == 0:\n                    flg = 1\nif flg == 1:\n    print(t_x + t_y)\nelse:\n    print(t_x + t_y - 1)"
  ],
  [
    "n, m, q = map(int, input().split())\nabcd = []\nfor _ in range(q):\n    a, b, c, d = map(int, input().split())\n    abcd.append((a, b, c, d))\nans = 0\np = []\nsys.setrecursionlimit(10**6)\ndef dfs(x):\n    if len(x) == n:\n        p.append(x)\n    else:\n        for i in range(m - x[-1] + 1):\n            dfs(x + [x[-1] + i])\ndfs([1])\nfor x in p:\n    r = 0\n    for i in range(q):\n        if x[abcd[i][1] - 1] - x[abcd[i][0] - 1] == abcd[i][2]:\n            r += abcd[i][3]\n    ans = max(ans, r)\nprint(ans)"
  ],
  [
    "import sys\nIS = lambda: sys.stdin.readline().rstrip()\nII = lambda: int(IS())\nMII = lambda: list(map(int, IS().split()))\nfrom bisect import bisect_left, insort_left\ndef main():\n    n = II()\n    aa = MII()\n    index = [i for i in range(n)]\n    aa = list(zip(index, aa))\n    aa.sort(key=lambda x: x[1], reverse=True)\n    sumv = 0\n    cnt = 0\n    neibs = [-100]\n    u = n//2\n    i = 0\n    while cnt < u:\n        idx = aa[i][0]\n        d = bisect_left(neibs, idx)\n        l = neibs[d-1] if d != 1 else -10\n        r = neibs[d] if len(neibs) != d else neibs[d-1]\n        if l == idx-1 or l == idx+1 or r == idx-1 or r == idx+1:\n            i+=1; continue\n        sumv += aa[i][1]\n        insort_left(neibs, idx)\n        cnt += 1\n        i += 1\n    print(sumv)\nif __name__ == '__main__':\n    main()"
  ],
  [
    "N, A, B = map(int, input().split())\nX = list(map(int, input().split()))\nres = 0\nfor i in range(N - 1):\n  if X[i + 1] - X[i] > B:\n    res += B\n  else:\n    res += X[i + 1] - X[i]\nprint(res)"
  ],
  [
    "MOD = 10**9 + 7\ndef factorial(n):\n    fact = [1]\n    for i in range(1, n+1):\n        fact.append((fact[-1] * i) % MOD)\n    return fact\ndef power(n, p):\n    result = 1\n    while p > 0:\n        if p % 2 == 1:\n            result = (result * n) % MOD\n        n = (n * n) % MOD\n        p //= 2\n    return result\ndef combinations(n, k):\n    fact = factorial(n)\n    return (fact[n] * power(fact[k] * fact[n-k], MOD-2)) % MOD\ndef solve(K, S):\n    N = len(S)\n    result = 0\n    for i in range(K+1):\n        result = (result + combinations(N+i, i) * power(26, K-i)) % MOD\n    return result\nK = int(input())\nS = input()\nprint(solve(K, S))\n"
  ],
  [
    "N = int(input())\nA = int(input())\nif N % 500 <= A:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
  ],
  [
    "B = int(input())\nC = int(input())\nremaining_money = A - B\ndonuts_bought = remaining_money // C\nremaining_money -= donuts_bought * C\nprint(remaining_money)"
  ],
  [
    "A, V = map(int, input().split())\nB, W = map(int, input().split())\nT = int(input())\nif abs(A - B) <= (V - W) * T:\n  print(\"YES\")\nelse:\n  print(\"NO\")\n"
  ],
  [
    "  def solve(A, B):\n    if A == B:\n        return \"IMPOSSIBLE\"\n    if A < B:\n        smaller = A\n        larger = B\n    else:\n        smaller = B\n        larger = A\n    for i in range(smaller, larger+1):\n        if abs(A-i) == abs(B-i):\n            return i\n    return \"IMPOSSIBLE\""
  ],
  [
    "import sys\nimport collections\nimport copy\nimport math\ninput = sys.stdin.readline\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nA_sum = sum(A)\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i!= n // i:\n                divisors.append(n//i)\n    divisors.sort(reverse=True)\n    return divisors\nchk = make_divisors(A_sum)\nflag = 0\nfor i in range(len(chk)):\n    trial = chk[i]\n    count = 0\n    coll = trial\n    count += A[0] % trial\n    mod_list = [A[0] % trial]\n    for j in range(1, N):\n        count += A[j] % trial\n        mod_list.append(A[j] % trial)\n    ans = count // trial\n    mod_list.sort(reverse=True)\n    test = 0\n    for j in range(ans):\n        test += trial - mod_list[j]\n    if test > K:\n        continue\n    else:\n        print(trial)\n        break"
  ],
  [
    "import math\na,b=map(int,input().split())\nans=-1\nfor i in range(1,10000):\n    if math.floor(i*0.08)==a and math.floor(i*0.1)==b:\n        ans=i\n        break\nprint(ans)"
  ],
  [
    "n = int(input())\nl = list(map(int, input().split()))\nla = list(map(int, input().split()))\nflag = 0\nans = 0\nfor m, i in enumerate(la):\n    if i > l[m]:\n        ans += min(i, l[m])\n        l[m + 1] -= min(i, l[m])\n    else:\n        ans += i\n        l[m + 1] -= i\n    if l[m + 1] < 0:\n        flag = 1\n        break\nprint(ans)"
  ],
  [
    "import sys\ndef main():\n    MOD = 10**9 + 7\n    LI = lambda : [int(x) for x in sys.stdin.readline().split()]\n    N,M = LI()\n    S = LI()\n    T = LI()\n    dp = [[0]*(M+1) for _ in range(N+1)]\n    dp[0][0] = 1\n    for i in range(1,N+1):\n        for j in range(1,M+1):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            if S[i-1] == T[j-1]:\n                dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % MOD\n    print(dp[-1][-1])\nif __name__ == '__main__':\n    main()"
  ],
  [
    "n = int(input())\ndist = [list(map(int, input().split())) for _ in range(n)]\ntotal_length = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if dist[i][j] < 0 or dist[i][j]!= dist[j][i]:\n            print(-1)\n            exit()\n        for k in range(n):\n            if dist[i][k] > dist[i][j] + dist[j][k]:\n                print(-1)\n                exit()\n        total_length += dist[i][j]\nprint(total_length)\n"
  ],
  [
    "import sys\ninput = sys.stdin.readline\nN = int(input())\nS = [int(input()) for _ in range(N)]\nt = 0\nfor i in range(1, N - 1):\n    for j in range(i + 1, N):\n        for k in range(j + 1, N + 1):\n            if S[i - 1] != S[j - 1] and S[j - 1] != S[k - 1] and S[k - 1] != S[i - 1] and j - i != k - j:\n                t += 1\nprint(t)"
  ],
  [
    "n = int(input())\ntotal_people = 0\nfor _ in range(n):\n    l, r = map(int, input().split())\n    total_people += r - l + 1\nprint(total_people)\n"
  ],
  [
    "def solve(n, s):\n    left = 0\n    right = 0\n    for i in range(n):\n        if s[i] == '(':\n            left += 1\n        else:\n            right += 1\n    ans = ''\n    for i in range(left):\n        ans += '('\n    for i in range(n):\n        ans += s[i]\n    for i in range(right - left):\n        ans += ')'\n    return ans\nn = int(input())\ns = input()\nprint(solve(n, s))\n"
  ],
  [
    "S = \"ACL\"\nprint(S*int(input()))"
  ],
  [
    "n = int(input())\nanswer = 0\nfor i in range(1, n//2):\n    next = i**2\n    if next <= n:\n        answer = i**2\n    else:\n        break\nprint(answer)"
  ],
  [
    "from decimal import *\nMOD = 1000000007\ndef solve(N, ABs):\n    groups = {}\n    L = 10**18\n    zero_count = 0\n    for a, b in ABs:\n        if a == 0 and b == 0:\n            zero_count += 1\n            continue\n        if b == 0:\n            k = \"INF\"\n        else:\n            k = Decimal(a) / Decimal(b)\n        groups.setdefault(k, 0)\n        groups[k] += 1\n    visited = set()\n    possibles = []\n    for k, v in groups.items():\n        if k in visited:\n            continue\n        p = 0\n        p += pow(2, v, MOD)\n        if k == \"INF\":\n            m = 0\n        elif k == 0:\n            m = \"INF\"\n        else:\n            m = - (Decimal(1) / Decimal(k))\n        if m in groups.keys():\n            p += pow(2, groups[m], MOD)\n            visited.add(m)\n            p -= 1\n        possibles.append(p % MOD)\n    ans = 1\n    for p in possibles:\n        ans *= p\n        ans %= MOD\n    if zero_count:\n        ans += zero_count\n        ans %= MOD\n    return (ans - 1) % MOD\nif __name__ == \"__main__\":\n    N = int(input())\n    ABs = [tuple(map(int, input().split(\" \"))) for _ in range(N)]\n    print(solve(N, ABs))"
  ],
  [
    "s = input()\nflag = True\nif 'C' not in s or 'F' not in s:\n  flag = False\nprint('Yes' if s.index('C') < s.rindex('F') and flag == True else 'No')"
  ],
  [
    "from collections import Counter\ndef inv_mod(n:int, mod:int) -> list:\n    inv = [-1,1]\n    for i in range(2,n+1):\n        inv.append(mod - ((mod//i)*inv[mod%i]) % mod)\n    return inv\ndef fact(n:int, mod:int) -> list:\n    fac = [1,1]\n    res = 1\n    for i in range(2,n+1):\n        res = res*i%mod\n        fac.append(res)\n    return fac\ndef fact_inv(n:int, inv:list, mod:int) -> list:\n    facInv = [1,1]\n    for i in range(2,n+1):\n        facInv.append(facInv[i-1]*inv[i] % mod)\n    return facInv\ndef nCr(n:int, r:int, mod:int, fac:list, facInv:list) -> int:\n    if not (0<=r and r<=n):\n        return 0\n    return ((fac[n]*facInv[r]) % mod) * facInv[n-r] % mod\nN,A,B = map(int, input().split())\nV = list(map(int, input().split()))\nV.sort(reverse=True)\nmxv_avg = sum(V[:A])/A\nprint(mxv_avg)\nMOD = 9999999900000001\ninv = inv_mod(N,MOD)\nfac = fact(N,MOD)\nfacInv = fact_inv(N,inv,MOD)\ncnt = Counter(V)\nans = 0\nif len(cnt) == 1:\n    for i in range(A,B+1):\n        ans += nCr(N,i,MOD,fac,facInv)\n    print(ans)\nelse:\n    cnt_min_choose = V[:B].count(V[A-1])\n    cnt_min_all = V.count(V[A-1])\n    for i in range(cnt_min_choose,cnt_min_all+1):\n        ans += nCr(cnt_min_all, i, MOD,fac,facInv)\n    print(ans)"
  ],
  [
    "import sys\nfrom math import ceil\ndef input():\n    return sys.stdin.readline().strip()\ndef iinput():\n    return int(input())\ndef finput():\n    return float(input())\ndef tinput():\n    return input().split()\ndef rinput():\n    return map(int, tinput())\ndef rlinput():\n    return list(rinput())\ndef nok(a, b):\n    m = a * b\n    while a != 0 and b != 0:\n        if a > b:\n            a %= b\n        else:\n            b %= a\n    return m // (a + b)    \ndef main():\n    mod = 10**9 + 7\n    n, m = rinput()\n    s = rlinput()\n    t = rlinput()\n    a = [1] * (m + 1)\n    for j in s:\n        d = a[:]\n        k = 0\n        for i, v in enumerate(t):\n            d[i] = (k + d[i]) % mod\n            if j == v:\n                k = (k + a[i]) % mod\n        d[-1] = (k + d[-1]) % mod\n        a = d[:]\n    print(a[-1])\nmain()"
  ],
  [
    "A, B, M = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndiscount = []\nfor _ in range(M):\n  x, y, c = map(int, input().split())\n  discount.append([x, y, c])\nmin_price = a[0] + b[0]\nfor i in range(A):\n  for j in range(B):\n    price = a[i] + b[j]\n    for x, y, c in discount:\n      if i + 1 == x and j + 1 == y:\n        price = min(price, a[i] + b[j] - c)\n    min_price = min(min_price, price)\nprint(min_price)\n"
  ],
  [
    "a, b = map(int, input().split())\nprint((a + b) % 24)"
  ],
  [
    "n = int(input())\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\nc = [int(i) for i in input().split()]\nsatisfy = 0\nfor i in range(n):\n    satisfy += b[a[i] - 1]\n    if i < n - 1:\n        satisfy += c[min(a[i], a[i + 1]) - 1]\nprint(satisfy)"
  ],
  [
    "X, A, B = list(map(int, input().split()))\nif A - B >= 0:\n    print('delicious')\nelif abs(A - B) < X:\n    print('safe')\nelse:\n    print('dangerous')"
  ],
  [
    "N = int(input())\nL = list(map(int,input().split()))\ns = sum(L)\np = 0\nfor a in L:\n    p += a*a\nans = (s*s - p) // 2\nprint(ans)"
  ],
  [
    "s=input()\nif a>=3200:\n  print(s)\nelse:\n  print('red')"
  ],
  [
    "  def compute_product(numbers):\n    result = 1\n    for num in numbers:\n        result *= num\n        if result > 10**18:\n            return -1\n    return result\ndef main():\n    n = int(input())\n    numbers = list(map(int, input().split()))\n    print(compute_product(numbers))\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "n, a, b = map(int, input().split())\nans = 0\nfor i in range(n - 1):\n    ans += max(a * (x[i + 1] - x[i]), b)\nprint(ans)"
  ],
  [
    "N = int(input())\nif N == 1:\n    print(0)\nelif N == 2:\n    print(2)\nelse:\n    print((2 * (10 ** (N - 2))) % (10 ** 9 + 7))"
  ],
  [
    "def change(c):\n    if c:\n        return False\n    else:\n        return True\nN, M = map(int, input().split())\ncard = [[True for i in range(M)] for j in range(N)]\nfor i in range(N):\n    for j in range(M):\n        card[i][j] = change(card[i][j])\n        if j - 1 >= 0:\n            card[i][j - 1] = change(card[i][j - 1])\n        if j + 1 < M:\n            card[i][j + 1] = change(card[i][j + 1])\n        if i - 1 >= 0:\n            card[i - 1][j] = change(card[i - 1][j])\n            if j - 1 >= 0:\n                card[i - 1][j - 1] = change(card[i - 1][j - 1])\n            if j + 1 < M:\n                card[i - 1][j + 1] = change(card[i - 1][j + 1])\n        if i + 1 < N:\n            card[i + 1][j] = change(card[i + 1][j])\n            if j - 1 >= 0:\n                card[i + 1][j - 1] = change(card[i + 1][j - 1])\n            if j + 1 < M:\n                card[i + 1][j + 1] = change(card[i + 1][j + 1])\nprint(sum([i.count(False) for i in card]))"
  ],
  [
    "from collections import defaultdict\ndef count_unique_substrings(s):\n    n = len(s)\n    prefix_hash = [0] * (n + 1)\n    power = [1] * (n + 1)\n    mod = 10**9 + 7\n    base = 257\n    for i in range(n):\n        prefix_hash[i + 1] = (prefix_hash[i] + (ord(s[i]) - ord('a') + 1) * power[i]) % mod\n        power[i + 1] = (power[i] * base) % mod\n    unique_substrings = set()\n    for i in range(n):\n        for j in range(i, n):\n            substring_hash = (prefix_hash[j + 1] - prefix_hash[i] + mod) % mod\n            unique_substrings.add(substring_hash)\n    return len(unique_substrings)\ninput_string = input()\nresult = count_unique_substrings(input_string)\nprint(result)"
  ],
  [
    "N = int(input())\nS = input()\nr = []\ng = []\nb = []\nA = 0\nB = 0\nC = 0\nfor i in range(N):\n    if S[i] == \"R\":\n        r.append(i)\n        A += 1\n    elif S[i] == \"G\":\n        g.append(i)\n        B += 1\n    else:\n        b.append(i)\n        C += 1\nk = 0\nfor i in range(N-2):\n    for j in range(i+1, N-1):\n        t = 2*j - i\n        if t < N:\n            if S[i] != S[j] and S[i] != S[t] and S[t] != S[j]:\n                k += 1\n                print(i, j, t)\nprint(k)\nprint(A*B*C - k)"
  ],
  [
    "h,w=map(int,input().split())\na={}\nfor i in range(26):\n  a[chr(i+97)]=0\nfor i in range(h):\n  s=input()\n  for j in s:\n    a[j]+=1\nif h==1 and w==1:print(\"Yes\")\nelif h==1 or w==1:\n  cnt=0\n  for i in a.values():\n    if i%2==1:cnt+=1\n  if cnt!=1:print(\"No\")\n  else:print(\"Yes\")\nelif h%2==0 and w%2==0:\n  for i in a.values():\n    if i%4!=0:print(\"No\");exit()\n  print(\"Yes\")\nelif h%2==1 and w%2==0:\n  cnt=0\n  for i in a.values():\n    if i%4==1 or i%4==3:\n      print(\"No\");exit()\n    if i%4==2:cnt+=1\n  if cnt>w//2:\n    print(\"No\")\n  else:print(\"Yes\")\nelif h%2==0 and w%2==1:\n  cnt=0\n  for i in a.values():\n    if i%4==1 or i%4==3:\n      print(\"No\");exit()\n    if i%4==2:cnt+=1\n  if cnt>h//2:\n    print(\"No\")\n  else:print(\"Yes\")\nelse:\n  cnt3=0;cnt2=0;cnt1=0\n  for i in a.values():\n    if i%4==1:cnt1+=1\n    elif i%4==2:cnt2+=1\n    elif i%4==3:cnt3+=1\n  rem=1-cnt1\n  if cnt1+cnt3!=1:print(\"No\")\n  elif cnt2+cnt3-rem>(h-1)//2+(w-1)//2:print(\"No\")\n  else:\n    print(\"Yes\")"
  ],
  [
    "from collections import defaultdict\ndef solve(n, m, edges):\n    graph = defaultdict(list)\n    for a, b, c in edges:\n        graph[a].append((b, c))\n    dp = [float('-inf')] * (n + 1)\n    dp[1] = 0\n    for i in range(1, n + 1):\n        for j, c in graph[i]:\n            dp[j] = max(dp[j], dp[i] + c)\n    if dp[n] == float('-inf'):\n        return 'inf'\n    return dp[n]\nn, m = map(int, input().split())\nedges = []\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    edges.append((a, b, c))\nprint(solve(n, m, edges))\n"
  ],
  [
    "import numpy as np\nN, M = map(int, input().split())\nres = np.zeros((N + 1, 2), dtype=np.int16)\nfor i in range(M):\n    p, s = input().split()\n    p = int(p)\n    if res[p][0] == 0:\n        if s == 'AC':\n            res[p][0] += 1\n        elif s == 'WA':\n            res[p][1] += 1\nprint(\"%d %d\" % (res[1:, 0].sum(), res[1:, 1].sum()))"
  ],
  [
    "a, b, c = map(int, input().split())\nresult = abcSwap([a, b, c])\nprint(*result)"
  ],
  [
    "import sys\nfrom typing import List\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    MOD = 10**9 + 7\n    N, M, K = map(int, readline().split())\n    def comb(n: int, k: int) -> int:\n        if n < k:\n            return 0\n        return fact[n] * factinv[k] * factinv[n-k] % MOD\n    fact = [1]\n    factinv = [1]\n    inv = [0, 1]\n    for i in range(2, N * M + 1):\n        fact.append(fact[-1] * i % MOD)\n        inv.append((MOD - inv[MOD % i] * (MOD // i)) % MOD)\n        factinv.append(factinv[-1] * inv[-1] % MOD)\n    ans = 0\n    for i in range(1, K + 1):\n        ans += comb(N * M, i) * (2 * i * (N + M - 2) * (N * M - i) % MOD)\n        ans %= MOD\n    write(\"%d\\n\" % ans)\nsolve()\n"
  ],
  [
    "N, K = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\nwhile K > 0 and len(A) > 1:\n    A[0] = (A[0] + A[1]) / 2\n    A.pop(1)\n    K -= 1\n    A.sort()\nprint(int(A[0]))"
  ],
  [
    "number_of_elements = int(input())\ninput_list = list(map(int, input().split()))\nresult_list = []\nfor index in range(number_of_elements):\n    result_list.insert(input_list[index] - 1, index + 1)\nif result_list == list(range(1, number_of_elements + 1)):\n    for element in result_list:\n        print(element)\nelse:\n    print(-1)\n"
  ],
  [
    "from scipy.sparse.csgraph import shortest_path\nfrom scipy.sparse import csr_matrix\ndef get_path(start, goal, pred):\n  return get_path_row(start, goal, pred[start])\ndef get_path_row(start, goal, pred_row):\n  path = []\n  i = goal\n  while i!= start and i >= 0:\n    path.append(i)\n    i = pred_row[i]\n  if i < 0:\n    return []\n  path.append(i)\n  return path[::-1]\nN,M,L = map(int,input().split())\nif M!= 0:\n  G = [[0 for _ in range(N)] for _ in range(N)]\n  for i in range(M):\n    A,B,C = map(int,input().split())\n    A -= 1\n    B -= 1\n    if C <= L:\n      G[A][B] = C\n      G[B][A] = C\n  csr = csr_matrix(G)\n  d, p = shortest_path(csr, return_predecessors=True)\nQ = int(input())\nfor i in range(Q):\n  if M == 0:\n    print(-1)\n  else:\n    s,t = map(int,input().split())\n    s -= 1\n    t -= 1\n    path = get_path(s,t,p)\n    if len(path) == 0:\n      print(-1)\n    else:\n      ans = 0\n      tank = L\n      for j in range(len(path)-1):\n        if tank - G[path[j]][path[j+1]] < 0:\n          ans +=1\n          tank = L\n        tank -= G[path[j]][path[j+1]]\n      print(ans)"
  ],
  [
    "S = input()\nT = input()\nD = []\nfor i in range(len(S) - len(T) + 1):\n    SS = S[i:i+len(T)]\n    dif = 0\n    for j in range(len(T)):\n        if T[j]!= SS[j]:\n            dif += 1\n    D.append(dif)\nprint(min(D))"
  ],
  [
    "n,m,c = map(int,input().split())\nb = [i for i in map(int,input().split())]\na = []\nfor j in range(n):\n    a.append( [i for i in map(int,input().split())] )\nans = [0]*(n)\ncount = 0\nfor i in range(n) :\n    for j in range(m):\n        ans[i] += a[i][j] * b[j]\n    if ans[i] + c > 0 :\n        count += 1 \nprint(count)"
  ],
  [
    "  from itertools import accumulate\ndef solve(N, A, B):\n    A = list(accumulate(A))\n    B = list(accumulate(B))\n    return max(A[-1] - B[-1], B[-1] - A[-1])\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    result = solve(N, A, B)\n    print(result)\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "import sys\nfrom collections import Counter\nfrom math import sqrt\nMOD = 10**9 + 7\ndef factorize(n):\n    factors = []\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            factors.append(i)\n            if i!= n // i:\n                factors.append(n // i)\n    return sorted(factors)\ndef solve(n, m):\n    factors = factorize(m)\n    counter = Counter(factors)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for factor, count in counter.items():\n        for i in range(n, -1, -1):\n            for j in range(1, min(i, count) + 1):\n                dp[i] = (dp[i] + dp[i - j]) % MOD\n    return dp[n]\nn, m = map(int, sys.stdin.readline().split())\nprint(solve(n, m))\n"
  ],
  [
    "s = input().split()\na1 = int(s[0]) * int(s[2])\na2 = int(s[0]) * int(s[3])\na3 = int(s[1]) * int(s[2])\na4 = int(s[1]) * int(s[3])\nlist = (a1, a2, a3, a4)\nprint(max(list))"
  ],
  [
    "n,k = map(int,input().split())\na = list(map(int,input().split()))\nf = list(map(int,input().split()))\na.sort()\nf.sort(reverse = True)\ndef is_ok(t):\n  cost = 0\n  for aa,ff in zip(a,f):\n    temp = t // ff\n    if temp >= aa:\n      continue\n    cost += aa - temp\n  if cost <= k:\n    return True\n  return False\nleft = 0\nright = a[-1]*f[0]\nwhile left < right:\n  mid = (left + right) // 2\n  if is_ok(mid):\n    right = mid\n  else:\n    left = mid + 1\nprint(left)"
  ],
  [
    "import sys\nfrom itertools import product\nn, m, x = map(int, sys.stdin.readline().split())\nc = []\na = []\nfor i in range(n):\n    c.append(int(sys.stdin.readline().split()[0]))\n    a.append(list(map(int, sys.stdin.readline().split()[1:])))\nmin_cost = -1\nfor bits in product([0, 1], repeat=n):\n    cost = 0\n    level = [0] * m\n    for i, bit in enumerate(bits):\n        if bit:\n            cost += c[i]\n            for j in range(m):\n                level[j] += a[i][j]\n    if all(l >= x for l in level):\n        if min_cost == -1 or cost < min_cost:\n            min_cost = cost\nprint(min_cost)"
  ],
  [
    "N = int(input())\nK = int(input())\nx = list(map(int, input().split()))\ndef light_candles(x, K):\n    time = 0\n    for i in range(K):\n        time += abs(x[i] - x[i-1])\n    return time\nprint(light_candles(x, K))\n"
  ],
  [
    "  def find_king_location(n, k, a):\n    current_location = 1\n    for _ in range(k):\n        current_location = a[current_location - 1]\n    return current_location"
  ],
  [
    "S=input().split()\nprint(S[0][0].upper()+S[1][0].upper()+S[2][0].upper())"
  ],
  [
    "N = int(input())\nP = list(map(int,input().split()))\nans = 0\nfor j in range(N):\n    p = P[j]\n    i = j + 1\n    if p == i:\n        if i == 1:\n            ans += 1\n            P[j], P[j+1] = P[j+1], P[j]\n        else:\n            ans += 1\n            P[j-1], P[j] = P[j], P[j-1]\nprint(ans)"
  ],
  [
    "N = int(input())\nA = list(map(int, input().split()))\ndef max_sum(arr):\n    max_ending_here = max_so_far = 0\n    for num in arr:\n        max_ending_here = max(num, max_ending_here + num)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\ndef min_sum(arr):\n    min_ending_here = min_so_far = 0\n    for num in arr:\n        min_ending_here = min(num, min_ending_here + num)\n        min_so_far = min(min_so_far, min_ending_here)\n    return min_so_far\nmax_sum_arr = max_sum(A[::2]) + max_sum(A[1::2])\nmin_sum_arr = min_sum(A[::2]) + min_sum(A[1::2])\nprint(max(max_sum_arr, min_sum_arr))"
  ],
  [
    "def palindromic_number():\n    n = input()\n    n_reversed = ''.join(list(reversed(n)))\n    if n == n_reversed:\n        print('Yes')\n    else:\n        print('No')\nif __name__ == '__main__':\n    palindromic_number()"
  ],
  [
    "N=int(input())\nprint('ABC'+str(N))"
  ],
  [
    "def main():\n    N = int(input())\n    monsters = list(map(int, input().split()))\n    while True:\n        for i in range(1, len(monsters)):\n            monsters[i] = monsters[i] % monsters[0]\n        if 0 in monsters:\n            monsters = list(set(monsters))\n            monsters.remove(0)\n        if len(monsters) == 2:\n            if monsters[1] < monsters[0]:\n                monsters[0] -= monsters[1]\n                continue\n            last = monsters[1] - monsters[0]\n            monsters[0] = last\n            monsters.remove(monsters[1])\n        if len(monsters) == 1:\n            break\n    print(monsters[0])\nmain()"
  ],
  [
    "import heapq\nX, Y, A, B, C = map(int, input().split())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\nr = list(map(int, input().split()))\np.sort(reverse=True)\nq.sort(reverse=True)\nr.sort(reverse=True)\nred_heap = []\ngreen_heap = []\nfor i in range(A):\n  heapq.heappush(red_heap, -p[i])\nfor i in range(B):\n  heapq.heappush(green_heap, -q[i])\nfor i in range(C):\n  if -r[i] >= -red_heap[0] and X < A:  \n    heapq.heappush(red_heap, -r[i])\n    X += 1\n  elif -r[i] >= -green_heap[0] and Y < B:  \n    heapq.heappush(green_heap, -r[i])\n    Y += 1\ntotal_deliciousness = 0\nfor i in range(X):\n  total_deliciousness -= heapq.heappop(red_heap)\nfor i in range(Y):\n  total_deliciousness -= heapq.heappop(green_heap)\nprint(total_deliciousness)\n"
  ],
  [
    "def min_swaps(arr):\n    n = len(arr)\n    ans = 0\n    temp = [0] * (n + 1)\n    for i in range(n):\n        temp[arr[i]] = i\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if visited[i] or temp[i] == i - 1:\n            continue\n        cycle_size = 0\n        j = i\n        while not visited[j]:\n            visited[j] = True\n            j = temp[j] + 1\n            cycle_size += 1\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans\nn = int(input())\narr = list(map(int, input().split()))\nprint(min_swaps(arr))\n"
  ],
  [
    "import math\ndef isPrime(num):\n    if num < 2:\n        return False\n    else:\n        rootNum = math.floor(math.sqrt(num))\n        for i in range(2,rootNum+1):\n            if num % i == 0:\n                return False\n    return True\ndef solve():\n    lst = []\n    count = int(input())\n    for i in range(count):\n        ans = 0\n        l, r = map(int, input().split())\n        t = l\n        while t <= r:\n            if isPrime(t) and isPrime((t+1)/2):\n                ans += 1\n            t += 2\n        lst.append(str(ans))\n    print('\\n'.join(lst))\nsolve()"
  ],
  [
    "  from typing import List\ndef get_min_diff(cards: List[int]) -> int:\n    cards.sort()\n    n = len(cards)\n    if n == 2:\n        return abs(cards[0] - cards[1])\n    if n % 2 == 0:\n        return min(abs(cards[0] - cards[1]), abs(cards[n // 2] - cards[n // 2 - 1]))\n    else:\n        return min(abs(cards[0] - cards[n // 2]), abs(cards[n // 2] - cards[n - 1]))\ndef main():\n    n = int(input())\n    cards = list(map(int, input().split()))\n    print(get_min_diff(cards))\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "def getsum(BITTree,i):\n    s = 0\n    i = i+1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & (-i)\n    return s\ndef updatebit(BITTree , n , i ,v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & (-i)\ndef construct(arr, n):\n    BITTree = [0]*(n+1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\nN = int(input())\nS = input()\nBIT = [construct([0]*(N+1),N+1) for k in range(26)]\nfor k in range(N):\n    updatebit(BIT[ord(S[k])-97],N,k,1)\nfor _ in range(int(input())):\n    l = list(input().split())\n    if l[0] == \"1\":\n        updatebit(BIT[ord(S[int(l[1])-1])-97],N,int(l[1])-1,-1)\n        S = S[:int(l[1])-1] + l[2] + S[int(l[1]):]\n        updatebit(BIT[ord(l[2])-97],N,int(l[1])-1,1)\n    else:\n        t = 0\n        a, b = int(l[1])-1, int(l[2])-1\n        for k in range(26):\n            if getsum(BIT[k],b)-getsum(BIT[k],a-1) > 0:\n                t += 1\n        print(t)"
  ],
  [
    "h, w, k = map(int, input().split())\nmod = 10 ** 9 + 7\ndp = [[0] * (w + 1) for _ in range(h + 1)]\nfor i in range(w + 1):\n  dp[0][i] = 1 if i == 1 else 0\ndef calc_pow(from_col, to_col):\n  assert(1<=from_col<=w and 1<=to_col<=w)\n  if from_col == 1 or to_col == 1 or from_col == w or to_col == w:\n    return pow(2, max(w-1-2, 0), mod)\n  else:\n    return pow(2, max(w-1-3, 0), mod)\nfor t in range(1, h + 1):\n  for i in range(1, w + 1):\n    pattern_1 = dp[t-1][i-1] * calc_pow(i-1, i) if i > 1 else 0\n    pattern_2 = dp[t-1][i+1] * calc_pow(i+1, i) if i < w else 0\n    pattern_3 = dp[t-1][i] * (pow(2, max(w-1-2, 0), mod) if 1 < i < w else pow(2, max(w-1-1, 0), mod))\n    dp[t][i] = (pattern_1 + pattern_2 + pattern_3) % mod\nprint(dp[h][k])"
  ],
  [
    "def solve(n, k, a, f):\n    a.sort()\n    f.sort(reverse=True)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, (a[i] - min(k, i)) * f[i])\n    return ans\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nf = list(map(int, input().split()))\nprint(solve(n, k, a, f))\n"
  ],
  [
    "import sys\nfrom math import sqrt\nfrom collections import deque\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\nN,K=MAP()\nA=LIST()\nsm=sum(A)\ndef divisor_set(N: int) -> set:\n    s = {1, N}\n    for i in range(2, int(sqrt(N))+1):\n        if N % i == 0:\n            s.add(i)\n            s.add(N // i)\n    return s\ndivs=sorted(divisor_set(sm), reverse=True)\nfor div in divs:\n    B=[]\n    for i in range(N):\n        if A[i]%div!=0:\n            B.append(A[i]%div)\n    B.sort()\n    B=deque(B)\n    cnt=0\n    while len(B):\n        dista=B[0]%div\n        distb=div-B[-1]%div\n        if dista>distb:\n            B[0]-=distb\n            B.pop()\n            cnt+=distb\n        elif dista<distb:\n            B[-1]-=dista\n            B.popleft()\n            cnt+=dista\n        else:\n            B.pop()\n            B.popleft()\n            cnt+=dista\n    if cnt<=K:\n        print(div)\n        exit()"
  ],
  [
    "import sys\ninput = sys.stdin.readline\ndef I(): return int(input())\ndef MI(): return map(int, input().split())\ndef LI(): return list(map(int, input().split()))\ndef main():\n    mod=10**9+7\n    N=I()\n    A=LI()\n    A.sort(reverse=True)\n    ans=sum(A)-A[-1]-A[-2]+A[1]\n    print(ans)\nmain()"
  ],
  [
    "n= [int(i) for i in input().split()]\nn.sort()\nif n[0]+n[1]==n[2]:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
  ],
  [
    "n, h = map(int, input().split())\nkatana = []\nfor _ in range(n):\n  a, b = map(int, input().split())\n  katana.append((a, b))\nkatana.sort(key=lambda x: x[1], reverse=True)\nattacks = 0\ndamage = 0\nfor a, b in katana:\n  while damage + a < h:\n    attacks += 1\n    damage += a\n  attacks += 1\n  damage += b\nprint(attacks)\n"
  ],
  [
    "x1, y1, x2, y2 = map(int, input().split())\ndx = x2 - x1\ndy = y1 - y2\nx3 = x2 - dy\ny3 = y2 - dx\nx4 = x1 - dy\ny4 = y1 - dx\nprint(x3, y3, x4, y4)\n"
  ],
  [
    "N = int(input())\nsyain = [0] * N\nx = (input()).split(\" \")\nxid = [int(s) for s in x]\nfor t in xid:\n    syain[t-1] += 1\nprint(syain)"
  ],
  [
    "N = int(input())\ndata = list(map(int, input().split()))\nfor i in range(N):\n    data[i] -= (i + 1)\nave = sum(data) / N\nkey = int(ave)\nkey1 = key + 1\ndata.sort()\nsumdata = 0\nsumdata1 = 0\nfor i in data:\n    sumdata += abs(i - key)\n    sumdata1 += abs(i - key1)\nprint(min([sumdata, sumdata1]))"
  ],
  [
    "data_num = [int(i) for i in input().split(\" \")]\ndata = [input() for i in range(data_num[0])]\nfor i in data:\n  \tprint(i)\t\n  \tprint(i)"
  ],
  [
    "N = int(input())\nA = [int(input()) for i in range(N)]\nfor i in range(N):\n    A_temp = A[:i] + A[i+1:]\n    print(max(A_temp))"
  ],
  [
    "s = input()\ndef cal(n):\n    if len(s) == 1:\n        return 0\n    else:\n        new = s[0]\n        ans = 0\n        cnt = 0\n        for i in range(1, n):\n            if s[i] != new:\n                new = s[i]\n                cnt = 0\n                ans += (i + 1)\n            else:\n                cnt += 1\n                ans += cnt\n        return ans"
  ],
  [
    "def main():\n  N=int(input())\n  a=list(map(int,input().split()))\n  p=max(a)\n  m=len(bin(p))-2\n  for i in range(N):\n    b=len(bin(a[i]))-2\n    ans=0\n    for j in range(b):\n      if a[i]>>j&1==1:\n        if j==m-1 or j==0:\n          ans+=pow(2,j)\n        else:\n          ans-=pow(2,j)\n      else:\n        if j==m-1 or j==0:\n          continue\n        ans+=pow(2,j)\n    print(ans,end=' ')\nif __name__=='__main__':\n  main()"
  ],
  [
    "A, B = map(int, input().split())\nstart_time = (A + B) % 24\nprint(start_time)\n"
  ],
  [
    "n, c = map(int, input().split())\nx = [list(map(int, input().split())) for i in range(n)]\nclass SegmentTree(object):\n    __slots__ = [\"elem_size\", \"tree\", \"default\", \"op\"]\n    def __init__(self, a: list, default: int, op):\n        from math import ceil, log\n        real_size = len(a)\n        self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n        self.tree = tree = [default] * (elem_size * 2)\n        tree[elem_size:elem_size + real_size] = a\n        self.default = default\n        self.op = op\n        for i in range(elem_size - 1, 0, -1):\n            tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    def get_value(self, x: int, y: int) -> int:  \n        l, r = x + self.elem_size, y + self.elem_size\n        tree, result, op = self.tree, self.default, self.op\n        while l < r:\n            if l & 1:\n                result = op(tree[l], result)\n                l += 1\n            if r & 1:\n                r -= 1\n                result = op(tree[r], result)\n            l, r = l >> 1, r >> 1\n        return result\n    def set_value(self, i: int, value: int) -> None:\n        k = self.elem_size + i\n        self.tree[k] = value\n        self.update(k)\n    def update(self, i: int) -> None:\n        op, tree = self.op, self.tree\n        while i > 1:\n            i >>= 1\n            tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\nr = [[0, 0, 0]]\nfor i in range(n):\n    a, b = x[i]\n    s = r[-1][0] + b - (a + r[-1][1])\n    r.append([s, -a, i + 1])\nl = [[0, 0] for i in range(n + 1)]\nl[-2] = [x[-1][1] - (c - x[-1][0]), x[-1][0]]\nfor i in range(2, n + 1):\n    a, b = x[-i]\n    s = l[-i][0] + b - (l[-i][1] - a)\n    l[-i - 1] = [s, a]\nl[-1][1] = c\nrs = sorted(r, reverse=True)\nnow = 0\nrm = [[0] * 2 for i in range(n + 1)]\nfor i in range(n, 0, -1):\n    if i >= rs[now][2]:\n        rm[i] = [rs[now][0], rs[now][1]]\n    else:\n        while i < rs[now][2]:\n            now += 1\n        rm[i] = [rs[now][0], rs[now][1]]\nans = 0\nfor i in range(n + 1):\n    count = l[i][0] + rm[i][0] - min(c - l[i][1], -rm[i][1])\n    ans = max(ans, count)\nprint(ans)"
  ],
  [
    "MOD = 10**9 + 7\ndef solve(s):\n    n = len(s)\n    dp = [[0] * 3 for _ in range(n)]\n    for i in range(n):\n        if s[i] == 'A':\n            dp[i][0] = 1\n        elif s[i] == 'B':\n            dp[i][1] = 1\n        elif s[i] == 'C':\n            dp[i][2] = 1\n        else:\n            dp[i][0] = dp[i][1] = dp[i][2] = 1\n        if i > 0:\n            dp[i][0] = (dp[i][0] + dp[i-1][0]) % MOD\n            dp[i][1] = (dp[i][1] + dp[i-1][1]) % MOD\n            dp[i][2] = (dp[i][2] + dp[i-1][2]) % MOD\n    ans = 0\n    for i in range(n):\n        if s[i] == 'A':\n            for j in range(i+1, n):\n                if s[j] == 'B':\n                    for k in range(j+1, n):\n                        if s[k] == 'C':\n                            ans = (ans + dp[i][0] * dp[j][1] * dp[k][2]) % MOD\n        elif s[i] == 'B':\n            for j in range(i+1, n):\n                if s[j] == 'C':\n                    for k in range(j+1, n):\n                        if s[k] == 'A':\n                            ans = (ans + dp[i][1] * dp[j][2] * dp[k][0]) % MOD\n        elif s[i] == 'C':\n            for j in range(i+1, n):\n                if s[j] == 'A':\n                    for k in range(j+1, n):\n                        if s[k] == 'B':\n                            ans = (ans + dp[i][2] * dp[j][0] * dp[k][1]) % MOD\n        elif s[i] == '?':\n            for j in range(i+1, n):\n                if s[j] == 'B':\n                    for k in range(j+1, n):\n                        if s[k] == 'C':\n                            ans = (ans + dp[i][0] * dp[j][1] * dp[k][2]) % MOD\n                        elif s[k] == '?':\n                            ans = (ans + dp[i][0] * dp[j][1] * dp[k][0]) % MOD\n                            ans = (ans + dp[i][0] * dp[j][1] * dp[k][1]) % MOD\n                            ans = (ans + dp[i][0] * dp[j][1] * dp[k][2]) % MOD\n                elif s[j] == 'C':\n                    for k in range(j+1, n):\n                        if s[k] == 'A':\n                            ans = (ans + dp[i][0] * dp[j][2] * dp[k][0]) % MOD\n                            ans = (ans + dp[i][1] * dp[j][2] * dp[k][0]) % MOD\n                            ans = (ans + dp[i][2] * dp[j][2] * dp[k][0]) % MOD\n                elif s[j] == '?':\n                    for k in range(j+1, n):\n                        if s[k] == 'C':\n                            ans = (ans + dp[i][0] * dp[j][0] * dp[k][2]) % MOD\n                            ans = (ans + dp[i][0] * dp[j][1] * dp[k][2]) % MOD\n                            ans = (ans + dp[i][0] * dp[j][2] * dp[k][2]) % MOD\n                        elif s[k] == 'A':\n                            ans = (ans + dp[i][0] * dp[j]["
  ],
  [
    "O = input()\nE = input()\npassword = ''\ni = 0\nj = 0\nwhile i < len(O) or j < len(E):\n    if i < len(O):\n        password += O[i]\n        i += 1\n    if j < len(E):\n        password += E[j]\n        j += 1\nprint(password)\n"
  ],
  [
    "N, C = map(int, input().split())\nD = [list(map(int, input().split())) for _ in range(C)]\nG = [list(map(int, input().split())) for _ in range(N)]\ng1 = []\ng2 = []\ng3 = []\nfor i in range(N):\n    for j in range(N):\n        G[i][j] -= 1\n        if (i + j) % 3 == 0:\n            g1.append(G[i][j])\n        if (i + j) % 3 == 1:\n            g2.append(G[i][j])\n        if (i + j) % 3 == 2:\n            g3.append(G[i][j])\nfor k in range(C):\n    for i in range(C):\n        for j in range(C):\n            D[i][j] = min(D[i][j], D[i][k] + D[k][j])\nans = float('inf')\nfor c1 in range(C):\n    for c2 in range(C):\n        for c3 in range(C):\n            if c1 == c2 or c2 == c3 or c3 == c1:\n                continue\n            temp = sum(D[clr_g1][c1] for clr_g1 in g1)\n            temp += sum(D[clr_g2][c2] for clr_g2 in g2)\n            temp += sum(D[clr_g3][c3] for clr_g3 in g3)\n            ans = min(ans, temp)\nprint(ans)"
  ],
  [
    "n = int(input())\nv = []\nfor i in range(n):\n    v.append(int(input()))\nv.sort()\ns = 0\nwhile len(v) > 1:\n    v0 = v.pop(0)\n    v1 = v.pop(0)\n    v.append((v0 + v1) / 2)\n    v.sort()\nprint(v[0])"
  ],
  [
    "N = int(input())\ns = str(N)\nif s[0] == s[2]:\n  print(\"Yes\")\nelse:\n  print(\"No\")\n"
  ],
  [
    "n, y = map(int,input().split())\ny = y / 1000\nf = 0\nfor i in range(n + 1):\n    for j in range(n - i + 1):\n        if 10 * i + 5 * j + (n - i - j) == y:\n            print(i, j, n - i - j)\n            f = 1\n            break\n    if f == 1:\n        break\nif f == 0:\n    print(-1, -1, -1)"
  ],
  [
    "def cake_cutting(cake, pieces):\n    for i in range(len(cake)):\n        for j in range(len(cake[i])):\n            pieces[i][j] = False\n    for i in range(len(cake)):\n        for j in range(len(cake[i])):\n            if cake[i][j]:\n                for k in range(i+1, len(cake)):\n                    if not cake[k][j]:\n                        pieces[i][j] = True\n                        break\n                if not pieces[i][j]:\n                    for k in range(j+1, len(cake[i])):\n                        if not cake[i][k]:\n                            pieces[i][j] = True\n                            break\n    for i in range(len(pieces)):\n        for j in range(len(pieces[i])):\n            if pieces[i][j]:\n                print(i, j, \"contains a strawberry\")\n"
  ],
  [
    "N = list(map(int,input().split()))\nprint(N.index(0) + 1)"
  ],
  [
    "import bisect\nN = int(input())\nA = [int(input()) for _ in range(N)]\ndp = [A[0]]\nfor i in A[1:]:\n    if i > dp[-1]:\n        dp.append(i)\n    else:\n        dp[bisect.bisect_left(dp, i)] = i\nprint(N - len(dp) + 1)"
  ],
  [
    "def get_max_value(numbers):\n    max_value = 0\n    sequence = []\n    numbers.sort(reverse=True)\n    for i in range(len(numbers)):\n        x = numbers[i]\n        y = numbers[i + 1]\n        result = x - y\n        if result > max_value:\n            max_value = result\n            sequence.append((x, y))\n    return max_value, sequence\nprint(get_max_value([1, -1, 2]))  \nprint(get_max_value([1, 1, 1]))  \n"
  ],
  [
    "import numpy as np\nn, m = map(int, input().split())\ns = list(map(int, input().split()))\nt = np.array(list(map(int, input().split())))\nmod = 10**9 + 7\ndp = np.ones(m+1, dtype='int64')\nfor i in s:\n    dp[1:] = ((dp[:-1] * (i == t)).cumsum() + dp[1:]) % mod\n    print(dp)\nprint(dp[-1])"
  ],
  [
    "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nN = int(input())\ne = [0] * (N+1)\nfor i in range(2, N+1):\n    cur = i\n    for j in range(2, i+1):\n        while cur % j == 0:\n            e[j] += 1\n            cur //= j\ndef num(n):\n    return len(list(filter(lambda x: x >= n-1, e)))\nprint(num(75) + num(25)*(num(3)-1) + num(15)*(num(5)-1) + num(5)*(num(5)-1)*(num(3)-2)//2)"
  ],
  [
    "s = input()\nfor n in range(1, len(s) - 1):\n    s = s[:-2]\n    if s[:len(s) // 2] == s[len(s) // 2:]:\n        break\nprint(len(s))"
  ],
  [
    "def find_shortest_sequence(n, m, s):\n    shortest_sequence = []\n    shortest_length = float('inf')\n    for sequence in itertools.product(range(1, m + 1), repeat=n):\n        if is_valid_sequence(sequence, s):\n            length = len(sequence)\n            if length < shortest_length:\n                shortest_sequence = sequence\n                shortest_length = length\n    return shortest_sequence\ndef is_valid_sequence(sequence, s):\n    current_square = 0\n    num_turns = 0\n    for x in sequence:\n        if s[current_square] == 1:\n            return False\n        current_square += x\n        if current_square > n:\n            return False\n        num_turns += 1\n    return True\nn = 19\nm = 3\ns = '0001000100'\nprint(find_shortest_sequence(n, m, s))\n"
  ],
  [
    "S = list(input())\ni, j = 0, len(S) - 1\nans = 0\nwhile i < j:\n    if S[i] == S[j]:\n        i += 1\n        j -= 1\n    elif S[i] == 'x':\n        i += 1\n        ans += 1\n    elif S[j] == 'x':\n        j -= 1\n        ans += 1\n    else:\n        print('-1')\n        break\nelse:\n    print(ans)"
  ],
  [
    "def count_altars(N, A, B, C):\n    count = 0\n    for i in range(N):\n        for j in range(N):\n            for k in range(N):\n                if B[j] > A[i] and C[k] > B[j]:\n                    count += 1\n    return count\n"
  ],
  [
    "a = input()\nb = [i for i in a]\nif b[0] == \"?\":\n    b[0] = \"D\"\nfor i in range(1, len(t) - 1):\n    if b[i] == \"?\":\n        if b[i-1] == \"D\" and b[i+1] == \"D\":\n            b[i] = \"P\"\n        elif b[i-1] == \"D\" and b[i+1] == \"?\":\n            b[i] = \"P\"\n        else:\n            b[i] = \"D\"\nif b[-1] == \"?\":\n    b[-1] = \"D\"\nprint(\"\".join(b))"
  ],
  [
    "n = int(input())\nl = list(map(int, input().split()))\nl.sort()\ncount = 0\nfor i in range(n - 2):\n  for j in range(i + 1, n - 1):\n    for k in range(j + 1, n):\n      if l[i] != l[j] and l[j] != l[k] and l[i] != l[k] and l[i] + l[j] > l[k] and l[j] + l[k] > l[i] and l[i] + l[k] > l[j]:\n        count += 1\nprint(count)\n"
  ],
  [
    "N=int(input())\nb = list(map(int, input().split()))\nans=[]\nfor i in range(N):\n    j = 1\n    if j < len(b):\n        while b[j] == j + 1:\n            j += 1\n            if j == len(b):break\n    if b[j - 1] == j:\n        del b[j-1]\n        ans.append(j)\n    else:\n        print(-1)\n        import sys\n        sys.exit()\nfor i in range(len(ans)-1,-1,-1):\n    print(ans[i])"
  ],
  [
    "N = int(input())\nS = list(input())\nl_point = 0\nleft_first = S.index(\"(\")\nfor i in range(left_first, N):\n    if S[i] == \"(\":\n        l_point += 1\n    else:\n        l_point -= 1\nr_point = 0\nT = S[::-1]\nright_first = T.index(\")\")\nfor j in range(right_first, N):\n    if T[j] == \")\":\n        r_point += 1\n    else:\n        r_point -= 1\nmigi = \")\" * max(0, l_point)\nhidari = \"(\" * max(0, r_point)\ncenter = \"\".join(S)\nprint(hidari + center + migi)"
  ],
  [
    "import sys\ndef floyd_warshall(cost_matrix):\n    for k in range(10):\n        for i in range(10):\n            for j in range(10):\n                cost_matrix[i][j] = min(cost_matrix[i][j], cost_matrix[i][k] + cost_matrix[k][j])\n    return cost_matrix\ndef min_cost(cost_matrix, wall):\n    h, w = len(wall), len(wall[0])\n    dp = [[float('inf')] * 10 for _ in range(h)]\n    dp[0][1] = 0\n    for i in range(h):\n        for j in range(w):\n            if wall[i][j]!= -1:\n                for k in range(10):\n                    dp[i][k] = min(dp[i][k], dp[i-1][wall[i][j]] + cost_matrix[wall[i][j]][k])\n            else:\n                for k in range(10):\n                    dp[i][k] = min(dp[i][k], dp[i-1][k])\n    return min(dp[-1])\ndef main():\n    h, w = map(int, sys.stdin.readline().split())\n    cost_matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(10)]\n    wall = [list(map(int, sys.stdin.readline().split())) for _ in range(h)]\n    cost_matrix = floyd_warshall(cost_matrix)\n    print(min_cost(cost_matrix, wall))\nif __name__ == '__main__':\n    main()\n"
  ],
  [
    "a, b, c = map(int, input().split())\nif a + c == b or b + c == a:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
  ],
  [
    "def September9(num):\n    if (num // 10) == 9: \n        print(\"Yes\")\n    elif (num % 10) == 9:    \n        print(\"Yes\")\n    else:\n        print(\"No\")\nif __name__ == \"__main__\":\n    while True:\n        try:\n            N = int( input(\"2N:\" ))\n            if (10 <= N) and (N <= 99):\n                break\n            else:\n                print(\"2\")\n                print(\"-----------------------------------------\")\n                continue\n        except ValueError:\n            print(\"2N\")\n            print(\"-----------------------------------------\")\n    print(\" \n    September9(N) "
  ],
  [
    "s1=input()\ns2=input()\nl1 = list(s1)\nl2 = list(s2)\ncnt=0\nfor i in range(len(l1)):\n    if l1[i]==l2[-i-1]:\n        cnt+=1\nif cnt == 3:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
  ],
  [
    "n = int(input())\notoshidama = {\"JPY\":0, \"BTC\":0}\nfor i in range(n):\n    a, b = map(str, input().split())\n    a = float(a)\n    if b == \"JPY\":\n        otoshidama[\"JPY\"] = otoshidama[\"JPY\"] + a\n    else:\n        otoshidama[\"BTC\"] = otoshidama[\"BTC\"] + a\nans = otoshidama[\"JPY\"] + otoshidama[\"BTC\"] * 380000.0\nprint(ans)"
  ],
  [
    "n, t = map(int, input().split())\nl = [tuple(map(int, input().split())) for i in range(n)]\nm = sorted([i for i in l if i[1] <= t], key=lambda x: x[0])\nprint(m[0][0])"
  ],
  [
    "X, Y = map(int, input().split())\nv = [300000, 200000, 100000]\nx = 0\ny = 0\nif X <= 3:\n    x = v[X-1]\nif Y <= 3:\n    y = v[Y-1]\nprint(x + y + 400000 * (X==1 and Y==1))"
  ],
  [
    "  def get_kth_char(s, k):\n    for i in range(500000000000000):\n        s = s.replace('1', '11').replace('2', '22').replace('3', '333').replace('4', '4444').replace('5', '55555').replace('6', '666666').replace('7', '7777777').replace('8', '88888888').replace('9', '999999999')\n    return s[k-1]\ns = input()\nk = int(input())\nprint(get_kth_char(s, k))"
  ],
  [
    "a, b = map(int, input().split())\nif a == b:\n    print(\"Draw\")\nelif a == 1 or b == 1:\n    print(\"Draw\")\nelif a > b:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")"
  ],
  [
    "n, m = list(map(int, input().split()))\nheight = [int(i) for i in input().split()]\ntele = {}\nfor num, h in enumerate(height, 1):\n    tele[num] = [h, \"G\"]\nfor roads in range(m):\n    a, b = list(map(int, input().split()))\n    if (tele[a][0] < tele[b][0]):\n        tele[a][1] = \"N\"\n    elif (tele[b][0] < tele[a][0]):\n        tele[b][1] = \"N\"\nans_list = tele.values()\nans = 0\nfor a in ans_list:\n    if (a[1] == \"G\"):\n        ans += 1\nprint(ans)"
  ],
  [
    "from collections import deque\ndef count_children(s):\n    n = len(s)\n    children = [1] * n\n    directions = [1 if c == 'R' else -1 for c in s]\n    for i in range(1, n - 1):\n        if directions[i] == 1:\n            children[i + 1] += children[i]\n            children[i] = 0\n        else:\n            children[i - 1] += children[i]\n            children[i] = 0\n    return children\ns = input()\nresult = count_children(s)\nprint(*result)\n"
  ],
  [
    "n = int(input())\ndist = [list(map(int, input().split())) for _ in range(n)]\ntotal_length = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if dist[i][j] < 0 or dist[i][j]!= dist[j][i]:\n            print(-1)\n            exit()\n        for k in range(n):\n            if dist[i][k] > dist[i][j] + dist[j][k]:\n                print(-1)\n                exit()\n        total_length += dist[i][j]\nprint(total_length)\n"
  ],
  [
    "from itertools import accumulate\nimport heapq as hq\nn,m = map(int,input().split())\nab = [list(map(int,input().split())) for i in range(n)]\nab.sort(key=lambda x: x[0])\nls = []\nhq.heapify(ls)\nk = max([a[0] for a in ab])\ndaylist = [0]*(k+1)\nfor i in range(n):\n  daylist[ab[i][0]] += 1\ndaylistsum = list(accumulate(daylist))\nans = 0\nfor i in range(1,m+1):\n  for j in range(daylistsum[i-1],daylistsum[i]):\n    hq.heappush(ls,-ab[j][1])\n  if ls:\n    ans -= hq.heappop(ls)\nprint(ans)"
  ],
  [
    "n, k = map(int, input().split())\nMOD = 10**9 + 7\ndef modcomb(n, a, mod):\n    cnt = 1\n    for i in range(a):\n        cnt *= (n - i)\n        cnt *= pow(i + 1, mod - 2, mod)\n        cnt %= mod\n    return cnt\ncnt1 = modcomb(2 * (n - 1) + k, n - 1, MOD)\ncnt2 = modcomb(2 * (n - 1) + k, n, MOD)\nans = (cnt1 + cnt2) % MOD\nprint(ans)"
  ],
  [
    "in = int(input())\na = in // 100\nb = (in % 100)\nc = b % 10\nb = b // 10\nif a == b and a == c:\n  pass\nelse:\n  a = a + 1\nprint('{}{}{}'.format(a, a, a))"
  ],
  [
    "transfer = min(c, a - b)\nc -= transfer\nprint(c)"
  ],
  [
    "n = input()\nb = list(n)\nc = 0\nd = 0\nwhile c <= len(b) - 3:\n    if (b[c+1] > b[c] and b[c+1] < b[c+2]) or (b[c+1] < b[c] and b[c+1] > b[c+2]):\n        d += 1\n        c += 1\n    else:\n        c += 1\nif len(set(b)) == 2 and d == 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
  ],
  [
    "x, y = map(int, input().split())\nif y != 1:\n    if x * (y - 1) % y == 0:\n        print(x * (y - 1))\n    else:\n        print(-1)\nelse:\n    print(-1)"
  ],
  [
    "a = input().split()\nprint(a.index('0') + 1)"
  ],
  [
    "import math\nn = int(input())\nA = list(map(int, input().split()))\nans = 1\nfor x in A:\n    ans = x * ans // math.gcd(ans, x)\nB = list(map(lambda x: ans // x, A))\nprint(int(sum(B) % (10**9 + 7)))"
  ],
  [
    "  import math\ndef get_min_score(N, K, A, F):\n    min_score = math.inf\n    max_sets = K\n    for i in range(max_sets + 1):\n        score = 0\n        for j in range(N):\n            time = A[j] * F[j]\n            score += time\n        if score < min_score:\n            min_score = score\n    return min_score\ndef main():\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    F = list(map(int, input().split()))\n    min_score = get_min_score(N, K, A, F)\n    print(min_score)\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "n, m = map(int, input().split())\nbroken_steps = set()\nfor _ in range(m):\n    broken_steps.add(int(input()))\ndp = [0] * (n + 1)\ndp[0] = 1\ndp[1] = 1\nfor i in range(2, n + 1):\n    if i in broken_steps:\n        continue\n    dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007\nprint(dp[n])"
  ],
  [
    "def getNum():\n    x,y,z = map(int,input().split())\n    return x,y,z\ndef cal(x,y,z):\n    tmp = (x - z) // (y + z)\n    print(tmp)\ndef main():\n    x,y,z = getNum()\n    cal(x,y,z)\nmain()"
  ],
  [
    "from datetime import datetime\ndate_string = input()\ndate = datetime.strptime(date_string, '%Y/%m/%d')\ntarget_date = datetime(2019, 4, 30)\nif date <= target_date:\n    print('Heisei')\nelse:\n    print('TBD')\n"
  ],
  [
    "N = int(input())\nseat = [0]*100000\nfor i in range(N):\n    li,ri = map(int,input().split())\n    for j in range(li,ri+1):\n        seat[j] += 1\nprint(sum(seat))"
  ],
  [
    "import sys\ninput = sys.stdin.readline\nN = int(input())\nS = [int(input()) for _ in range(N)]\nt = 0\nfor i in range(1, N - 1):\n    for j in range(i + 1, N):\n        for k in range(j + 1, N + 1):\n            if S[i - 1] != S[j - 1] and S[j - 1] != S[k - 1] and S[k - 1] != S[i - 1] and j - i != k - j:\n                t += 1\nprint(t)"
  ],
  [
    "n, m = map(int, input().split())\nts = [list(map(int, input().split()))[::-1]]\ncount = 0\nt = 0\nfor i in range(m):\n    if ts[i][1] >= t:\n        count += 1\n        t = ts[i][0]\nprint(count)"
  ],
  [
    "input_val = int(input())\nanswer = \"ABC\" + str(input_val)\nprint(answer)"
  ],
  [
    "import numpy\nn,d = map(int,input().split())\na=[]\nb=[]\ncnt = 0\nfor i in range(n):\n    x, y = map(int,input().split())\n    a.append(x)\n    b.append(y)\n    if numpy.sqrt(x**2+y**2)<=d:\n        cnt += 1\nprint(\"{}\".format(cnt))"
  ],
  [
    "n = int(input())\nnumbers = list(map(int, input().split()))\ntotal_sum = sum(numbers)\nmin_negative = float('inf')\nfor i in range(n):\n    if numbers[i] < 0 and abs(numbers[i]) < min_negative:\n        min_negative = abs(numbers[i])\n    elif numbers[i] > 0 and i % 2 == 1:\n        total_sum -= 2 * numbers[i]\nif sum(1 for num in numbers if num < 0) % 2 == 1:\n    total_sum -= 2 * min_negative\nprint(total_sum)\n"
  ],
  [
    "import sys\nreadline = sys.stdin.readline\nMOD = pow(10,9)+7\ndef combinations(n,k):\n    global fac, finv\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n-k] % MOD) % MOD\ndef main():\n    global fac, finv\n    N, K = map(int, readline().split())\n    A = list(map(int, readline().split()))\n    A.sort()\n    MAX_NUM = N + 1\n    fac  = [0 for _ in range(MAX_NUM)]\n    finv = [0 for _ in range(MAX_NUM)]\n    inv  = [0 for _ in range(MAX_NUM)]\n    fac[0]  = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n    for i in range(2,MAX_NUM):\n        fac[i] = fac[i-1] * i % MOD\n        inv[i] = MOD - inv[MOD%i] * (MOD // i) % MOD\n        finv[i] = finv[i-1] * inv[i] % MOD\n    summax = 0\n    summin = 0\n    for i in range(K+1):\n        j = N-i\n        tmp = combinations(j-1, K-1)\n        summax += A[j-1] * tmp\n        summin += A[i] * tmp\n    ans = (summax - summin) % MOD\n    print(ans)\nif __name__ == \"__main__\":\n    main()"
  ],
  [
    "n, m = map(int, input().split())\nships = []\nfor i in range(m):\n    ships.append(tuple(map(int, input().split())))\nreachable_from_1 = set()\nfor a, b in ships:\n    if a == 1:\n        reachable_from_1.add(b)\nfor island in reachable_from_1:\n    for a, b in ships:\n        if a == island and b == n:\n            print(\"POSSIBLE\")\n            exit()\nprint(\"IMPOSSIBLE\")"
  ],
  [
    "n = int(input())\narr = list(map(int,input().split()))\nif n % 2 == 0:\n    tp = sum(arr[::2])\n    print(max(sum(arr)-tp,tp))\nelif n == 3:\n    print(arr[0]+arr[2])\nelse:\n    hoge = -(10**12)\n    buf = [[hoge for i in range(3)] for j in range(n)]\n    buf[0][0] = arr[0]\n    buf[1][1] = arr[1]\n    buf[2][2] = arr[2]\n    buf[2][0] = arr[0]+arr[2]\n    for i in range(3,n):\n        buf[i][0] = buf[i-2][0] + arr[i]\n        buf[i][1] = max(buf[i-3][0] + arr[i],buf[i-2][1]+arr[i])\n        if i >= 4:\n            buf[i][2] = max([buf[i-3][1] + arr[i],buf[i-4][0] + arr[i],buf[i-2][2]+arr[i]])\n        else:\n            buf[i][2] = max([buf[i-3][1] + arr[i],buf[i-2][2]+arr[i]])\n    print(max(buf[-1][2],buf[-2][1],buf[-3][0]))"
  ],
  [
    "import sys\ndef turn_on_ac(temp):\n    if temp >= 30:\n        return \"Yes\"\n    else:\n        return \"No\"\nif __name__ == \"__main__\":\n    temp = int(sys.stdin.readline())\n    print(turn_on_ac(temp))\n"
  ],
  [
    "import numpy as np\nn = int(input())\na = list(map(int, input().split()))\nmax_stock = 1000000\ndp = [[] for _ in range(n+1)]\ndp[0] = [1000, 0]\nfor i in range(n):\n    for k in dp[i]:\n        dp[i+1].append(k) \n        if k[0] >= a[i]:\n            dp[i+1].append([k[0] - a[i], k[1] + 1]) \n        if k[1] > 0:\n            dp[i+1].append([k[0] + k[1]*a[i], k[1] - 1]) \nmax_ = 0\nfor i in dp[n]:\n    if i[0] > max_:\n        max_ = i[0]\nprint(max_)"
  ],
  [
    "n, m, k = map(int, input().split())\nmod = 10 ** 9 + 7\nres_n, res_m = 0, 0\nfor i in range(n):\n    for j in range(n):\n        res_n += abs(i - j)\n        res_n %= mod\nres_n = (res_n * (m ** 2)) % mod\nfor i in range(m):\n    for j in range(m):\n        res_m += abs(i - j)\n        res_m %= mod\nres_m = (res_m * (n ** 2)) % mod\nres = (res_n + res_m) // 2\nf = [1 for _ in range(n*m)]\nfor i in range(1, n*m):\n    f[i] = f[i-1] * i % mod\nres = res * f[n*m-2] * pow(f[k-2], mod-2, mod) * pow(f[n*m-k], mod-2, mod) % mod\nprint(res)"
  ],
  [
    "N = int(input())\nA = [False] * 10 ** 9\ncnt = 0\nfor i in range(N):\n  a = int(input())\n  if A[a - 1]:\n    cnt -= 1\n  else:\n    cnt += 1\n    A[a - 1] = True\nprint(cnt)"
  ],
  [
    "import collections\nN = int(input())\na = list(map(int, input().split()))\ncount = 0\na_1 = collections.Counter(a)\nfor k,v in a_1.items():\n    if k < v:\n        count += v-k\n    else:\n        count += v\nprint(count)"
  ],
  [
    "n = int(input())\nelements = list(map(int, input().split()))\nsum = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        sum += elements[i] * elements[j]\nprint(sum % (10**9 + 7))\n"
  ],
  [
    "import sys\nstdin = sys.stdin\ndef li(): return map(int, stdin.readline().split())\ndef li_(): return map(lambda x: int(x)-1, stdin.readline().split())\ndef lf(): return map(float, stdin.readline().split())\ndef ls(): return stdin.readline().split()\ndef ns(): return stdin.readline().rstrip()\ndef lc(): return list(ns())\ndef ni(): return int(stdin.readline())\ndef nf(): return float(stdin.readline())\nfrom collections import Counter\ns = lc()\ncnt = Counter(s)\nsr = s[::-1]\ncntr = Counter([])\ndelete = 0\nfor sri in sr:\n    alleven = True\n    cntr[sri] += 1\n    for cntrv in cntr.values():\n        if cntrv % 2 == 1:\n            alleven = False\n            break\n    if alleven:\n        delete = sum(cntr.values())\n        break\nprint(len(s) - delete)"
  ],
  [
    "import sys\nimport heapq, functools, collections\nimport random\nfrom collections import Counter, defaultdict\nk = int(input())\nprint(9 - (k - 400) // 200)"
  ],
  [
    "N,C = map(int,input().split())\nX = []\nV = []\nfor _ in range(N):\n    x,v = map(int,input().split())\n    X.append(x)\n    V.append(v)\nA = [0 for _ in range(N)]\nA[0] = V[0]-X[0]\nB = [0 for _ in range(N)]\nB[0] = max(0,A[0])\nfor i in range(1,N):\n    A[i] = A[i-1]+V[i]-X[i]+X[i-1]\n    B[i] = max(A[i],B[i-1])\ncmax = B[-1]\nv =0\nfor i in range(1,N):\n    v += V[-i]\n    cmax = max(cmax,v-(C-X[-i]),v-2*(C-X[-i])+B[-i-1])\ncmax = max(cmax,v+V[0]-(C-X[0]))\nprint(cmax)"
  ],
  [
    "def xor(a, b):\n  return a ^ b\ndef solve(M, K):\n  N = 1 << (M + 1)\n  a = [0] * N\n  used = [False] * (1 << M)\n  for i in range(N // 2):\n    for j in range(1 << M):\n      if not used[j]:\n        a[2 * i] = j\n        a[2 * i + 1] = j ^ K\n        used[j] = True\n        break\n  if all(used):\n    return a\n  else:\n    return [-1]\nM, K = map(int, input().split())\na = solve(M, K)\nif a == [-1]:\n  print(-1)\nelse:\n  for x in a:\n    print(x, end=\" \")"
  ],
  [
    "n=int(input())\na=sorted([int(i) for i in input().split()])[::-1]\nb=[a[0],a[1]]\nans=a[0]\nfor i in range(n-2):\n    if b[0]<=b[1]:\n        ans+=b[0]\n        b=b[1:]\n        b+=[a[i+2]]\n    else:\n        ans+=b[1]\n        b=b[:1]\n        b+=[a[i+2]]\nprint(ans)"
  ],
  [
    "n=int(input())\nans=0\nn_5=0\nn_2=0\nif n%2==0:\n    for i in range(1,19):\n        ans+=n//(10**i)\nx=n//10\nfor i in range(1,26):\n    n_5+=x//(5**i)\nfor i in range(1,18):\n    n_2+=x//(2**i)\nans+=min(n_5,n_2)\nprint(ans)"
  ],
  [
    "N = int(input())\na = list(map(int, input().split()))\na.sort()\nt = 0\nflag = 1\nsum_a = 0\nfor i in range(N):\n    sum_a += a[i]\n    if i < N-1 and sum_a * 2 < a[i+1]:\n        t = i+1\n        flag = 0\n    if flag == 0:\n        break\nprint(N - t)"
  ],
  [
    "for i in range(1, 6):\n  if eval(f\"x_{i}\") == 0:\n    print(i)\n    break\n  else:\n    continue\n"
  ],
  [
    "def counting(numbers: list):\n    count = 0\n    for i in range(1, len(numbers) - 1):\n        pre = int(numbers[i-1])\n        curr = int(numbers[i])\n        next_ = int(numbers[i+1])\n        if pre < curr < next_ or pre > curr > next_:\n            count += 1\n    return count\n_ = input()\nnumbers_str = input()\nresult = counting(numbers_str.split())\nprint(result)"
  ]
]